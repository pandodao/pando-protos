// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: sweeper/v1/sweeper.proto
/* eslint-disable */

import type { ByteSource, ClientConfiguration } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

//========================================//
//     SweeperService Protobuf Client     //
//========================================//

export async function SendTransfer(
  sendTransferRequest: SendTransferRequest,
  config?: ClientConfiguration
): Promise<SendTransferResponse> {
  const response = await PBrequest(
    "/sweeper.v1.SweeperService/SendTransfer",
    SendTransferRequest.encode(sendTransferRequest),
    config
  );
  return SendTransferResponse.decode(response);
}

export async function SendTransfers(
  sendTransfersRequest: SendTransfersRequest,
  config?: ClientConfiguration
): Promise<SendTransfersResponse> {
  const response = await PBrequest(
    "/sweeper.v1.SweeperService/SendTransfers",
    SendTransfersRequest.encode(sendTransfersRequest),
    config
  );
  return SendTransfersResponse.decode(response);
}

export async function GetTransfer(
  getTransferRequest: GetTransferRequest,
  config?: ClientConfiguration
): Promise<GetTransferResponse> {
  const response = await PBrequest(
    "/sweeper.v1.SweeperService/GetTransfer",
    GetTransferRequest.encode(getTransferRequest),
    config
  );
  return GetTransferResponse.decode(response);
}

export async function GetBalances(
  getBalancesRequest: GetBalancesRequest,
  config?: ClientConfiguration
): Promise<GetBalancesResponse> {
  const response = await PBrequest(
    "/sweeper.v1.SweeperService/GetBalances",
    GetBalancesRequest.encode(getBalancesRequest),
    config
  );
  return GetBalancesResponse.decode(response);
}

//========================================//
//       SweeperService JSON Client       //
//========================================//

export async function SendTransferJSON(
  sendTransferRequest: SendTransferRequest,
  config?: ClientConfiguration
): Promise<SendTransferResponse> {
  const response = await JSONrequest(
    "/sweeper.v1.SweeperService/SendTransfer",
    SendTransferRequestJSON.encode(sendTransferRequest),
    config
  );
  return SendTransferResponseJSON.decode(response);
}

export async function SendTransfersJSON(
  sendTransfersRequest: SendTransfersRequest,
  config?: ClientConfiguration
): Promise<SendTransfersResponse> {
  const response = await JSONrequest(
    "/sweeper.v1.SweeperService/SendTransfers",
    SendTransfersRequestJSON.encode(sendTransfersRequest),
    config
  );
  return SendTransfersResponseJSON.decode(response);
}

export async function GetTransferJSON(
  getTransferRequest: GetTransferRequest,
  config?: ClientConfiguration
): Promise<GetTransferResponse> {
  const response = await JSONrequest(
    "/sweeper.v1.SweeperService/GetTransfer",
    GetTransferRequestJSON.encode(getTransferRequest),
    config
  );
  return GetTransferResponseJSON.decode(response);
}

export async function GetBalancesJSON(
  getBalancesRequest: GetBalancesRequest,
  config?: ClientConfiguration
): Promise<GetBalancesResponse> {
  const response = await JSONrequest(
    "/sweeper.v1.SweeperService/GetBalances",
    GetBalancesRequestJSON.encode(getBalancesRequest),
    config
  );
  return GetBalancesResponseJSON.decode(response);
}

//========================================//
//             SweeperService             //
//========================================//

export interface SweeperService<Context = unknown> {
  SendTransfer: (
    sendTransferRequest: SendTransferRequest,
    context: Context
  ) => Promise<SendTransferResponse> | SendTransferResponse;
  SendTransfers: (
    sendTransfersRequest: SendTransfersRequest,
    context: Context
  ) => Promise<SendTransfersResponse> | SendTransfersResponse;
  GetTransfer: (
    getTransferRequest: GetTransferRequest,
    context: Context
  ) => Promise<GetTransferResponse> | GetTransferResponse;
  GetBalances: (
    getBalancesRequest: GetBalancesRequest,
    context: Context
  ) => Promise<GetBalancesResponse> | GetBalancesResponse;
}

export function createSweeperService<Context>(
  service: SweeperService<Context>
) {
  return {
    name: "sweeper.v1.SweeperService",
    methods: {
      SendTransfer: {
        name: "SendTransfer",
        handler: service.SendTransfer,
        input: { protobuf: SendTransferRequest, json: SendTransferRequestJSON },
        output: {
          protobuf: SendTransferResponse,
          json: SendTransferResponseJSON,
        },
      },
      SendTransfers: {
        name: "SendTransfers",
        handler: service.SendTransfers,
        input: {
          protobuf: SendTransfersRequest,
          json: SendTransfersRequestJSON,
        },
        output: {
          protobuf: SendTransfersResponse,
          json: SendTransfersResponseJSON,
        },
      },
      GetTransfer: {
        name: "GetTransfer",
        handler: service.GetTransfer,
        input: { protobuf: GetTransferRequest, json: GetTransferRequestJSON },
        output: {
          protobuf: GetTransferResponse,
          json: GetTransferResponseJSON,
        },
      },
      GetBalances: {
        name: "GetBalances",
        handler: service.GetBalances,
        input: { protobuf: GetBalancesRequest, json: GetBalancesRequestJSON },
        output: {
          protobuf: GetBalancesResponse,
          json: GetBalancesResponseJSON,
        },
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Transfer {
  traceId: string;
  assetId: string;
  amount: string;
  opponents: string[];
  threshold: number;
  memo: string;
  status: Transfer.Status;
  txHash: string;
}

export declare namespace Transfer {
  export type Status = "NOT_SET" | "PENDING" | "HANDLED" | "SPENT";
}

export interface Balance {
  assetId: string;
  amount: string;
  count: number;
}

export interface SendTransferRequest {
  traceId: string;
  assetId: string;
  amount: string;
  opponents: string[];
  threshold: number;
  memo: string;
}

export interface SendTransferResponse {}

export interface SendTransfersRequest {
  transfers: SendTransferRequest[];
}

export interface SendTransfersResponse {}

export interface GetTransferRequest {
  traceId: string;
}

export interface GetTransferResponse {
  transfer: Transfer;
}

export interface GetBalancesRequest {}

export interface GetBalancesResponse {
  balances: Balance[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: Partial<Transfer>): Uint8Array {
    return Transfer._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      status: Transfer.Status._fromInt(0),
      txHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Transfer>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.traceId) {
      writer.writeString(1, msg.traceId);
    }
    if (msg.assetId) {
      writer.writeString(2, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(3, msg.amount);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(4, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeUint32(5, msg.threshold);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    if (msg.status && Transfer.Status._toInt(msg.status)) {
      writer.writeEnum(7, Transfer.Status._toInt(msg.status));
    }
    if (msg.txHash) {
      writer.writeString(8, msg.txHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, reader: BinaryReader): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.traceId = reader.readString();
          break;
        }
        case 2: {
          msg.assetId = reader.readString();
          break;
        }
        case 3: {
          msg.amount = reader.readString();
          break;
        }
        case 4: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 5: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        case 7: {
          msg.status = Transfer.Status._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          msg.txHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    HANDLED: "HANDLED",
    SPENT: "SPENT",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "HANDLED";
        }
        case 3: {
          return "SPENT";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "HANDLED": {
          return 2;
        }
        case "SPENT": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Balance = {
  /**
   * Serializes Balance to protobuf.
   */
  encode: function (msg: Partial<Balance>): Uint8Array {
    return Balance._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Balance from protobuf.
   */
  decode: function (bytes: ByteSource): Balance {
    return Balance._readMessage(Balance.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Balance with all fields set to their default value.
   */
  initialize: function (): Balance {
    return {
      assetId: "",
      amount: "",
      count: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Balance>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(2, msg.amount);
    }
    if (msg.count) {
      writer.writeInt32(3, msg.count);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Balance, reader: BinaryReader): Balance {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.amount = reader.readString();
          break;
        }
        case 3: {
          msg.count = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SendTransferRequest = {
  /**
   * Serializes SendTransferRequest to protobuf.
   */
  encode: function (msg: Partial<SendTransferRequest>): Uint8Array {
    return SendTransferRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SendTransferRequest from protobuf.
   */
  decode: function (bytes: ByteSource): SendTransferRequest {
    return SendTransferRequest._readMessage(
      SendTransferRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SendTransferRequest with all fields set to their default value.
   */
  initialize: function (): SendTransferRequest {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SendTransferRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.traceId) {
      writer.writeString(1, msg.traceId);
    }
    if (msg.assetId) {
      writer.writeString(2, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(3, msg.amount);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(4, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeUint32(5, msg.threshold);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransferRequest,
    reader: BinaryReader
  ): SendTransferRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.traceId = reader.readString();
          break;
        }
        case 2: {
          msg.assetId = reader.readString();
          break;
        }
        case 3: {
          msg.amount = reader.readString();
          break;
        }
        case 4: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 5: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SendTransferResponse = {
  /**
   * Serializes SendTransferResponse to protobuf.
   */
  encode: function (_msg?: Partial<SendTransferResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes SendTransferResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): SendTransferResponse {
    return {};
  },

  /**
   * Initializes SendTransferResponse with all fields set to their default value.
   */
  initialize: function (): SendTransferResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<SendTransferResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: SendTransferResponse,
    _reader: BinaryReader
  ): SendTransferResponse {
    return _msg;
  },
};

export const SendTransfersRequest = {
  /**
   * Serializes SendTransfersRequest to protobuf.
   */
  encode: function (msg: Partial<SendTransfersRequest>): Uint8Array {
    return SendTransfersRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SendTransfersRequest from protobuf.
   */
  decode: function (bytes: ByteSource): SendTransfersRequest {
    return SendTransfersRequest._readMessage(
      SendTransfersRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SendTransfersRequest with all fields set to their default value.
   */
  initialize: function (): SendTransfersRequest {
    return {
      transfers: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SendTransfersRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.transfers?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.transfers as any,
        SendTransferRequest._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransfersRequest,
    reader: BinaryReader
  ): SendTransfersRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = SendTransferRequest.initialize();
          reader.readMessage(m, SendTransferRequest._readMessage);
          msg.transfers.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SendTransfersResponse = {
  /**
   * Serializes SendTransfersResponse to protobuf.
   */
  encode: function (_msg?: Partial<SendTransfersResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes SendTransfersResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): SendTransfersResponse {
    return {};
  },

  /**
   * Initializes SendTransfersResponse with all fields set to their default value.
   */
  initialize: function (): SendTransfersResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<SendTransfersResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: SendTransfersResponse,
    _reader: BinaryReader
  ): SendTransfersResponse {
    return _msg;
  },
};

export const GetTransferRequest = {
  /**
   * Serializes GetTransferRequest to protobuf.
   */
  encode: function (msg: Partial<GetTransferRequest>): Uint8Array {
    return GetTransferRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetTransferRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetTransferRequest {
    return GetTransferRequest._readMessage(
      GetTransferRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetTransferRequest with all fields set to their default value.
   */
  initialize: function (): GetTransferRequest {
    return {
      traceId: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetTransferRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.traceId) {
      writer.writeString(1, msg.traceId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTransferRequest,
    reader: BinaryReader
  ): GetTransferRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.traceId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetTransferResponse = {
  /**
   * Serializes GetTransferResponse to protobuf.
   */
  encode: function (msg: Partial<GetTransferResponse>): Uint8Array {
    return GetTransferResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetTransferResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetTransferResponse {
    return GetTransferResponse._readMessage(
      GetTransferResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetTransferResponse with all fields set to their default value.
   */
  initialize: function (): GetTransferResponse {
    return {
      transfer: Transfer.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetTransferResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.transfer) {
      writer.writeMessage(1, msg.transfer, Transfer._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTransferResponse,
    reader: BinaryReader
  ): GetTransferResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.transfer, Transfer._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetBalancesRequest = {
  /**
   * Serializes GetBalancesRequest to protobuf.
   */
  encode: function (_msg?: Partial<GetBalancesRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes GetBalancesRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): GetBalancesRequest {
    return {};
  },

  /**
   * Initializes GetBalancesRequest with all fields set to their default value.
   */
  initialize: function (): GetBalancesRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<GetBalancesRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: GetBalancesRequest,
    _reader: BinaryReader
  ): GetBalancesRequest {
    return _msg;
  },
};

export const GetBalancesResponse = {
  /**
   * Serializes GetBalancesResponse to protobuf.
   */
  encode: function (msg: Partial<GetBalancesResponse>): Uint8Array {
    return GetBalancesResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetBalancesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetBalancesResponse {
    return GetBalancesResponse._readMessage(
      GetBalancesResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetBalancesResponse with all fields set to their default value.
   */
  initialize: function (): GetBalancesResponse {
    return {
      balances: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBalancesResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.balances?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.balances as any,
        Balance._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBalancesResponse,
    reader: BinaryReader
  ): GetBalancesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Balance.initialize();
          reader.readMessage(m, Balance._readMessage);
          msg.balances.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: Partial<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      status: Transfer.Status._fromInt(0),
      txHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Transfer>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.traceId) {
      json.traceId = msg.traceId;
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.opponents?.length) {
      json.opponents = msg.opponents;
    }
    if (msg.threshold) {
      json.threshold = msg.threshold;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    if (msg.status && TransferJSON.Status._toInt(msg.status)) {
      json.status = msg.status;
    }
    if (msg.txHash) {
      json.txHash = msg.txHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _traceId = json.traceId ?? json.trace_id;
    if (_traceId) {
      msg.traceId = _traceId;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _opponents = json.opponents;
    if (_opponents) {
      msg.opponents = _opponents;
    }
    const _threshold = json.threshold;
    if (_threshold) {
      msg.threshold = _threshold;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    const _status = json.status;
    if (_status) {
      msg.status = _status;
    }
    const _txHash = json.txHash ?? json.tx_hash;
    if (_txHash) {
      msg.txHash = _txHash;
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    HANDLED: "HANDLED",
    SPENT: "SPENT",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "HANDLED";
        }
        case 3: {
          return "SPENT";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "HANDLED": {
          return 2;
        }
        case "SPENT": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const BalanceJSON = {
  /**
   * Serializes Balance to JSON.
   */
  encode: function (msg: Partial<Balance>): string {
    return JSON.stringify(BalanceJSON._writeMessage(msg));
  },

  /**
   * Deserializes Balance from JSON.
   */
  decode: function (json: string): Balance {
    return BalanceJSON._readMessage(BalanceJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Balance with all fields set to their default value.
   */
  initialize: function (): Balance {
    return {
      assetId: "",
      amount: "",
      count: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Balance>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.count) {
      json.count = msg.count;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Balance, json: any): Balance {
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _count = json.count;
    if (_count) {
      msg.count = _count;
    }
    return msg;
  },
};

export const SendTransferRequestJSON = {
  /**
   * Serializes SendTransferRequest to JSON.
   */
  encode: function (msg: Partial<SendTransferRequest>): string {
    return JSON.stringify(SendTransferRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes SendTransferRequest from JSON.
   */
  decode: function (json: string): SendTransferRequest {
    return SendTransferRequestJSON._readMessage(
      SendTransferRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SendTransferRequest with all fields set to their default value.
   */
  initialize: function (): SendTransferRequest {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SendTransferRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.traceId) {
      json.traceId = msg.traceId;
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.opponents?.length) {
      json.opponents = msg.opponents;
    }
    if (msg.threshold) {
      json.threshold = msg.threshold;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransferRequest,
    json: any
  ): SendTransferRequest {
    const _traceId = json.traceId ?? json.trace_id;
    if (_traceId) {
      msg.traceId = _traceId;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _opponents = json.opponents;
    if (_opponents) {
      msg.opponents = _opponents;
    }
    const _threshold = json.threshold;
    if (_threshold) {
      msg.threshold = _threshold;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    return msg;
  },
};

export const SendTransferResponseJSON = {
  /**
   * Serializes SendTransferResponse to JSON.
   */
  encode: function (_msg?: Partial<SendTransferResponse>): string {
    return "{}";
  },

  /**
   * Deserializes SendTransferResponse from JSON.
   */
  decode: function (_json?: string): SendTransferResponse {
    return {};
  },

  /**
   * Initializes SendTransferResponse with all fields set to their default value.
   */
  initialize: function (): SendTransferResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<SendTransferResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransferResponse,
    _json: any
  ): SendTransferResponse {
    return msg;
  },
};

export const SendTransfersRequestJSON = {
  /**
   * Serializes SendTransfersRequest to JSON.
   */
  encode: function (msg: Partial<SendTransfersRequest>): string {
    return JSON.stringify(SendTransfersRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes SendTransfersRequest from JSON.
   */
  decode: function (json: string): SendTransfersRequest {
    return SendTransfersRequestJSON._readMessage(
      SendTransfersRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SendTransfersRequest with all fields set to their default value.
   */
  initialize: function (): SendTransfersRequest {
    return {
      transfers: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SendTransfersRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.transfers?.length) {
      json.transfers = msg.transfers.map(SendTransferRequestJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransfersRequest,
    json: any
  ): SendTransfersRequest {
    const _transfers = json.transfers;
    if (_transfers) {
      for (const item of _transfers) {
        const m = SendTransferRequest.initialize();
        SendTransferRequestJSON._readMessage(m, item);
        msg.transfers.push(m);
      }
    }
    return msg;
  },
};

export const SendTransfersResponseJSON = {
  /**
   * Serializes SendTransfersResponse to JSON.
   */
  encode: function (_msg?: Partial<SendTransfersResponse>): string {
    return "{}";
  },

  /**
   * Deserializes SendTransfersResponse from JSON.
   */
  decode: function (_json?: string): SendTransfersResponse {
    return {};
  },

  /**
   * Initializes SendTransfersResponse with all fields set to their default value.
   */
  initialize: function (): SendTransfersResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<SendTransfersResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SendTransfersResponse,
    _json: any
  ): SendTransfersResponse {
    return msg;
  },
};

export const GetTransferRequestJSON = {
  /**
   * Serializes GetTransferRequest to JSON.
   */
  encode: function (msg: Partial<GetTransferRequest>): string {
    return JSON.stringify(GetTransferRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetTransferRequest from JSON.
   */
  decode: function (json: string): GetTransferRequest {
    return GetTransferRequestJSON._readMessage(
      GetTransferRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetTransferRequest with all fields set to their default value.
   */
  initialize: function (): GetTransferRequest {
    return {
      traceId: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetTransferRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.traceId) {
      json.traceId = msg.traceId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTransferRequest,
    json: any
  ): GetTransferRequest {
    const _traceId = json.traceId ?? json.trace_id;
    if (_traceId) {
      msg.traceId = _traceId;
    }
    return msg;
  },
};

export const GetTransferResponseJSON = {
  /**
   * Serializes GetTransferResponse to JSON.
   */
  encode: function (msg: Partial<GetTransferResponse>): string {
    return JSON.stringify(GetTransferResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetTransferResponse from JSON.
   */
  decode: function (json: string): GetTransferResponse {
    return GetTransferResponseJSON._readMessage(
      GetTransferResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetTransferResponse with all fields set to their default value.
   */
  initialize: function (): GetTransferResponse {
    return {
      transfer: Transfer.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetTransferResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.transfer) {
      const transfer = TransferJSON._writeMessage(msg.transfer);
      if (Object.keys(transfer).length > 0) {
        json.transfer = transfer;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTransferResponse,
    json: any
  ): GetTransferResponse {
    const _transfer = json.transfer;
    if (_transfer) {
      const m = Transfer.initialize();
      TransferJSON._readMessage(m, _transfer);
      msg.transfer = m;
    }
    return msg;
  },
};

export const GetBalancesRequestJSON = {
  /**
   * Serializes GetBalancesRequest to JSON.
   */
  encode: function (_msg?: Partial<GetBalancesRequest>): string {
    return "{}";
  },

  /**
   * Deserializes GetBalancesRequest from JSON.
   */
  decode: function (_json?: string): GetBalancesRequest {
    return {};
  },

  /**
   * Initializes GetBalancesRequest with all fields set to their default value.
   */
  initialize: function (): GetBalancesRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<GetBalancesRequest>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBalancesRequest,
    _json: any
  ): GetBalancesRequest {
    return msg;
  },
};

export const GetBalancesResponseJSON = {
  /**
   * Serializes GetBalancesResponse to JSON.
   */
  encode: function (msg: Partial<GetBalancesResponse>): string {
    return JSON.stringify(GetBalancesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetBalancesResponse from JSON.
   */
  decode: function (json: string): GetBalancesResponse {
    return GetBalancesResponseJSON._readMessage(
      GetBalancesResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetBalancesResponse with all fields set to their default value.
   */
  initialize: function (): GetBalancesResponse {
    return {
      balances: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBalancesResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.balances?.length) {
      json.balances = msg.balances.map(BalanceJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBalancesResponse,
    json: any
  ): GetBalancesResponse {
    const _balances = json.balances;
    if (_balances) {
      for (const item of _balances) {
        const m = Balance.initialize();
        BalanceJSON._readMessage(m, item);
        msg.balances.push(m);
      }
    }
    return msg;
  },
};
