// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: swapnode/v2/node.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "ACTION_NOT_SET"
  | "LIQUIDITY_ADD"
  | "LIQUIDITY_REMOVE"
  | "LIQUIDITY_SWAP"
  | "DEPOSIT_EXPIRE"
  | "AUDIT_REVIEW"
  | "PROPOSAL_VOTE"
  | "ADD_PAIR"
  | "UPDATE_PAIR"
  | "WITHDRAW"
  | "SET_PROPERTY"
  | "FLUSH_PROFIT"
  | "SWAP_METHOD";

export interface User {
  members: string[];
  threshold: number;
  uniqueId: string;
}

export interface Pair {
  id: number;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
  version: bigint;
  baseAssetId: string;
  quoteAssetId: string;
  baseAmount: string;
  quoteAmount: string;
  baseProfit: string;
  quoteProfit: string;
  liquidity: string;
  maxLiquidity: string;
  liquidityAssetId: string;
  swapMethod: string;
  profitRate: string;
  fee: string;
}

export interface Transaction {
  group: bigint;
  index: number;
  createdAt: protoscript.Timestamp;
  pairId: number;
  baseAmount: string;
  quoteAmount: string;
  feeAmount: string;
  profitAmount: string;
  liquidity: string;
}

export interface Transfer {
  id: string;
  createdAt: protoscript.Timestamp;
  group: bigint;
  assetId: string;
  amount: string;
  memo: string;
  status: Transfer.Status;
  opponent: User;
  txHash: string;
}

export declare namespace Transfer {
  export type Status =
    | "STATUS_NOT_SET"
    | "AUDITING"
    | "APPROVED"
    | "ASSIGNED"
    | "HANDLED"
    | "PASSED"
    | "REJECTED";
}

export interface Deposit {
  id: bigint;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
  expiredAt: protoscript.Timestamp;
  version: bigint;
  status: Deposit.Status;
  pairId: number;
  baseAmount: string;
  quoteAmount: string;
  slippage: string;
  liquidity: string;
  feeAmount: string;
}

export declare namespace Deposit {
  export type Status = "STATUS_NOT_SET" | "PENDING" | "CANCELLED" | "DONE";
}

export interface Order {
  id: bigint;
  createdAt: protoscript.Timestamp;
  payAssetId: string;
  fillAssetId: string;
  payAmount: string;
  fillAmount: string;
  minAmount: string;
  paths: Order.Path[];
}

export declare namespace Order {
  export interface Path {
    weight: number;
    pairs: number[];
  }
}

export interface Request {
  id: bigint;
  createdAt: protoscript.Timestamp;
  systemVersion: number;
  protocolVersion: number;
  action: Action;
  user: User;
  followId: string;
  code: number;
}

export interface Proposal {
  id: bigint;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
  passedAt: protoscript.Timestamp;
  version: bigint;
  creator: string;
  assetId: string;
  amount: string;
  action: Action;
  votes: string[];
  addPair?: Proposal.AddPair | null | undefined;
  updatePair?: Proposal.UpdatePair | null | undefined;
  setProperty?: Proposal.SetProperty | null | undefined;
  flushProfit?: Proposal.FlushProfit | null | undefined;
  withdraw?: Proposal.Withdraw | null | undefined;
  swapMethod?: Proposal.SwapMethod | null | undefined;
  expiredAt: protoscript.Timestamp;
}

export declare namespace Proposal {
  export interface AddPair {
    baseAsset: string;
    quoteAsset: string;
    method: string;
    profitRate: string;
    fee: string;
  }

  export interface UpdatePair {
    baseAsset: string;
    quoteAsset: string;
    method: string;
    profitRate: string;
    fee: string;
  }

  export interface SetProperty {
    key: string;
    value: string;
  }

  export interface FlushProfit {
    baseAsset: string;
    quoteAsset: string;
  }

  export interface Withdraw {
    opponent: string;
    asset: string;
    amount: string;
  }

  export interface SwapMethod {
    baseAsset: string;
    quoteAsset: string;
    method: string;
  }
}

export interface GetInfoRequest {}

export interface GetInfoResponse {
  members: string[];
  threshold: number;
  version: string;
  mixAddress: string;
  /**
   * repeated Action blocked_actios = 5;
   */
  blockedActions: Action[];
}

export interface ListRequestsRequest {
  offset: bigint;
  limit: number;
}

export interface ListRequestsResponse {
  requests: Request[];
}

export interface FindRequestRequest {
  user: User;
  followId: string;
  id: bigint;
}

export interface FindRequestResponse {
  request: Request;
}

export interface FindDepositRequest {
  id: bigint;
}

export interface FindDepositResponse {
  deposit: Deposit;
}

export interface ListDepositsRequest {
  status: Deposit.Status;
  offset: bigint;
  limit: number;
}

export interface ListDepositsResponse {
  deposits: Deposit[];
}

export interface ListPairsRequest {}

export interface ListPairsResponse {
  pairs: Pair[];
}

export interface ListTransactionsRequest {
  group: bigint;
}

export interface ListTransactionsResponse {
  transactions: Transaction[];
}

export interface ListTransfersRequest {
  group: bigint;
  status: Transfer.Status;
  limit: number;
}

export interface ListTransfersResponse {
  transfers: Transfer[];
}

export interface FindTransferRequest {
  id: string;
}

export interface FindTransferResponse {
  transfer: Transfer;
}

export interface FindOrderRequest {
  id: bigint;
}

export interface FindOrderResponse {
  order: Order;
}

export interface FindProposalRequest {
  id: bigint;
}

export interface FindProposalResponse {
  proposal: Proposal;
}

export interface FindPairRequest {
  id: number;
  baseAssetId: string;
  quoteAssetId: string;
  liquidityAssetId: string;
}

export interface FindPairResponse {
  pair: Pair;
}

//========================================//
//    SwapNodeService Protobuf Client     //
//========================================//

export async function GetInfo(
  getInfoRequest: GetInfoRequest,
  config?: ClientConfiguration,
): Promise<GetInfoResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/GetInfo",
    GetInfoRequest.encode(getInfoRequest),
    config,
  );
  return GetInfoResponse.decode(response);
}

export async function ListRequests(
  listRequestsRequest: ListRequestsRequest,
  config?: ClientConfiguration,
): Promise<ListRequestsResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/ListRequests",
    ListRequestsRequest.encode(listRequestsRequest),
    config,
  );
  return ListRequestsResponse.decode(response);
}

export async function FindRequest(
  findRequestRequest: FindRequestRequest,
  config?: ClientConfiguration,
): Promise<FindRequestResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindRequest",
    FindRequestRequest.encode(findRequestRequest),
    config,
  );
  return FindRequestResponse.decode(response);
}

export async function FindDeposit(
  findDepositRequest: FindDepositRequest,
  config?: ClientConfiguration,
): Promise<FindDepositResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindDeposit",
    FindDepositRequest.encode(findDepositRequest),
    config,
  );
  return FindDepositResponse.decode(response);
}

export async function ListDeposits(
  listDepositsRequest: ListDepositsRequest,
  config?: ClientConfiguration,
): Promise<ListDepositsResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/ListDeposits",
    ListDepositsRequest.encode(listDepositsRequest),
    config,
  );
  return ListDepositsResponse.decode(response);
}

export async function ListPairs(
  listPairsRequest: ListPairsRequest,
  config?: ClientConfiguration,
): Promise<ListPairsResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/ListPairs",
    ListPairsRequest.encode(listPairsRequest),
    config,
  );
  return ListPairsResponse.decode(response);
}

export async function ListTransactions(
  listTransactionsRequest: ListTransactionsRequest,
  config?: ClientConfiguration,
): Promise<ListTransactionsResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/ListTransactions",
    ListTransactionsRequest.encode(listTransactionsRequest),
    config,
  );
  return ListTransactionsResponse.decode(response);
}

export async function ListTransfers(
  listTransfersRequest: ListTransfersRequest,
  config?: ClientConfiguration,
): Promise<ListTransfersResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/ListTransfers",
    ListTransfersRequest.encode(listTransfersRequest),
    config,
  );
  return ListTransfersResponse.decode(response);
}

export async function FindTransfer(
  findTransferRequest: FindTransferRequest,
  config?: ClientConfiguration,
): Promise<FindTransferResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindTransfer",
    FindTransferRequest.encode(findTransferRequest),
    config,
  );
  return FindTransferResponse.decode(response);
}

export async function FindOrder(
  findOrderRequest: FindOrderRequest,
  config?: ClientConfiguration,
): Promise<FindOrderResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindOrder",
    FindOrderRequest.encode(findOrderRequest),
    config,
  );
  return FindOrderResponse.decode(response);
}

export async function FindProposal(
  findProposalRequest: FindProposalRequest,
  config?: ClientConfiguration,
): Promise<FindProposalResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindProposal",
    FindProposalRequest.encode(findProposalRequest),
    config,
  );
  return FindProposalResponse.decode(response);
}

export async function FindPair(
  findPairRequest: FindPairRequest,
  config?: ClientConfiguration,
): Promise<FindPairResponse> {
  const response = await PBrequest(
    "/swapnode.v2.SwapNodeService/FindPair",
    FindPairRequest.encode(findPairRequest),
    config,
  );
  return FindPairResponse.decode(response);
}

//========================================//
//      SwapNodeService JSON Client       //
//========================================//

export async function GetInfoJSON(
  getInfoRequest: GetInfoRequest,
  config?: ClientConfiguration,
): Promise<GetInfoResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/GetInfo",
    GetInfoRequestJSON.encode(getInfoRequest),
    config,
  );
  return GetInfoResponseJSON.decode(response);
}

export async function ListRequestsJSON(
  listRequestsRequest: ListRequestsRequest,
  config?: ClientConfiguration,
): Promise<ListRequestsResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/ListRequests",
    ListRequestsRequestJSON.encode(listRequestsRequest),
    config,
  );
  return ListRequestsResponseJSON.decode(response);
}

export async function FindRequestJSON(
  findRequestRequest: FindRequestRequest,
  config?: ClientConfiguration,
): Promise<FindRequestResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindRequest",
    FindRequestRequestJSON.encode(findRequestRequest),
    config,
  );
  return FindRequestResponseJSON.decode(response);
}

export async function FindDepositJSON(
  findDepositRequest: FindDepositRequest,
  config?: ClientConfiguration,
): Promise<FindDepositResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindDeposit",
    FindDepositRequestJSON.encode(findDepositRequest),
    config,
  );
  return FindDepositResponseJSON.decode(response);
}

export async function ListDepositsJSON(
  listDepositsRequest: ListDepositsRequest,
  config?: ClientConfiguration,
): Promise<ListDepositsResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/ListDeposits",
    ListDepositsRequestJSON.encode(listDepositsRequest),
    config,
  );
  return ListDepositsResponseJSON.decode(response);
}

export async function ListPairsJSON(
  listPairsRequest: ListPairsRequest,
  config?: ClientConfiguration,
): Promise<ListPairsResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/ListPairs",
    ListPairsRequestJSON.encode(listPairsRequest),
    config,
  );
  return ListPairsResponseJSON.decode(response);
}

export async function ListTransactionsJSON(
  listTransactionsRequest: ListTransactionsRequest,
  config?: ClientConfiguration,
): Promise<ListTransactionsResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/ListTransactions",
    ListTransactionsRequestJSON.encode(listTransactionsRequest),
    config,
  );
  return ListTransactionsResponseJSON.decode(response);
}

export async function ListTransfersJSON(
  listTransfersRequest: ListTransfersRequest,
  config?: ClientConfiguration,
): Promise<ListTransfersResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/ListTransfers",
    ListTransfersRequestJSON.encode(listTransfersRequest),
    config,
  );
  return ListTransfersResponseJSON.decode(response);
}

export async function FindTransferJSON(
  findTransferRequest: FindTransferRequest,
  config?: ClientConfiguration,
): Promise<FindTransferResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindTransfer",
    FindTransferRequestJSON.encode(findTransferRequest),
    config,
  );
  return FindTransferResponseJSON.decode(response);
}

export async function FindOrderJSON(
  findOrderRequest: FindOrderRequest,
  config?: ClientConfiguration,
): Promise<FindOrderResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindOrder",
    FindOrderRequestJSON.encode(findOrderRequest),
    config,
  );
  return FindOrderResponseJSON.decode(response);
}

export async function FindProposalJSON(
  findProposalRequest: FindProposalRequest,
  config?: ClientConfiguration,
): Promise<FindProposalResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindProposal",
    FindProposalRequestJSON.encode(findProposalRequest),
    config,
  );
  return FindProposalResponseJSON.decode(response);
}

export async function FindPairJSON(
  findPairRequest: FindPairRequest,
  config?: ClientConfiguration,
): Promise<FindPairResponse> {
  const response = await JSONrequest(
    "/swapnode.v2.SwapNodeService/FindPair",
    FindPairRequestJSON.encode(findPairRequest),
    config,
  );
  return FindPairResponseJSON.decode(response);
}

//========================================//
//            SwapNodeService             //
//========================================//

export interface SwapNodeService<Context = unknown> {
  GetInfo: (
    getInfoRequest: GetInfoRequest,
    context: Context,
  ) => Promise<GetInfoResponse> | GetInfoResponse;
  ListRequests: (
    listRequestsRequest: ListRequestsRequest,
    context: Context,
  ) => Promise<ListRequestsResponse> | ListRequestsResponse;
  FindRequest: (
    findRequestRequest: FindRequestRequest,
    context: Context,
  ) => Promise<FindRequestResponse> | FindRequestResponse;
  FindDeposit: (
    findDepositRequest: FindDepositRequest,
    context: Context,
  ) => Promise<FindDepositResponse> | FindDepositResponse;
  ListDeposits: (
    listDepositsRequest: ListDepositsRequest,
    context: Context,
  ) => Promise<ListDepositsResponse> | ListDepositsResponse;
  ListPairs: (
    listPairsRequest: ListPairsRequest,
    context: Context,
  ) => Promise<ListPairsResponse> | ListPairsResponse;
  ListTransactions: (
    listTransactionsRequest: ListTransactionsRequest,
    context: Context,
  ) => Promise<ListTransactionsResponse> | ListTransactionsResponse;
  ListTransfers: (
    listTransfersRequest: ListTransfersRequest,
    context: Context,
  ) => Promise<ListTransfersResponse> | ListTransfersResponse;
  FindTransfer: (
    findTransferRequest: FindTransferRequest,
    context: Context,
  ) => Promise<FindTransferResponse> | FindTransferResponse;
  FindOrder: (
    findOrderRequest: FindOrderRequest,
    context: Context,
  ) => Promise<FindOrderResponse> | FindOrderResponse;
  FindProposal: (
    findProposalRequest: FindProposalRequest,
    context: Context,
  ) => Promise<FindProposalResponse> | FindProposalResponse;
  FindPair: (
    findPairRequest: FindPairRequest,
    context: Context,
  ) => Promise<FindPairResponse> | FindPairResponse;
}

export function createSwapNodeService<Context>(
  service: SwapNodeService<Context>,
) {
  return {
    name: "swapnode.v2.SwapNodeService",
    methods: {
      GetInfo: {
        name: "GetInfo",
        handler: service.GetInfo,
        input: { protobuf: GetInfoRequest, json: GetInfoRequestJSON },
        output: { protobuf: GetInfoResponse, json: GetInfoResponseJSON },
      },
      ListRequests: {
        name: "ListRequests",
        handler: service.ListRequests,
        input: { protobuf: ListRequestsRequest, json: ListRequestsRequestJSON },
        output: {
          protobuf: ListRequestsResponse,
          json: ListRequestsResponseJSON,
        },
      },
      FindRequest: {
        name: "FindRequest",
        handler: service.FindRequest,
        input: { protobuf: FindRequestRequest, json: FindRequestRequestJSON },
        output: {
          protobuf: FindRequestResponse,
          json: FindRequestResponseJSON,
        },
      },
      FindDeposit: {
        name: "FindDeposit",
        handler: service.FindDeposit,
        input: { protobuf: FindDepositRequest, json: FindDepositRequestJSON },
        output: {
          protobuf: FindDepositResponse,
          json: FindDepositResponseJSON,
        },
      },
      ListDeposits: {
        name: "ListDeposits",
        handler: service.ListDeposits,
        input: { protobuf: ListDepositsRequest, json: ListDepositsRequestJSON },
        output: {
          protobuf: ListDepositsResponse,
          json: ListDepositsResponseJSON,
        },
      },
      ListPairs: {
        name: "ListPairs",
        handler: service.ListPairs,
        input: { protobuf: ListPairsRequest, json: ListPairsRequestJSON },
        output: { protobuf: ListPairsResponse, json: ListPairsResponseJSON },
      },
      ListTransactions: {
        name: "ListTransactions",
        handler: service.ListTransactions,
        input: {
          protobuf: ListTransactionsRequest,
          json: ListTransactionsRequestJSON,
        },
        output: {
          protobuf: ListTransactionsResponse,
          json: ListTransactionsResponseJSON,
        },
      },
      ListTransfers: {
        name: "ListTransfers",
        handler: service.ListTransfers,
        input: {
          protobuf: ListTransfersRequest,
          json: ListTransfersRequestJSON,
        },
        output: {
          protobuf: ListTransfersResponse,
          json: ListTransfersResponseJSON,
        },
      },
      FindTransfer: {
        name: "FindTransfer",
        handler: service.FindTransfer,
        input: { protobuf: FindTransferRequest, json: FindTransferRequestJSON },
        output: {
          protobuf: FindTransferResponse,
          json: FindTransferResponseJSON,
        },
      },
      FindOrder: {
        name: "FindOrder",
        handler: service.FindOrder,
        input: { protobuf: FindOrderRequest, json: FindOrderRequestJSON },
        output: { protobuf: FindOrderResponse, json: FindOrderResponseJSON },
      },
      FindProposal: {
        name: "FindProposal",
        handler: service.FindProposal,
        input: { protobuf: FindProposalRequest, json: FindProposalRequestJSON },
        output: {
          protobuf: FindProposalResponse,
          json: FindProposalResponseJSON,
        },
      },
      FindPair: {
        name: "FindPair",
        handler: service.FindPair,
        input: { protobuf: FindPairRequest, json: FindPairRequestJSON },
        output: { protobuf: FindPairResponse, json: FindPairResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  ACTION_NOT_SET: "ACTION_NOT_SET",
  LIQUIDITY_ADD: "LIQUIDITY_ADD",
  LIQUIDITY_REMOVE: "LIQUIDITY_REMOVE",
  LIQUIDITY_SWAP: "LIQUIDITY_SWAP",
  DEPOSIT_EXPIRE: "DEPOSIT_EXPIRE",
  AUDIT_REVIEW: "AUDIT_REVIEW",
  PROPOSAL_VOTE: "PROPOSAL_VOTE",
  ADD_PAIR: "ADD_PAIR",
  UPDATE_PAIR: "UPDATE_PAIR",
  WITHDRAW: "WITHDRAW",
  SET_PROPERTY: "SET_PROPERTY",
  FLUSH_PROFIT: "FLUSH_PROFIT",
  SWAP_METHOD: "SWAP_METHOD",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "ACTION_NOT_SET";
      }
      case 1: {
        return "LIQUIDITY_ADD";
      }
      case 2: {
        return "LIQUIDITY_REMOVE";
      }
      case 3: {
        return "LIQUIDITY_SWAP";
      }
      case 4: {
        return "DEPOSIT_EXPIRE";
      }
      case 5: {
        return "AUDIT_REVIEW";
      }
      case 6: {
        return "PROPOSAL_VOTE";
      }
      case 7: {
        return "ADD_PAIR";
      }
      case 8: {
        return "UPDATE_PAIR";
      }
      case 9: {
        return "WITHDRAW";
      }
      case 10: {
        return "SET_PROPERTY";
      }
      case 11: {
        return "FLUSH_PROFIT";
      }
      case 12: {
        return "SWAP_METHOD";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "ACTION_NOT_SET": {
        return 0;
      }
      case "LIQUIDITY_ADD": {
        return 1;
      }
      case "LIQUIDITY_REMOVE": {
        return 2;
      }
      case "LIQUIDITY_SWAP": {
        return 3;
      }
      case "DEPOSIT_EXPIRE": {
        return 4;
      }
      case "AUDIT_REVIEW": {
        return 5;
      }
      case "PROPOSAL_VOTE": {
        return 6;
      }
      case "ADD_PAIR": {
        return 7;
      }
      case "UPDATE_PAIR": {
        return 8;
      }
      case "WITHDRAW": {
        return 9;
      }
      case "SET_PROPERTY": {
        return 10;
      }
      case "FLUSH_PROFIT": {
        return 11;
      }
      case "SWAP_METHOD": {
        return 12;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const User = {
  /**
   * Serializes User to protobuf.
   */
  encode: function (msg: PartialDeep<User>): Uint8Array {
    return User._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes User from protobuf.
   */
  decode: function (bytes: ByteSource): User {
    return User._readMessage(
      User.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      members: [],
      threshold: 0,
      uniqueId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<User>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.members?.length) {
      writer.writeRepeatedString(1, msg.members);
    }
    if (msg.threshold) {
      writer.writeUint32(2, msg.threshold);
    }
    if (msg.uniqueId) {
      writer.writeString(3, msg.uniqueId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, reader: protoscript.BinaryReader): User {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.members.push(reader.readString());
          break;
        }
        case 2: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 3: {
          msg.uniqueId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Pair = {
  /**
   * Serializes Pair to protobuf.
   */
  encode: function (msg: PartialDeep<Pair>): Uint8Array {
    return Pair._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Pair from protobuf.
   */
  decode: function (bytes: ByteSource): Pair {
    return Pair._readMessage(
      Pair.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pair>): Pair {
    return {
      id: 0,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      version: 0n,
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      baseProfit: "",
      quoteProfit: "",
      liquidity: "",
      maxLiquidity: "",
      liquidityAssetId: "",
      swapMethod: "",
      profitRate: "",
      fee: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Pair>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint32(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        3,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.version) {
      writer.writeUint64String(4, msg.version.toString() as any);
    }
    if (msg.baseAssetId) {
      writer.writeString(5, msg.baseAssetId);
    }
    if (msg.quoteAssetId) {
      writer.writeString(6, msg.quoteAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(7, msg.baseAmount);
    }
    if (msg.quoteAmount) {
      writer.writeString(8, msg.quoteAmount);
    }
    if (msg.baseProfit) {
      writer.writeString(9, msg.baseProfit);
    }
    if (msg.quoteProfit) {
      writer.writeString(10, msg.quoteProfit);
    }
    if (msg.liquidity) {
      writer.writeString(11, msg.liquidity);
    }
    if (msg.maxLiquidity) {
      writer.writeString(12, msg.maxLiquidity);
    }
    if (msg.liquidityAssetId) {
      writer.writeString(13, msg.liquidityAssetId);
    }
    if (msg.swapMethod) {
      writer.writeString(14, msg.swapMethod);
    }
    if (msg.profitRate) {
      writer.writeString(15, msg.profitRate);
    }
    if (msg.fee) {
      writer.writeString(16, msg.fee);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, reader: protoscript.BinaryReader): Pair {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readUint32();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.version = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 6: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 7: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 8: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 9: {
          msg.baseProfit = reader.readString();
          break;
        }
        case 10: {
          msg.quoteProfit = reader.readString();
          break;
        }
        case 11: {
          msg.liquidity = reader.readString();
          break;
        }
        case 12: {
          msg.maxLiquidity = reader.readString();
          break;
        }
        case 13: {
          msg.liquidityAssetId = reader.readString();
          break;
        }
        case 14: {
          msg.swapMethod = reader.readString();
          break;
        }
        case 15: {
          msg.profitRate = reader.readString();
          break;
        }
        case 16: {
          msg.fee = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: PartialDeep<Transaction>): Uint8Array {
    return Transaction._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      group: 0n,
      index: 0,
      createdAt: protoscript.Timestamp.initialize(),
      pairId: 0,
      baseAmount: "",
      quoteAmount: "",
      feeAmount: "",
      profitAmount: "",
      liquidity: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.group) {
      writer.writeUint64String(1, msg.group.toString() as any);
    }
    if (msg.index) {
      writer.writeUint32(2, msg.index);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        3,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.pairId) {
      writer.writeUint32(4, msg.pairId);
    }
    if (msg.baseAmount) {
      writer.writeString(5, msg.baseAmount);
    }
    if (msg.quoteAmount) {
      writer.writeString(6, msg.quoteAmount);
    }
    if (msg.feeAmount) {
      writer.writeString(7, msg.feeAmount);
    }
    if (msg.profitAmount) {
      writer.writeString(8, msg.profitAmount);
    }
    if (msg.liquidity) {
      writer.writeString(9, msg.liquidity);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transaction,
    reader: protoscript.BinaryReader,
  ): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.group = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          msg.index = reader.readUint32();
          break;
        }
        case 3: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.pairId = reader.readUint32();
          break;
        }
        case 5: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 6: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 7: {
          msg.feeAmount = reader.readString();
          break;
        }
        case 8: {
          msg.profitAmount = reader.readString();
          break;
        }
        case 9: {
          msg.liquidity = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: PartialDeep<Transfer>): Uint8Array {
    return Transfer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      group: 0n,
      assetId: "",
      amount: "",
      memo: "",
      status: Transfer.Status._fromInt(0),
      opponent: User.initialize(),
      txHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.group) {
      writer.writeUint64String(3, msg.group.toString() as any);
    }
    if (msg.assetId) {
      writer.writeString(4, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(5, msg.amount);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    if (msg.status && Transfer.Status._toInt(msg.status)) {
      writer.writeEnum(7, Transfer.Status._toInt(msg.status));
    }
    if (msg.opponent) {
      writer.writeMessage(8, msg.opponent, User._writeMessage);
    }
    if (msg.txHash) {
      writer.writeString(9, msg.txHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transfer,
    reader: protoscript.BinaryReader,
  ): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.group = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.assetId = reader.readString();
          break;
        }
        case 5: {
          msg.amount = reader.readString();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        case 7: {
          msg.status = Transfer.Status._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          reader.readMessage(msg.opponent, User._readMessage);
          break;
        }
        case 9: {
          msg.txHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    AUDITING: "AUDITING",
    APPROVED: "APPROVED",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    REJECTED: "REJECTED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "AUDITING";
        }
        case 2: {
          return "APPROVED";
        }
        case 3: {
          return "ASSIGNED";
        }
        case 4: {
          return "HANDLED";
        }
        case 5: {
          return "PASSED";
        }
        case 6: {
          return "REJECTED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "AUDITING": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        case "ASSIGNED": {
          return 3;
        }
        case "HANDLED": {
          return 4;
        }
        case "PASSED": {
          return 5;
        }
        case "REJECTED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Deposit = {
  /**
   * Serializes Deposit to protobuf.
   */
  encode: function (msg: PartialDeep<Deposit>): Uint8Array {
    return Deposit._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Deposit from protobuf.
   */
  decode: function (bytes: ByteSource): Deposit {
    return Deposit._readMessage(
      Deposit.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deposit>): Deposit {
    return {
      id: 0n,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      expiredAt: protoscript.Timestamp.initialize(),
      version: 0n,
      status: Deposit.Status._fromInt(0),
      pairId: 0,
      baseAmount: "",
      quoteAmount: "",
      slippage: "",
      liquidity: "",
      feeAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Deposit>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        3,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.expiredAt) {
      writer.writeMessage(
        4,
        msg.expiredAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.version) {
      writer.writeUint64String(5, msg.version.toString() as any);
    }
    if (msg.status && Deposit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Deposit.Status._toInt(msg.status));
    }
    if (msg.pairId) {
      writer.writeUint32(7, msg.pairId);
    }
    if (msg.baseAmount) {
      writer.writeString(8, msg.baseAmount);
    }
    if (msg.quoteAmount) {
      writer.writeString(9, msg.quoteAmount);
    }
    if (msg.slippage) {
      writer.writeString(10, msg.slippage);
    }
    if (msg.liquidity) {
      writer.writeString(11, msg.liquidity);
    }
    if (msg.feeAmount) {
      writer.writeString(12, msg.feeAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Deposit,
    reader: protoscript.BinaryReader,
  ): Deposit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.expiredAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 5: {
          msg.version = BigInt(reader.readUint64String());
          break;
        }
        case 6: {
          msg.status = Deposit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.pairId = reader.readUint32();
          break;
        }
        case 8: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 9: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 10: {
          msg.slippage = reader.readString();
          break;
        }
        case 11: {
          msg.liquidity = reader.readString();
          break;
        }
        case 12: {
          msg.feeAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Order = {
  /**
   * Serializes Order to protobuf.
   */
  encode: function (msg: PartialDeep<Order>): Uint8Array {
    return Order._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Order from protobuf.
   */
  decode: function (bytes: ByteSource): Order {
    return Order._readMessage(
      Order.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Order>): Order {
    return {
      id: 0n,
      createdAt: protoscript.Timestamp.initialize(),
      payAssetId: "",
      fillAssetId: "",
      payAmount: "",
      fillAmount: "",
      minAmount: "",
      paths: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Order>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.payAssetId) {
      writer.writeString(3, msg.payAssetId);
    }
    if (msg.fillAssetId) {
      writer.writeString(4, msg.fillAssetId);
    }
    if (msg.payAmount) {
      writer.writeString(5, msg.payAmount);
    }
    if (msg.fillAmount) {
      writer.writeString(6, msg.fillAmount);
    }
    if (msg.minAmount) {
      writer.writeString(7, msg.minAmount);
    }
    if (msg.paths?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.paths as any,
        Order.Path._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, reader: protoscript.BinaryReader): Order {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 4: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 5: {
          msg.payAmount = reader.readString();
          break;
        }
        case 6: {
          msg.fillAmount = reader.readString();
          break;
        }
        case 7: {
          msg.minAmount = reader.readString();
          break;
        }
        case 8: {
          const m = Order.Path.initialize();
          reader.readMessage(m, Order.Path._readMessage);
          msg.paths.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Path: {
    /**
     * Serializes Order.Path to protobuf.
     */
    encode: function (msg: PartialDeep<Order.Path>): Uint8Array {
      return Order.Path._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Order.Path from protobuf.
     */
    decode: function (bytes: ByteSource): Order.Path {
      return Order.Path._readMessage(
        Order.Path.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Order.Path with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Order.Path>): Order.Path {
      return {
        weight: 0,
        pairs: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Order.Path>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.weight) {
        writer.writeUint32(1, msg.weight);
      }
      if (msg.pairs?.length) {
        writer.writePackedUint32(2, msg.pairs);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Order.Path,
      reader: protoscript.BinaryReader,
    ): Order.Path {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.weight = reader.readUint32();
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.pairs.push(...reader.readPackedUint32());
            } else {
              msg.pairs.push(reader.readUint32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Request = {
  /**
   * Serializes Request to protobuf.
   */
  encode: function (msg: PartialDeep<Request>): Uint8Array {
    return Request._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Request from protobuf.
   */
  decode: function (bytes: ByteSource): Request {
    return Request._readMessage(
      Request.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Request with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Request>): Request {
    return {
      id: 0n,
      createdAt: protoscript.Timestamp.initialize(),
      systemVersion: 0,
      protocolVersion: 0,
      action: Action._fromInt(0),
      user: User.initialize(),
      followId: "",
      code: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Request>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.systemVersion) {
      writer.writeUint32(3, msg.systemVersion);
    }
    if (msg.protocolVersion) {
      writer.writeUint32(4, msg.protocolVersion);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(5, Action._toInt(msg.action));
    }
    if (msg.user) {
      writer.writeMessage(6, msg.user, User._writeMessage);
    }
    if (msg.followId) {
      writer.writeString(7, msg.followId);
    }
    if (msg.code) {
      writer.writeInt32(8, msg.code);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Request,
    reader: protoscript.BinaryReader,
  ): Request {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.systemVersion = reader.readUint32();
          break;
        }
        case 4: {
          msg.protocolVersion = reader.readUint32();
          break;
        }
        case 5: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          reader.readMessage(msg.user, User._readMessage);
          break;
        }
        case 7: {
          msg.followId = reader.readString();
          break;
        }
        case 8: {
          msg.code = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Proposal = {
  /**
   * Serializes Proposal to protobuf.
   */
  encode: function (msg: PartialDeep<Proposal>): Uint8Array {
    return Proposal._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Proposal from protobuf.
   */
  decode: function (bytes: ByteSource): Proposal {
    return Proposal._readMessage(
      Proposal.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Proposal>): Proposal {
    return {
      id: 0n,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      passedAt: protoscript.Timestamp.initialize(),
      version: 0n,
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      votes: [],
      addPair: undefined,
      updatePair: undefined,
      setProperty: undefined,
      flushProfit: undefined,
      withdraw: undefined,
      swapMethod: undefined,
      expiredAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Proposal>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        3,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.passedAt) {
      writer.writeMessage(4, msg.passedAt, protoscript.Timestamp._writeMessage);
    }
    if (msg.version) {
      writer.writeUint64String(5, msg.version.toString() as any);
    }
    if (msg.creator) {
      writer.writeString(6, msg.creator);
    }
    if (msg.assetId) {
      writer.writeString(7, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(8, msg.amount);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(9, Action._toInt(msg.action));
    }
    if (msg.votes?.length) {
      writer.writeRepeatedString(10, msg.votes);
    }
    if (msg.addPair != undefined) {
      writer.writeMessage(11, msg.addPair, Proposal.AddPair._writeMessage);
    }
    if (msg.updatePair != undefined) {
      writer.writeMessage(
        12,
        msg.updatePair,
        Proposal.UpdatePair._writeMessage,
      );
    }
    if (msg.setProperty != undefined) {
      writer.writeMessage(
        13,
        msg.setProperty,
        Proposal.SetProperty._writeMessage,
      );
    }
    if (msg.flushProfit != undefined) {
      writer.writeMessage(
        14,
        msg.flushProfit,
        Proposal.FlushProfit._writeMessage,
      );
    }
    if (msg.withdraw != undefined) {
      writer.writeMessage(15, msg.withdraw, Proposal.Withdraw._writeMessage);
    }
    if (msg.swapMethod != undefined) {
      writer.writeMessage(
        16,
        msg.swapMethod,
        Proposal.SwapMethod._writeMessage,
      );
    }
    if (msg.expiredAt) {
      writer.writeMessage(
        17,
        msg.expiredAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Proposal,
    reader: protoscript.BinaryReader,
  ): Proposal {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.passedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 5: {
          msg.version = BigInt(reader.readUint64String());
          break;
        }
        case 6: {
          msg.creator = reader.readString();
          break;
        }
        case 7: {
          msg.assetId = reader.readString();
          break;
        }
        case 8: {
          msg.amount = reader.readString();
          break;
        }
        case 9: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 10: {
          msg.votes.push(reader.readString());
          break;
        }
        case 11: {
          msg.addPair = Proposal.AddPair.initialize();
          reader.readMessage(msg.addPair, Proposal.AddPair._readMessage);
          break;
        }
        case 12: {
          msg.updatePair = Proposal.UpdatePair.initialize();
          reader.readMessage(msg.updatePair, Proposal.UpdatePair._readMessage);
          break;
        }
        case 13: {
          msg.setProperty = Proposal.SetProperty.initialize();
          reader.readMessage(
            msg.setProperty,
            Proposal.SetProperty._readMessage,
          );
          break;
        }
        case 14: {
          msg.flushProfit = Proposal.FlushProfit.initialize();
          reader.readMessage(
            msg.flushProfit,
            Proposal.FlushProfit._readMessage,
          );
          break;
        }
        case 15: {
          msg.withdraw = Proposal.Withdraw.initialize();
          reader.readMessage(msg.withdraw, Proposal.Withdraw._readMessage);
          break;
        }
        case 16: {
          msg.swapMethod = Proposal.SwapMethod.initialize();
          reader.readMessage(msg.swapMethod, Proposal.SwapMethod._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.expiredAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  AddPair: {
    /**
     * Serializes Proposal.AddPair to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.AddPair>): Uint8Array {
      return Proposal.AddPair._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.AddPair from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.AddPair {
      return Proposal.AddPair._readMessage(
        Proposal.AddPair.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.AddPair with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.AddPair>): Proposal.AddPair {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        profitRate: "",
        fee: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.AddPair>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.baseAsset) {
        writer.writeString(1, msg.baseAsset);
      }
      if (msg.quoteAsset) {
        writer.writeString(2, msg.quoteAsset);
      }
      if (msg.method) {
        writer.writeString(3, msg.method);
      }
      if (msg.profitRate) {
        writer.writeString(4, msg.profitRate);
      }
      if (msg.fee) {
        writer.writeString(5, msg.fee);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.AddPair,
      reader: protoscript.BinaryReader,
    ): Proposal.AddPair {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.baseAsset = reader.readString();
            break;
          }
          case 2: {
            msg.quoteAsset = reader.readString();
            break;
          }
          case 3: {
            msg.method = reader.readString();
            break;
          }
          case 4: {
            msg.profitRate = reader.readString();
            break;
          }
          case 5: {
            msg.fee = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  UpdatePair: {
    /**
     * Serializes Proposal.UpdatePair to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.UpdatePair>): Uint8Array {
      return Proposal.UpdatePair._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.UpdatePair from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.UpdatePair {
      return Proposal.UpdatePair._readMessage(
        Proposal.UpdatePair.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.UpdatePair with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.UpdatePair>,
    ): Proposal.UpdatePair {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        profitRate: "",
        fee: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.UpdatePair>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.baseAsset) {
        writer.writeString(1, msg.baseAsset);
      }
      if (msg.quoteAsset) {
        writer.writeString(2, msg.quoteAsset);
      }
      if (msg.method) {
        writer.writeString(3, msg.method);
      }
      if (msg.profitRate) {
        writer.writeString(4, msg.profitRate);
      }
      if (msg.fee) {
        writer.writeString(5, msg.fee);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.UpdatePair,
      reader: protoscript.BinaryReader,
    ): Proposal.UpdatePair {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.baseAsset = reader.readString();
            break;
          }
          case 2: {
            msg.quoteAsset = reader.readString();
            break;
          }
          case 3: {
            msg.method = reader.readString();
            break;
          }
          case 4: {
            msg.profitRate = reader.readString();
            break;
          }
          case 5: {
            msg.fee = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SetProperty: {
    /**
     * Serializes Proposal.SetProperty to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.SetProperty>): Uint8Array {
      return Proposal.SetProperty._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.SetProperty from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.SetProperty {
      return Proposal.SetProperty._readMessage(
        Proposal.SetProperty.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.SetProperty with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.SetProperty>,
    ): Proposal.SetProperty {
      return {
        key: "",
        value: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.SetProperty>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.SetProperty,
      reader: protoscript.BinaryReader,
    ): Proposal.SetProperty {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FlushProfit: {
    /**
     * Serializes Proposal.FlushProfit to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.FlushProfit>): Uint8Array {
      return Proposal.FlushProfit._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.FlushProfit from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.FlushProfit {
      return Proposal.FlushProfit._readMessage(
        Proposal.FlushProfit.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.FlushProfit with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.FlushProfit>,
    ): Proposal.FlushProfit {
      return {
        baseAsset: "",
        quoteAsset: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.FlushProfit>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.baseAsset) {
        writer.writeString(1, msg.baseAsset);
      }
      if (msg.quoteAsset) {
        writer.writeString(2, msg.quoteAsset);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.FlushProfit,
      reader: protoscript.BinaryReader,
    ): Proposal.FlushProfit {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.baseAsset = reader.readString();
            break;
          }
          case 2: {
            msg.quoteAsset = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Withdraw: {
    /**
     * Serializes Proposal.Withdraw to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.Withdraw>): Uint8Array {
      return Proposal.Withdraw._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.Withdraw from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.Withdraw {
      return Proposal.Withdraw._readMessage(
        Proposal.Withdraw.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.Withdraw with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.Withdraw>): Proposal.Withdraw {
      return {
        opponent: "",
        asset: "",
        amount: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.Withdraw>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.opponent) {
        writer.writeString(1, msg.opponent);
      }
      if (msg.asset) {
        writer.writeString(2, msg.asset);
      }
      if (msg.amount) {
        writer.writeString(3, msg.amount);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.Withdraw,
      reader: protoscript.BinaryReader,
    ): Proposal.Withdraw {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.opponent = reader.readString();
            break;
          }
          case 2: {
            msg.asset = reader.readString();
            break;
          }
          case 3: {
            msg.amount = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SwapMethod: {
    /**
     * Serializes Proposal.SwapMethod to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.SwapMethod>): Uint8Array {
      return Proposal.SwapMethod._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.SwapMethod from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.SwapMethod {
      return Proposal.SwapMethod._readMessage(
        Proposal.SwapMethod.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.SwapMethod with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.SwapMethod>,
    ): Proposal.SwapMethod {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.SwapMethod>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.baseAsset) {
        writer.writeString(1, msg.baseAsset);
      }
      if (msg.quoteAsset) {
        writer.writeString(2, msg.quoteAsset);
      }
      if (msg.method) {
        writer.writeString(3, msg.method);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.SwapMethod,
      reader: protoscript.BinaryReader,
    ): Proposal.SwapMethod {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.baseAsset = reader.readString();
            break;
          }
          case 2: {
            msg.quoteAsset = reader.readString();
            break;
          }
          case 3: {
            msg.method = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const GetInfoRequest = {
  /**
   * Serializes GetInfoRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<GetInfoRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes GetInfoRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): GetInfoRequest {
    return {};
  },

  /**
   * Initializes GetInfoRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoRequest>): GetInfoRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<GetInfoRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: GetInfoRequest,
    _reader: protoscript.BinaryReader,
  ): GetInfoRequest {
    return _msg;
  },
};

export const GetInfoResponse = {
  /**
   * Serializes GetInfoResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GetInfoResponse>): Uint8Array {
    return GetInfoResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetInfoResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetInfoResponse {
    return GetInfoResponse._readMessage(
      GetInfoResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetInfoResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoResponse>): GetInfoResponse {
    return {
      members: [],
      threshold: 0,
      version: "",
      mixAddress: "",
      blockedActions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetInfoResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.members?.length) {
      writer.writeRepeatedString(1, msg.members);
    }
    if (msg.threshold) {
      writer.writeInt32(2, msg.threshold);
    }
    if (msg.version) {
      writer.writeString(3, msg.version);
    }
    if (msg.mixAddress) {
      writer.writeString(4, msg.mixAddress);
    }
    if (msg.blockedActions?.length) {
      writer.writePackedEnum(6, msg.blockedActions.map(Action._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetInfoResponse,
    reader: protoscript.BinaryReader,
  ): GetInfoResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.members.push(reader.readString());
          break;
        }
        case 2: {
          msg.threshold = reader.readInt32();
          break;
        }
        case 3: {
          msg.version = reader.readString();
          break;
        }
        case 4: {
          msg.mixAddress = reader.readString();
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.blockedActions.push(
              ...reader.readPackedEnum().map(Action._fromInt),
            );
          } else {
            msg.blockedActions.push(Action._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListRequestsRequest = {
  /**
   * Serializes ListRequestsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListRequestsRequest>): Uint8Array {
    return ListRequestsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListRequestsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListRequestsRequest {
    return ListRequestsRequest._readMessage(
      ListRequestsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListRequestsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListRequestsRequest>,
  ): ListRequestsRequest {
    return {
      offset: 0n,
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListRequestsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.offset) {
      writer.writeUint64String(1, msg.offset.toString() as any);
    }
    if (msg.limit) {
      writer.writeInt32(2, msg.limit);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListRequestsRequest,
    reader: protoscript.BinaryReader,
  ): ListRequestsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.offset = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          msg.limit = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListRequestsResponse = {
  /**
   * Serializes ListRequestsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListRequestsResponse>): Uint8Array {
    return ListRequestsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListRequestsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListRequestsResponse {
    return ListRequestsResponse._readMessage(
      ListRequestsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListRequestsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListRequestsResponse>,
  ): ListRequestsResponse {
    return {
      requests: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListRequestsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.requests?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.requests as any,
        Request._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListRequestsResponse,
    reader: protoscript.BinaryReader,
  ): ListRequestsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Request.initialize();
          reader.readMessage(m, Request._readMessage);
          msg.requests.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindRequestRequest = {
  /**
   * Serializes FindRequestRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindRequestRequest>): Uint8Array {
    return FindRequestRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindRequestRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindRequestRequest {
    return FindRequestRequest._readMessage(
      FindRequestRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindRequestRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindRequestRequest>): FindRequestRequest {
    return {
      user: User.initialize(),
      followId: "",
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindRequestRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.user) {
      writer.writeMessage(1, msg.user, User._writeMessage);
    }
    if (msg.followId) {
      writer.writeString(2, msg.followId);
    }
    if (msg.id) {
      writer.writeUint64String(3, msg.id.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindRequestRequest,
    reader: protoscript.BinaryReader,
  ): FindRequestRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.user, User._readMessage);
          break;
        }
        case 2: {
          msg.followId = reader.readString();
          break;
        }
        case 3: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindRequestResponse = {
  /**
   * Serializes FindRequestResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindRequestResponse>): Uint8Array {
    return FindRequestResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindRequestResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindRequestResponse {
    return FindRequestResponse._readMessage(
      FindRequestResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindRequestResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindRequestResponse>,
  ): FindRequestResponse {
    return {
      request: Request.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindRequestResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.request) {
      writer.writeMessage(1, msg.request, Request._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindRequestResponse,
    reader: protoscript.BinaryReader,
  ): FindRequestResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.request, Request._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindDepositRequest = {
  /**
   * Serializes FindDepositRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindDepositRequest>): Uint8Array {
    return FindDepositRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindDepositRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindDepositRequest {
    return FindDepositRequest._readMessage(
      FindDepositRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindDepositRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindDepositRequest>): FindDepositRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindDepositRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindDepositRequest,
    reader: protoscript.BinaryReader,
  ): FindDepositRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindDepositResponse = {
  /**
   * Serializes FindDepositResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindDepositResponse>): Uint8Array {
    return FindDepositResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindDepositResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindDepositResponse {
    return FindDepositResponse._readMessage(
      FindDepositResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindDepositResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindDepositResponse>,
  ): FindDepositResponse {
    return {
      deposit: Deposit.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindDepositResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.deposit) {
      writer.writeMessage(1, msg.deposit, Deposit._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindDepositResponse,
    reader: protoscript.BinaryReader,
  ): FindDepositResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.deposit, Deposit._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListDepositsRequest = {
  /**
   * Serializes ListDepositsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListDepositsRequest>): Uint8Array {
    return ListDepositsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListDepositsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListDepositsRequest {
    return ListDepositsRequest._readMessage(
      ListDepositsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListDepositsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListDepositsRequest>,
  ): ListDepositsRequest {
    return {
      status: Deposit.Status._fromInt(0),
      offset: 0n,
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListDepositsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status && Deposit.Status._toInt(msg.status)) {
      writer.writeEnum(1, Deposit.Status._toInt(msg.status));
    }
    if (msg.offset) {
      writer.writeUint64String(2, msg.offset.toString() as any);
    }
    if (msg.limit) {
      writer.writeInt32(3, msg.limit);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListDepositsRequest,
    reader: protoscript.BinaryReader,
  ): ListDepositsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.status = Deposit.Status._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.offset = BigInt(reader.readUint64String());
          break;
        }
        case 3: {
          msg.limit = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListDepositsResponse = {
  /**
   * Serializes ListDepositsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListDepositsResponse>): Uint8Array {
    return ListDepositsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListDepositsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListDepositsResponse {
    return ListDepositsResponse._readMessage(
      ListDepositsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListDepositsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListDepositsResponse>,
  ): ListDepositsResponse {
    return {
      deposits: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListDepositsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.deposits?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.deposits as any,
        Deposit._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListDepositsResponse,
    reader: protoscript.BinaryReader,
  ): ListDepositsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Deposit.initialize();
          reader.readMessage(m, Deposit._readMessage);
          msg.deposits.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListPairsRequest = {
  /**
   * Serializes ListPairsRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<ListPairsRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes ListPairsRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): ListPairsRequest {
    return {};
  },

  /**
   * Initializes ListPairsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPairsRequest>): ListPairsRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListPairsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: ListPairsRequest,
    _reader: protoscript.BinaryReader,
  ): ListPairsRequest {
    return _msg;
  },
};

export const ListPairsResponse = {
  /**
   * Serializes ListPairsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListPairsResponse>): Uint8Array {
    return ListPairsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListPairsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListPairsResponse {
    return ListPairsResponse._readMessage(
      ListPairsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListPairsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPairsResponse>): ListPairsResponse {
    return {
      pairs: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListPairsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.pairs?.length) {
      writer.writeRepeatedMessage(1, msg.pairs as any, Pair._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListPairsResponse,
    reader: protoscript.BinaryReader,
  ): ListPairsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Pair.initialize();
          reader.readMessage(m, Pair._readMessage);
          msg.pairs.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTransactionsRequest = {
  /**
   * Serializes ListTransactionsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListTransactionsRequest>): Uint8Array {
    return ListTransactionsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTransactionsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListTransactionsRequest {
    return ListTransactionsRequest._readMessage(
      ListTransactionsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTransactionsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransactionsRequest>,
  ): ListTransactionsRequest {
    return {
      group: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransactionsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.group) {
      writer.writeUint64String(1, msg.group.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransactionsRequest,
    reader: protoscript.BinaryReader,
  ): ListTransactionsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.group = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTransactionsResponse = {
  /**
   * Serializes ListTransactionsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListTransactionsResponse>): Uint8Array {
    return ListTransactionsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTransactionsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListTransactionsResponse {
    return ListTransactionsResponse._readMessage(
      ListTransactionsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTransactionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransactionsResponse>,
  ): ListTransactionsResponse {
    return {
      transactions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransactionsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.transactions?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.transactions as any,
        Transaction._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransactionsResponse,
    reader: protoscript.BinaryReader,
  ): ListTransactionsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Transaction.initialize();
          reader.readMessage(m, Transaction._readMessage);
          msg.transactions.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTransfersRequest = {
  /**
   * Serializes ListTransfersRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListTransfersRequest>): Uint8Array {
    return ListTransfersRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTransfersRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListTransfersRequest {
    return ListTransfersRequest._readMessage(
      ListTransfersRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTransfersRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransfersRequest>,
  ): ListTransfersRequest {
    return {
      group: 0n,
      status: Transfer.Status._fromInt(0),
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransfersRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.group) {
      writer.writeUint64String(1, msg.group.toString() as any);
    }
    if (msg.status && Transfer.Status._toInt(msg.status)) {
      writer.writeEnum(2, Transfer.Status._toInt(msg.status));
    }
    if (msg.limit) {
      writer.writeInt32(3, msg.limit);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransfersRequest,
    reader: protoscript.BinaryReader,
  ): ListTransfersRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.group = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          msg.status = Transfer.Status._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.limit = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTransfersResponse = {
  /**
   * Serializes ListTransfersResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListTransfersResponse>): Uint8Array {
    return ListTransfersResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTransfersResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListTransfersResponse {
    return ListTransfersResponse._readMessage(
      ListTransfersResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTransfersResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransfersResponse>,
  ): ListTransfersResponse {
    return {
      transfers: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransfersResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.transfers?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.transfers as any,
        Transfer._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransfersResponse,
    reader: protoscript.BinaryReader,
  ): ListTransfersResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Transfer.initialize();
          reader.readMessage(m, Transfer._readMessage);
          msg.transfers.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindTransferRequest = {
  /**
   * Serializes FindTransferRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindTransferRequest>): Uint8Array {
    return FindTransferRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindTransferRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindTransferRequest {
    return FindTransferRequest._readMessage(
      FindTransferRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindTransferRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindTransferRequest>,
  ): FindTransferRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTransferRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTransferRequest,
    reader: protoscript.BinaryReader,
  ): FindTransferRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindTransferResponse = {
  /**
   * Serializes FindTransferResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindTransferResponse>): Uint8Array {
    return FindTransferResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindTransferResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindTransferResponse {
    return FindTransferResponse._readMessage(
      FindTransferResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindTransferResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindTransferResponse>,
  ): FindTransferResponse {
    return {
      transfer: Transfer.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTransferResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.transfer) {
      writer.writeMessage(1, msg.transfer, Transfer._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTransferResponse,
    reader: protoscript.BinaryReader,
  ): FindTransferResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.transfer, Transfer._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindOrderRequest = {
  /**
   * Serializes FindOrderRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindOrderRequest>): Uint8Array {
    return FindOrderRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindOrderRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindOrderRequest {
    return FindOrderRequest._readMessage(
      FindOrderRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindOrderRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindOrderRequest>): FindOrderRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindOrderRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindOrderRequest,
    reader: protoscript.BinaryReader,
  ): FindOrderRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindOrderResponse = {
  /**
   * Serializes FindOrderResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindOrderResponse>): Uint8Array {
    return FindOrderResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindOrderResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindOrderResponse {
    return FindOrderResponse._readMessage(
      FindOrderResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindOrderResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindOrderResponse>): FindOrderResponse {
    return {
      order: Order.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindOrderResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.order) {
      writer.writeMessage(1, msg.order, Order._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindOrderResponse,
    reader: protoscript.BinaryReader,
  ): FindOrderResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.order, Order._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindProposalRequest = {
  /**
   * Serializes FindProposalRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindProposalRequest>): Uint8Array {
    return FindProposalRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindProposalRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindProposalRequest {
    return FindProposalRequest._readMessage(
      FindProposalRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindProposalRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindProposalRequest>,
  ): FindProposalRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindProposalRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint64String(1, msg.id.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindProposalRequest,
    reader: protoscript.BinaryReader,
  ): FindProposalRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindProposalResponse = {
  /**
   * Serializes FindProposalResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindProposalResponse>): Uint8Array {
    return FindProposalResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindProposalResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindProposalResponse {
    return FindProposalResponse._readMessage(
      FindProposalResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindProposalResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindProposalResponse>,
  ): FindProposalResponse {
    return {
      proposal: Proposal.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindProposalResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.proposal) {
      writer.writeMessage(1, msg.proposal, Proposal._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindProposalResponse,
    reader: protoscript.BinaryReader,
  ): FindProposalResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.proposal, Proposal._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindPairRequest = {
  /**
   * Serializes FindPairRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindPairRequest>): Uint8Array {
    return FindPairRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindPairRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindPairRequest {
    return FindPairRequest._readMessage(
      FindPairRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindPairRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPairRequest>): FindPairRequest {
    return {
      id: 0,
      baseAssetId: "",
      quoteAssetId: "",
      liquidityAssetId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPairRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeUint32(1, msg.id);
    }
    if (msg.baseAssetId) {
      writer.writeString(2, msg.baseAssetId);
    }
    if (msg.quoteAssetId) {
      writer.writeString(3, msg.quoteAssetId);
    }
    if (msg.liquidityAssetId) {
      writer.writeString(4, msg.liquidityAssetId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindPairRequest,
    reader: protoscript.BinaryReader,
  ): FindPairRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readUint32();
          break;
        }
        case 2: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 3: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 4: {
          msg.liquidityAssetId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindPairResponse = {
  /**
   * Serializes FindPairResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindPairResponse>): Uint8Array {
    return FindPairResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindPairResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindPairResponse {
    return FindPairResponse._readMessage(
      FindPairResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindPairResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPairResponse>): FindPairResponse {
    return {
      pair: Pair.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPairResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.pair) {
      writer.writeMessage(1, msg.pair, Pair._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindPairResponse,
    reader: protoscript.BinaryReader,
  ): FindPairResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.pair, Pair._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  ACTION_NOT_SET: "ACTION_NOT_SET",
  LIQUIDITY_ADD: "LIQUIDITY_ADD",
  LIQUIDITY_REMOVE: "LIQUIDITY_REMOVE",
  LIQUIDITY_SWAP: "LIQUIDITY_SWAP",
  DEPOSIT_EXPIRE: "DEPOSIT_EXPIRE",
  AUDIT_REVIEW: "AUDIT_REVIEW",
  PROPOSAL_VOTE: "PROPOSAL_VOTE",
  ADD_PAIR: "ADD_PAIR",
  UPDATE_PAIR: "UPDATE_PAIR",
  WITHDRAW: "WITHDRAW",
  SET_PROPERTY: "SET_PROPERTY",
  FLUSH_PROFIT: "FLUSH_PROFIT",
  SWAP_METHOD: "SWAP_METHOD",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "ACTION_NOT_SET";
      }
      case 1: {
        return "LIQUIDITY_ADD";
      }
      case 2: {
        return "LIQUIDITY_REMOVE";
      }
      case 3: {
        return "LIQUIDITY_SWAP";
      }
      case 4: {
        return "DEPOSIT_EXPIRE";
      }
      case 5: {
        return "AUDIT_REVIEW";
      }
      case 6: {
        return "PROPOSAL_VOTE";
      }
      case 7: {
        return "ADD_PAIR";
      }
      case 8: {
        return "UPDATE_PAIR";
      }
      case 9: {
        return "WITHDRAW";
      }
      case 10: {
        return "SET_PROPERTY";
      }
      case 11: {
        return "FLUSH_PROFIT";
      }
      case 12: {
        return "SWAP_METHOD";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "ACTION_NOT_SET": {
        return 0;
      }
      case "LIQUIDITY_ADD": {
        return 1;
      }
      case "LIQUIDITY_REMOVE": {
        return 2;
      }
      case "LIQUIDITY_SWAP": {
        return 3;
      }
      case "DEPOSIT_EXPIRE": {
        return 4;
      }
      case "AUDIT_REVIEW": {
        return 5;
      }
      case "PROPOSAL_VOTE": {
        return 6;
      }
      case "ADD_PAIR": {
        return 7;
      }
      case "UPDATE_PAIR": {
        return 8;
      }
      case "WITHDRAW": {
        return 9;
      }
      case "SET_PROPERTY": {
        return 10;
      }
      case "FLUSH_PROFIT": {
        return 11;
      }
      case "SWAP_METHOD": {
        return 12;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const UserJSON = {
  /**
   * Serializes User to JSON.
   */
  encode: function (msg: PartialDeep<User>): string {
    return JSON.stringify(UserJSON._writeMessage(msg));
  },

  /**
   * Deserializes User from JSON.
   */
  decode: function (json: string): User {
    return UserJSON._readMessage(UserJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      members: [],
      threshold: 0,
      uniqueId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<User>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.members?.length) {
      json["members"] = msg.members;
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.uniqueId) {
      json["uniqueId"] = msg.uniqueId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, json: any): User {
    const _members_ = json["members"];
    if (_members_) {
      msg.members = _members_;
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _uniqueId_ = json["uniqueId"] ?? json["unique_id"];
    if (_uniqueId_) {
      msg.uniqueId = _uniqueId_;
    }
    return msg;
  },
};

export const PairJSON = {
  /**
   * Serializes Pair to JSON.
   */
  encode: function (msg: PartialDeep<Pair>): string {
    return JSON.stringify(PairJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pair from JSON.
   */
  decode: function (json: string): Pair {
    return PairJSON._readMessage(PairJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pair>): Pair {
    return {
      id: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      version: 0n,
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      baseProfit: "",
      quoteProfit: "",
      liquidity: "",
      maxLiquidity: "",
      liquidityAssetId: "",
      swapMethod: "",
      profitRate: "",
      fee: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Pair>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    if (msg.version) {
      json["version"] = String(msg.version);
    }
    if (msg.baseAssetId) {
      json["baseAssetId"] = msg.baseAssetId;
    }
    if (msg.quoteAssetId) {
      json["quoteAssetId"] = msg.quoteAssetId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.baseProfit) {
      json["baseProfit"] = msg.baseProfit;
    }
    if (msg.quoteProfit) {
      json["quoteProfit"] = msg.quoteProfit;
    }
    if (msg.liquidity) {
      json["liquidity"] = msg.liquidity;
    }
    if (msg.maxLiquidity) {
      json["maxLiquidity"] = msg.maxLiquidity;
    }
    if (msg.liquidityAssetId) {
      json["liquidityAssetId"] = msg.liquidityAssetId;
    }
    if (msg.swapMethod) {
      json["swapMethod"] = msg.swapMethod;
    }
    if (msg.profitRate) {
      json["profitRate"] = msg.profitRate;
    }
    if (msg.fee) {
      json["fee"] = msg.fee;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, json: any): Pair {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = BigInt(_version_);
    }
    const _baseAssetId_ = json["baseAssetId"] ?? json["base_asset_id"];
    if (_baseAssetId_) {
      msg.baseAssetId = _baseAssetId_;
    }
    const _quoteAssetId_ = json["quoteAssetId"] ?? json["quote_asset_id"];
    if (_quoteAssetId_) {
      msg.quoteAssetId = _quoteAssetId_;
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _baseProfit_ = json["baseProfit"] ?? json["base_profit"];
    if (_baseProfit_) {
      msg.baseProfit = _baseProfit_;
    }
    const _quoteProfit_ = json["quoteProfit"] ?? json["quote_profit"];
    if (_quoteProfit_) {
      msg.quoteProfit = _quoteProfit_;
    }
    const _liquidity_ = json["liquidity"];
    if (_liquidity_) {
      msg.liquidity = _liquidity_;
    }
    const _maxLiquidity_ = json["maxLiquidity"] ?? json["max_liquidity"];
    if (_maxLiquidity_) {
      msg.maxLiquidity = _maxLiquidity_;
    }
    const _liquidityAssetId_ =
      json["liquidityAssetId"] ?? json["liquidity_asset_id"];
    if (_liquidityAssetId_) {
      msg.liquidityAssetId = _liquidityAssetId_;
    }
    const _swapMethod_ = json["swapMethod"] ?? json["swap_method"];
    if (_swapMethod_) {
      msg.swapMethod = _swapMethod_;
    }
    const _profitRate_ = json["profitRate"] ?? json["profit_rate"];
    if (_profitRate_) {
      msg.profitRate = _profitRate_;
    }
    const _fee_ = json["fee"];
    if (_fee_) {
      msg.fee = _fee_;
    }
    return msg;
  },
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: PartialDeep<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      group: 0n,
      index: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      pairId: 0,
      baseAmount: "",
      quoteAmount: "",
      feeAmount: "",
      profitAmount: "",
      liquidity: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    if (msg.index) {
      json["index"] = msg.index;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.pairId) {
      json["pairId"] = msg.pairId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.feeAmount) {
      json["feeAmount"] = msg.feeAmount;
    }
    if (msg.profitAmount) {
      json["profitAmount"] = msg.profitAmount;
    }
    if (msg.liquidity) {
      json["liquidity"] = msg.liquidity;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    const _index_ = json["index"];
    if (_index_) {
      msg.index = protoscript.parseNumber(_index_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _pairId_ = json["pairId"] ?? json["pair_id"];
    if (_pairId_) {
      msg.pairId = protoscript.parseNumber(_pairId_);
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _feeAmount_ = json["feeAmount"] ?? json["fee_amount"];
    if (_feeAmount_) {
      msg.feeAmount = _feeAmount_;
    }
    const _profitAmount_ = json["profitAmount"] ?? json["profit_amount"];
    if (_profitAmount_) {
      msg.profitAmount = _profitAmount_;
    }
    const _liquidity_ = json["liquidity"];
    if (_liquidity_) {
      msg.liquidity = _liquidity_;
    }
    return msg;
  },
};

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: PartialDeep<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      group: 0n,
      assetId: "",
      amount: "",
      memo: "",
      status: Transfer.Status._fromInt(0),
      opponent: UserJSON.initialize(),
      txHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.status && TransferJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.opponent) {
      const _opponent_ = UserJSON._writeMessage(msg.opponent);
      if (Object.keys(_opponent_).length > 0) {
        json["opponent"] = _opponent_;
      }
    }
    if (msg.txHash) {
      json["txHash"] = msg.txHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Transfer.Status._fromInt(_status_);
    }
    const _opponent_ = json["opponent"];
    if (_opponent_) {
      UserJSON._readMessage(msg.opponent, _opponent_);
    }
    const _txHash_ = json["txHash"] ?? json["tx_hash"];
    if (_txHash_) {
      msg.txHash = _txHash_;
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    AUDITING: "AUDITING",
    APPROVED: "APPROVED",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    REJECTED: "REJECTED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "AUDITING";
        }
        case 2: {
          return "APPROVED";
        }
        case 3: {
          return "ASSIGNED";
        }
        case 4: {
          return "HANDLED";
        }
        case 5: {
          return "PASSED";
        }
        case 6: {
          return "REJECTED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "AUDITING": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        case "ASSIGNED": {
          return 3;
        }
        case "HANDLED": {
          return 4;
        }
        case "PASSED": {
          return 5;
        }
        case "REJECTED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const DepositJSON = {
  /**
   * Serializes Deposit to JSON.
   */
  encode: function (msg: PartialDeep<Deposit>): string {
    return JSON.stringify(DepositJSON._writeMessage(msg));
  },

  /**
   * Deserializes Deposit from JSON.
   */
  decode: function (json: string): Deposit {
    return DepositJSON._readMessage(DepositJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deposit>): Deposit {
    return {
      id: 0n,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      expiredAt: protoscript.TimestampJSON.initialize(),
      version: 0n,
      status: Deposit.Status._fromInt(0),
      pairId: 0,
      baseAmount: "",
      quoteAmount: "",
      slippage: "",
      liquidity: "",
      feeAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Deposit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    if (msg.expiredAt && msg.expiredAt.seconds && msg.expiredAt.nanos) {
      json["expiredAt"] = protoscript.serializeTimestamp(msg.expiredAt);
    }
    if (msg.version) {
      json["version"] = String(msg.version);
    }
    if (msg.status && DepositJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.pairId) {
      json["pairId"] = msg.pairId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.slippage) {
      json["slippage"] = msg.slippage;
    }
    if (msg.liquidity) {
      json["liquidity"] = msg.liquidity;
    }
    if (msg.feeAmount) {
      json["feeAmount"] = msg.feeAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deposit, json: any): Deposit {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    const _expiredAt_ = json["expiredAt"] ?? json["expired_at"];
    if (_expiredAt_) {
      msg.expiredAt = protoscript.parseTimestamp(_expiredAt_);
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = BigInt(_version_);
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Deposit.Status._fromInt(_status_);
    }
    const _pairId_ = json["pairId"] ?? json["pair_id"];
    if (_pairId_) {
      msg.pairId = protoscript.parseNumber(_pairId_);
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _slippage_ = json["slippage"];
    if (_slippage_) {
      msg.slippage = _slippage_;
    }
    const _liquidity_ = json["liquidity"];
    if (_liquidity_) {
      msg.liquidity = _liquidity_;
    }
    const _feeAmount_ = json["feeAmount"] ?? json["fee_amount"];
    if (_feeAmount_) {
      msg.feeAmount = _feeAmount_;
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const OrderJSON = {
  /**
   * Serializes Order to JSON.
   */
  encode: function (msg: PartialDeep<Order>): string {
    return JSON.stringify(OrderJSON._writeMessage(msg));
  },

  /**
   * Deserializes Order from JSON.
   */
  decode: function (json: string): Order {
    return OrderJSON._readMessage(OrderJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Order>): Order {
    return {
      id: 0n,
      createdAt: protoscript.TimestampJSON.initialize(),
      payAssetId: "",
      fillAssetId: "",
      payAmount: "",
      fillAmount: "",
      minAmount: "",
      paths: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Order>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.payAssetId) {
      json["payAssetId"] = msg.payAssetId;
    }
    if (msg.fillAssetId) {
      json["fillAssetId"] = msg.fillAssetId;
    }
    if (msg.payAmount) {
      json["payAmount"] = msg.payAmount;
    }
    if (msg.fillAmount) {
      json["fillAmount"] = msg.fillAmount;
    }
    if (msg.minAmount) {
      json["minAmount"] = msg.minAmount;
    }
    if (msg.paths?.length) {
      json["paths"] = msg.paths.map(OrderJSON.Path._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, json: any): Order {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    const _fillAssetId_ = json["fillAssetId"] ?? json["fill_asset_id"];
    if (_fillAssetId_) {
      msg.fillAssetId = _fillAssetId_;
    }
    const _payAmount_ = json["payAmount"] ?? json["pay_amount"];
    if (_payAmount_) {
      msg.payAmount = _payAmount_;
    }
    const _fillAmount_ = json["fillAmount"] ?? json["fill_amount"];
    if (_fillAmount_) {
      msg.fillAmount = _fillAmount_;
    }
    const _minAmount_ = json["minAmount"] ?? json["min_amount"];
    if (_minAmount_) {
      msg.minAmount = _minAmount_;
    }
    const _paths_ = json["paths"];
    if (_paths_) {
      for (const item of _paths_) {
        const m = OrderJSON.Path.initialize();
        OrderJSON.Path._readMessage(m, item);
        msg.paths.push(m);
      }
    }
    return msg;
  },

  Path: {
    /**
     * Serializes Order.Path to JSON.
     */
    encode: function (msg: PartialDeep<Order.Path>): string {
      return JSON.stringify(OrderJSON.Path._writeMessage(msg));
    },

    /**
     * Deserializes Order.Path from JSON.
     */
    decode: function (json: string): Order.Path {
      return OrderJSON.Path._readMessage(
        OrderJSON.Path.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Order.Path with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Order.Path>): Order.Path {
      return {
        weight: 0,
        pairs: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Order.Path>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.weight) {
        json["weight"] = msg.weight;
      }
      if (msg.pairs?.length) {
        json["pairs"] = msg.pairs;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Order.Path, json: any): Order.Path {
      const _weight_ = json["weight"];
      if (_weight_) {
        msg.weight = protoscript.parseNumber(_weight_);
      }
      const _pairs_ = json["pairs"];
      if (_pairs_) {
        msg.pairs = _pairs_.map(protoscript.parseNumber);
      }
      return msg;
    },
  },
};

export const RequestJSON = {
  /**
   * Serializes Request to JSON.
   */
  encode: function (msg: PartialDeep<Request>): string {
    return JSON.stringify(RequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes Request from JSON.
   */
  decode: function (json: string): Request {
    return RequestJSON._readMessage(RequestJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Request with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Request>): Request {
    return {
      id: 0n,
      createdAt: protoscript.TimestampJSON.initialize(),
      systemVersion: 0,
      protocolVersion: 0,
      action: Action._fromInt(0),
      user: UserJSON.initialize(),
      followId: "",
      code: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Request>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.systemVersion) {
      json["systemVersion"] = msg.systemVersion;
    }
    if (msg.protocolVersion) {
      json["protocolVersion"] = msg.protocolVersion;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.user) {
      const _user_ = UserJSON._writeMessage(msg.user);
      if (Object.keys(_user_).length > 0) {
        json["user"] = _user_;
      }
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.code) {
      json["code"] = msg.code;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Request, json: any): Request {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _systemVersion_ = json["systemVersion"] ?? json["system_version"];
    if (_systemVersion_) {
      msg.systemVersion = protoscript.parseNumber(_systemVersion_);
    }
    const _protocolVersion_ =
      json["protocolVersion"] ?? json["protocol_version"];
    if (_protocolVersion_) {
      msg.protocolVersion = protoscript.parseNumber(_protocolVersion_);
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _user_ = json["user"];
    if (_user_) {
      UserJSON._readMessage(msg.user, _user_);
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _code_ = json["code"];
    if (_code_) {
      msg.code = protoscript.parseNumber(_code_);
    }
    return msg;
  },
};

export const ProposalJSON = {
  /**
   * Serializes Proposal to JSON.
   */
  encode: function (msg: PartialDeep<Proposal>): string {
    return JSON.stringify(ProposalJSON._writeMessage(msg));
  },

  /**
   * Deserializes Proposal from JSON.
   */
  decode: function (json: string): Proposal {
    return ProposalJSON._readMessage(
      ProposalJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Proposal>): Proposal {
    return {
      id: 0n,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      passedAt: protoscript.TimestampJSON.initialize(),
      version: 0n,
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      votes: [],
      addPair: undefined,
      updatePair: undefined,
      setProperty: undefined,
      flushProfit: undefined,
      withdraw: undefined,
      swapMethod: undefined,
      expiredAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Proposal>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    if (msg.passedAt && msg.passedAt.seconds && msg.passedAt.nanos) {
      json["passedAt"] = protoscript.serializeTimestamp(msg.passedAt);
    }
    if (msg.version) {
      json["version"] = String(msg.version);
    }
    if (msg.creator) {
      json["creator"] = msg.creator;
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.votes?.length) {
      json["votes"] = msg.votes;
    }
    if (msg.addPair != undefined) {
      const _addPair_ = ProposalJSON.AddPair._writeMessage(msg.addPair);
      json["addPair"] = _addPair_;
    }
    if (msg.updatePair != undefined) {
      const _updatePair_ = ProposalJSON.UpdatePair._writeMessage(
        msg.updatePair,
      );
      json["updatePair"] = _updatePair_;
    }
    if (msg.setProperty != undefined) {
      const _setProperty_ = ProposalJSON.SetProperty._writeMessage(
        msg.setProperty,
      );
      json["setProperty"] = _setProperty_;
    }
    if (msg.flushProfit != undefined) {
      const _flushProfit_ = ProposalJSON.FlushProfit._writeMessage(
        msg.flushProfit,
      );
      json["flushProfit"] = _flushProfit_;
    }
    if (msg.withdraw != undefined) {
      const _withdraw_ = ProposalJSON.Withdraw._writeMessage(msg.withdraw);
      json["withdraw"] = _withdraw_;
    }
    if (msg.swapMethod != undefined) {
      const _swapMethod_ = ProposalJSON.SwapMethod._writeMessage(
        msg.swapMethod,
      );
      json["swapMethod"] = _swapMethod_;
    }
    if (msg.expiredAt && msg.expiredAt.seconds && msg.expiredAt.nanos) {
      json["expiredAt"] = protoscript.serializeTimestamp(msg.expiredAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Proposal, json: any): Proposal {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    const _passedAt_ = json["passedAt"] ?? json["passed_at"];
    if (_passedAt_) {
      msg.passedAt = protoscript.parseTimestamp(_passedAt_);
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = BigInt(_version_);
    }
    const _creator_ = json["creator"];
    if (_creator_) {
      msg.creator = _creator_;
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _votes_ = json["votes"];
    if (_votes_) {
      msg.votes = _votes_;
    }
    const _addPair_ = json["addPair"] ?? json["add_pair"];
    if (_addPair_) {
      msg.addPair = ProposalJSON.AddPair.initialize();
      ProposalJSON.AddPair._readMessage(msg.addPair, _addPair_);
    }
    const _updatePair_ = json["updatePair"] ?? json["update_pair"];
    if (_updatePair_) {
      msg.updatePair = ProposalJSON.UpdatePair.initialize();
      ProposalJSON.UpdatePair._readMessage(msg.updatePair, _updatePair_);
    }
    const _setProperty_ = json["setProperty"] ?? json["set_property"];
    if (_setProperty_) {
      msg.setProperty = ProposalJSON.SetProperty.initialize();
      ProposalJSON.SetProperty._readMessage(msg.setProperty, _setProperty_);
    }
    const _flushProfit_ = json["flushProfit"] ?? json["flush_profit"];
    if (_flushProfit_) {
      msg.flushProfit = ProposalJSON.FlushProfit.initialize();
      ProposalJSON.FlushProfit._readMessage(msg.flushProfit, _flushProfit_);
    }
    const _withdraw_ = json["withdraw"];
    if (_withdraw_) {
      msg.withdraw = ProposalJSON.Withdraw.initialize();
      ProposalJSON.Withdraw._readMessage(msg.withdraw, _withdraw_);
    }
    const _swapMethod_ = json["swapMethod"] ?? json["swap_method"];
    if (_swapMethod_) {
      msg.swapMethod = ProposalJSON.SwapMethod.initialize();
      ProposalJSON.SwapMethod._readMessage(msg.swapMethod, _swapMethod_);
    }
    const _expiredAt_ = json["expiredAt"] ?? json["expired_at"];
    if (_expiredAt_) {
      msg.expiredAt = protoscript.parseTimestamp(_expiredAt_);
    }
    return msg;
  },

  AddPair: {
    /**
     * Serializes Proposal.AddPair to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.AddPair>): string {
      return JSON.stringify(ProposalJSON.AddPair._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.AddPair from JSON.
     */
    decode: function (json: string): Proposal.AddPair {
      return ProposalJSON.AddPair._readMessage(
        ProposalJSON.AddPair.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.AddPair with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.AddPair>): Proposal.AddPair {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        profitRate: "",
        fee: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.AddPair>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.baseAsset) {
        json["baseAsset"] = msg.baseAsset;
      }
      if (msg.quoteAsset) {
        json["quoteAsset"] = msg.quoteAsset;
      }
      if (msg.method) {
        json["method"] = msg.method;
      }
      if (msg.profitRate) {
        json["profitRate"] = msg.profitRate;
      }
      if (msg.fee) {
        json["fee"] = msg.fee;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.AddPair,
      json: any,
    ): Proposal.AddPair {
      const _baseAsset_ = json["baseAsset"] ?? json["base_asset"];
      if (_baseAsset_) {
        msg.baseAsset = _baseAsset_;
      }
      const _quoteAsset_ = json["quoteAsset"] ?? json["quote_asset"];
      if (_quoteAsset_) {
        msg.quoteAsset = _quoteAsset_;
      }
      const _method_ = json["method"];
      if (_method_) {
        msg.method = _method_;
      }
      const _profitRate_ = json["profitRate"] ?? json["profit_rate"];
      if (_profitRate_) {
        msg.profitRate = _profitRate_;
      }
      const _fee_ = json["fee"];
      if (_fee_) {
        msg.fee = _fee_;
      }
      return msg;
    },
  },

  UpdatePair: {
    /**
     * Serializes Proposal.UpdatePair to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.UpdatePair>): string {
      return JSON.stringify(ProposalJSON.UpdatePair._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.UpdatePair from JSON.
     */
    decode: function (json: string): Proposal.UpdatePair {
      return ProposalJSON.UpdatePair._readMessage(
        ProposalJSON.UpdatePair.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.UpdatePair with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.UpdatePair>,
    ): Proposal.UpdatePair {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        profitRate: "",
        fee: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.UpdatePair>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.baseAsset) {
        json["baseAsset"] = msg.baseAsset;
      }
      if (msg.quoteAsset) {
        json["quoteAsset"] = msg.quoteAsset;
      }
      if (msg.method) {
        json["method"] = msg.method;
      }
      if (msg.profitRate) {
        json["profitRate"] = msg.profitRate;
      }
      if (msg.fee) {
        json["fee"] = msg.fee;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.UpdatePair,
      json: any,
    ): Proposal.UpdatePair {
      const _baseAsset_ = json["baseAsset"] ?? json["base_asset"];
      if (_baseAsset_) {
        msg.baseAsset = _baseAsset_;
      }
      const _quoteAsset_ = json["quoteAsset"] ?? json["quote_asset"];
      if (_quoteAsset_) {
        msg.quoteAsset = _quoteAsset_;
      }
      const _method_ = json["method"];
      if (_method_) {
        msg.method = _method_;
      }
      const _profitRate_ = json["profitRate"] ?? json["profit_rate"];
      if (_profitRate_) {
        msg.profitRate = _profitRate_;
      }
      const _fee_ = json["fee"];
      if (_fee_) {
        msg.fee = _fee_;
      }
      return msg;
    },
  },

  SetProperty: {
    /**
     * Serializes Proposal.SetProperty to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.SetProperty>): string {
      return JSON.stringify(ProposalJSON.SetProperty._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.SetProperty from JSON.
     */
    decode: function (json: string): Proposal.SetProperty {
      return ProposalJSON.SetProperty._readMessage(
        ProposalJSON.SetProperty.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.SetProperty with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.SetProperty>,
    ): Proposal.SetProperty {
      return {
        key: "",
        value: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.SetProperty>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.SetProperty,
      json: any,
    ): Proposal.SetProperty {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  FlushProfit: {
    /**
     * Serializes Proposal.FlushProfit to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.FlushProfit>): string {
      return JSON.stringify(ProposalJSON.FlushProfit._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.FlushProfit from JSON.
     */
    decode: function (json: string): Proposal.FlushProfit {
      return ProposalJSON.FlushProfit._readMessage(
        ProposalJSON.FlushProfit.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.FlushProfit with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.FlushProfit>,
    ): Proposal.FlushProfit {
      return {
        baseAsset: "",
        quoteAsset: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.FlushProfit>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.baseAsset) {
        json["baseAsset"] = msg.baseAsset;
      }
      if (msg.quoteAsset) {
        json["quoteAsset"] = msg.quoteAsset;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.FlushProfit,
      json: any,
    ): Proposal.FlushProfit {
      const _baseAsset_ = json["baseAsset"] ?? json["base_asset"];
      if (_baseAsset_) {
        msg.baseAsset = _baseAsset_;
      }
      const _quoteAsset_ = json["quoteAsset"] ?? json["quote_asset"];
      if (_quoteAsset_) {
        msg.quoteAsset = _quoteAsset_;
      }
      return msg;
    },
  },

  Withdraw: {
    /**
     * Serializes Proposal.Withdraw to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.Withdraw>): string {
      return JSON.stringify(ProposalJSON.Withdraw._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.Withdraw from JSON.
     */
    decode: function (json: string): Proposal.Withdraw {
      return ProposalJSON.Withdraw._readMessage(
        ProposalJSON.Withdraw.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.Withdraw with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.Withdraw>): Proposal.Withdraw {
      return {
        opponent: "",
        asset: "",
        amount: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.Withdraw>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.opponent) {
        json["opponent"] = msg.opponent;
      }
      if (msg.asset) {
        json["asset"] = msg.asset;
      }
      if (msg.amount) {
        json["amount"] = msg.amount;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.Withdraw,
      json: any,
    ): Proposal.Withdraw {
      const _opponent_ = json["opponent"];
      if (_opponent_) {
        msg.opponent = _opponent_;
      }
      const _asset_ = json["asset"];
      if (_asset_) {
        msg.asset = _asset_;
      }
      const _amount_ = json["amount"];
      if (_amount_) {
        msg.amount = _amount_;
      }
      return msg;
    },
  },

  SwapMethod: {
    /**
     * Serializes Proposal.SwapMethod to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.SwapMethod>): string {
      return JSON.stringify(ProposalJSON.SwapMethod._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.SwapMethod from JSON.
     */
    decode: function (json: string): Proposal.SwapMethod {
      return ProposalJSON.SwapMethod._readMessage(
        ProposalJSON.SwapMethod.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.SwapMethod with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Proposal.SwapMethod>,
    ): Proposal.SwapMethod {
      return {
        baseAsset: "",
        quoteAsset: "",
        method: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.SwapMethod>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.baseAsset) {
        json["baseAsset"] = msg.baseAsset;
      }
      if (msg.quoteAsset) {
        json["quoteAsset"] = msg.quoteAsset;
      }
      if (msg.method) {
        json["method"] = msg.method;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.SwapMethod,
      json: any,
    ): Proposal.SwapMethod {
      const _baseAsset_ = json["baseAsset"] ?? json["base_asset"];
      if (_baseAsset_) {
        msg.baseAsset = _baseAsset_;
      }
      const _quoteAsset_ = json["quoteAsset"] ?? json["quote_asset"];
      if (_quoteAsset_) {
        msg.quoteAsset = _quoteAsset_;
      }
      const _method_ = json["method"];
      if (_method_) {
        msg.method = _method_;
      }
      return msg;
    },
  },
};

export const GetInfoRequestJSON = {
  /**
   * Serializes GetInfoRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<GetInfoRequest>): string {
    return "{}";
  },

  /**
   * Deserializes GetInfoRequest from JSON.
   */
  decode: function (_json?: string): GetInfoRequest {
    return {};
  },

  /**
   * Initializes GetInfoRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoRequest>): GetInfoRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<GetInfoRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetInfoRequest, _json: any): GetInfoRequest {
    return msg;
  },
};

export const GetInfoResponseJSON = {
  /**
   * Serializes GetInfoResponse to JSON.
   */
  encode: function (msg: PartialDeep<GetInfoResponse>): string {
    return JSON.stringify(GetInfoResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetInfoResponse from JSON.
   */
  decode: function (json: string): GetInfoResponse {
    return GetInfoResponseJSON._readMessage(
      GetInfoResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetInfoResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoResponse>): GetInfoResponse {
    return {
      members: [],
      threshold: 0,
      version: "",
      mixAddress: "",
      blockedActions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetInfoResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.members?.length) {
      json["members"] = msg.members;
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.version) {
      json["version"] = msg.version;
    }
    if (msg.mixAddress) {
      json["mixAddress"] = msg.mixAddress;
    }
    if (msg.blockedActions?.length) {
      json["blockedActions"] = msg.blockedActions;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetInfoResponse, json: any): GetInfoResponse {
    const _members_ = json["members"];
    if (_members_) {
      msg.members = _members_;
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = _version_;
    }
    const _mixAddress_ = json["mixAddress"] ?? json["mix_address"];
    if (_mixAddress_) {
      msg.mixAddress = _mixAddress_;
    }
    const _blockedActions_ = json["blockedActions"] ?? json["blocked_actions"];
    if (_blockedActions_) {
      msg.blockedActions = _blockedActions_.map(Action._fromInt);
    }
    return msg;
  },
};

export const ListRequestsRequestJSON = {
  /**
   * Serializes ListRequestsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListRequestsRequest>): string {
    return JSON.stringify(ListRequestsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListRequestsRequest from JSON.
   */
  decode: function (json: string): ListRequestsRequest {
    return ListRequestsRequestJSON._readMessage(
      ListRequestsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListRequestsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListRequestsRequest>,
  ): ListRequestsRequest {
    return {
      offset: 0n,
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListRequestsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.offset) {
      json["offset"] = String(msg.offset);
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListRequestsRequest,
    json: any,
  ): ListRequestsRequest {
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = BigInt(_offset_);
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    return msg;
  },
};

export const ListRequestsResponseJSON = {
  /**
   * Serializes ListRequestsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListRequestsResponse>): string {
    return JSON.stringify(ListRequestsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListRequestsResponse from JSON.
   */
  decode: function (json: string): ListRequestsResponse {
    return ListRequestsResponseJSON._readMessage(
      ListRequestsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListRequestsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListRequestsResponse>,
  ): ListRequestsResponse {
    return {
      requests: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListRequestsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requests?.length) {
      json["requests"] = msg.requests.map(RequestJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListRequestsResponse,
    json: any,
  ): ListRequestsResponse {
    const _requests_ = json["requests"];
    if (_requests_) {
      for (const item of _requests_) {
        const m = RequestJSON.initialize();
        RequestJSON._readMessage(m, item);
        msg.requests.push(m);
      }
    }
    return msg;
  },
};

export const FindRequestRequestJSON = {
  /**
   * Serializes FindRequestRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindRequestRequest>): string {
    return JSON.stringify(FindRequestRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindRequestRequest from JSON.
   */
  decode: function (json: string): FindRequestRequest {
    return FindRequestRequestJSON._readMessage(
      FindRequestRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindRequestRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindRequestRequest>): FindRequestRequest {
    return {
      user: UserJSON.initialize(),
      followId: "",
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindRequestRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.user) {
      const _user_ = UserJSON._writeMessage(msg.user);
      if (Object.keys(_user_).length > 0) {
        json["user"] = _user_;
      }
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindRequestRequest,
    json: any,
  ): FindRequestRequest {
    const _user_ = json["user"];
    if (_user_) {
      UserJSON._readMessage(msg.user, _user_);
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    return msg;
  },
};

export const FindRequestResponseJSON = {
  /**
   * Serializes FindRequestResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindRequestResponse>): string {
    return JSON.stringify(FindRequestResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindRequestResponse from JSON.
   */
  decode: function (json: string): FindRequestResponse {
    return FindRequestResponseJSON._readMessage(
      FindRequestResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindRequestResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindRequestResponse>,
  ): FindRequestResponse {
    return {
      request: RequestJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindRequestResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.request) {
      const _request_ = RequestJSON._writeMessage(msg.request);
      if (Object.keys(_request_).length > 0) {
        json["request"] = _request_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindRequestResponse,
    json: any,
  ): FindRequestResponse {
    const _request_ = json["request"];
    if (_request_) {
      RequestJSON._readMessage(msg.request, _request_);
    }
    return msg;
  },
};

export const FindDepositRequestJSON = {
  /**
   * Serializes FindDepositRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindDepositRequest>): string {
    return JSON.stringify(FindDepositRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindDepositRequest from JSON.
   */
  decode: function (json: string): FindDepositRequest {
    return FindDepositRequestJSON._readMessage(
      FindDepositRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindDepositRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindDepositRequest>): FindDepositRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindDepositRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindDepositRequest,
    json: any,
  ): FindDepositRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    return msg;
  },
};

export const FindDepositResponseJSON = {
  /**
   * Serializes FindDepositResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindDepositResponse>): string {
    return JSON.stringify(FindDepositResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindDepositResponse from JSON.
   */
  decode: function (json: string): FindDepositResponse {
    return FindDepositResponseJSON._readMessage(
      FindDepositResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindDepositResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindDepositResponse>,
  ): FindDepositResponse {
    return {
      deposit: DepositJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindDepositResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deposit) {
      const _deposit_ = DepositJSON._writeMessage(msg.deposit);
      if (Object.keys(_deposit_).length > 0) {
        json["deposit"] = _deposit_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindDepositResponse,
    json: any,
  ): FindDepositResponse {
    const _deposit_ = json["deposit"];
    if (_deposit_) {
      DepositJSON._readMessage(msg.deposit, _deposit_);
    }
    return msg;
  },
};

export const ListDepositsRequestJSON = {
  /**
   * Serializes ListDepositsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListDepositsRequest>): string {
    return JSON.stringify(ListDepositsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListDepositsRequest from JSON.
   */
  decode: function (json: string): ListDepositsRequest {
    return ListDepositsRequestJSON._readMessage(
      ListDepositsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListDepositsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListDepositsRequest>,
  ): ListDepositsRequest {
    return {
      status: Deposit.Status._fromInt(0),
      offset: 0n,
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListDepositsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status && DepositJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.offset) {
      json["offset"] = String(msg.offset);
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListDepositsRequest,
    json: any,
  ): ListDepositsRequest {
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Deposit.Status._fromInt(_status_);
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = BigInt(_offset_);
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    return msg;
  },
};

export const ListDepositsResponseJSON = {
  /**
   * Serializes ListDepositsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListDepositsResponse>): string {
    return JSON.stringify(ListDepositsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListDepositsResponse from JSON.
   */
  decode: function (json: string): ListDepositsResponse {
    return ListDepositsResponseJSON._readMessage(
      ListDepositsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListDepositsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListDepositsResponse>,
  ): ListDepositsResponse {
    return {
      deposits: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListDepositsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deposits?.length) {
      json["deposits"] = msg.deposits.map(DepositJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListDepositsResponse,
    json: any,
  ): ListDepositsResponse {
    const _deposits_ = json["deposits"];
    if (_deposits_) {
      for (const item of _deposits_) {
        const m = DepositJSON.initialize();
        DepositJSON._readMessage(m, item);
        msg.deposits.push(m);
      }
    }
    return msg;
  },
};

export const ListPairsRequestJSON = {
  /**
   * Serializes ListPairsRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<ListPairsRequest>): string {
    return "{}";
  },

  /**
   * Deserializes ListPairsRequest from JSON.
   */
  decode: function (_json?: string): ListPairsRequest {
    return {};
  },

  /**
   * Initializes ListPairsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPairsRequest>): ListPairsRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListPairsRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListPairsRequest, _json: any): ListPairsRequest {
    return msg;
  },
};

export const ListPairsResponseJSON = {
  /**
   * Serializes ListPairsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListPairsResponse>): string {
    return JSON.stringify(ListPairsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListPairsResponse from JSON.
   */
  decode: function (json: string): ListPairsResponse {
    return ListPairsResponseJSON._readMessage(
      ListPairsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListPairsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPairsResponse>): ListPairsResponse {
    return {
      pairs: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListPairsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.pairs?.length) {
      json["pairs"] = msg.pairs.map(PairJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListPairsResponse,
    json: any,
  ): ListPairsResponse {
    const _pairs_ = json["pairs"];
    if (_pairs_) {
      for (const item of _pairs_) {
        const m = PairJSON.initialize();
        PairJSON._readMessage(m, item);
        msg.pairs.push(m);
      }
    }
    return msg;
  },
};

export const ListTransactionsRequestJSON = {
  /**
   * Serializes ListTransactionsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListTransactionsRequest>): string {
    return JSON.stringify(ListTransactionsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTransactionsRequest from JSON.
   */
  decode: function (json: string): ListTransactionsRequest {
    return ListTransactionsRequestJSON._readMessage(
      ListTransactionsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTransactionsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransactionsRequest>,
  ): ListTransactionsRequest {
    return {
      group: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransactionsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransactionsRequest,
    json: any,
  ): ListTransactionsRequest {
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    return msg;
  },
};

export const ListTransactionsResponseJSON = {
  /**
   * Serializes ListTransactionsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListTransactionsResponse>): string {
    return JSON.stringify(ListTransactionsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTransactionsResponse from JSON.
   */
  decode: function (json: string): ListTransactionsResponse {
    return ListTransactionsResponseJSON._readMessage(
      ListTransactionsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTransactionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransactionsResponse>,
  ): ListTransactionsResponse {
    return {
      transactions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransactionsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.transactions?.length) {
      json["transactions"] = msg.transactions.map(
        TransactionJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransactionsResponse,
    json: any,
  ): ListTransactionsResponse {
    const _transactions_ = json["transactions"];
    if (_transactions_) {
      for (const item of _transactions_) {
        const m = TransactionJSON.initialize();
        TransactionJSON._readMessage(m, item);
        msg.transactions.push(m);
      }
    }
    return msg;
  },
};

export const ListTransfersRequestJSON = {
  /**
   * Serializes ListTransfersRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListTransfersRequest>): string {
    return JSON.stringify(ListTransfersRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTransfersRequest from JSON.
   */
  decode: function (json: string): ListTransfersRequest {
    return ListTransfersRequestJSON._readMessage(
      ListTransfersRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTransfersRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransfersRequest>,
  ): ListTransfersRequest {
    return {
      group: 0n,
      status: Transfer.Status._fromInt(0),
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransfersRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    if (msg.status && TransferJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransfersRequest,
    json: any,
  ): ListTransfersRequest {
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Transfer.Status._fromInt(_status_);
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    return msg;
  },
};

export const ListTransfersResponseJSON = {
  /**
   * Serializes ListTransfersResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListTransfersResponse>): string {
    return JSON.stringify(ListTransfersResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTransfersResponse from JSON.
   */
  decode: function (json: string): ListTransfersResponse {
    return ListTransfersResponseJSON._readMessage(
      ListTransfersResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTransfersResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListTransfersResponse>,
  ): ListTransfersResponse {
    return {
      transfers: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTransfersResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.transfers?.length) {
      json["transfers"] = msg.transfers.map(TransferJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTransfersResponse,
    json: any,
  ): ListTransfersResponse {
    const _transfers_ = json["transfers"];
    if (_transfers_) {
      for (const item of _transfers_) {
        const m = TransferJSON.initialize();
        TransferJSON._readMessage(m, item);
        msg.transfers.push(m);
      }
    }
    return msg;
  },
};

export const FindTransferRequestJSON = {
  /**
   * Serializes FindTransferRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindTransferRequest>): string {
    return JSON.stringify(FindTransferRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindTransferRequest from JSON.
   */
  decode: function (json: string): FindTransferRequest {
    return FindTransferRequestJSON._readMessage(
      FindTransferRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindTransferRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindTransferRequest>,
  ): FindTransferRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTransferRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTransferRequest,
    json: any,
  ): FindTransferRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const FindTransferResponseJSON = {
  /**
   * Serializes FindTransferResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindTransferResponse>): string {
    return JSON.stringify(FindTransferResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindTransferResponse from JSON.
   */
  decode: function (json: string): FindTransferResponse {
    return FindTransferResponseJSON._readMessage(
      FindTransferResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindTransferResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindTransferResponse>,
  ): FindTransferResponse {
    return {
      transfer: TransferJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTransferResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.transfer) {
      const _transfer_ = TransferJSON._writeMessage(msg.transfer);
      if (Object.keys(_transfer_).length > 0) {
        json["transfer"] = _transfer_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTransferResponse,
    json: any,
  ): FindTransferResponse {
    const _transfer_ = json["transfer"];
    if (_transfer_) {
      TransferJSON._readMessage(msg.transfer, _transfer_);
    }
    return msg;
  },
};

export const FindOrderRequestJSON = {
  /**
   * Serializes FindOrderRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindOrderRequest>): string {
    return JSON.stringify(FindOrderRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindOrderRequest from JSON.
   */
  decode: function (json: string): FindOrderRequest {
    return FindOrderRequestJSON._readMessage(
      FindOrderRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindOrderRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindOrderRequest>): FindOrderRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindOrderRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindOrderRequest, json: any): FindOrderRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    return msg;
  },
};

export const FindOrderResponseJSON = {
  /**
   * Serializes FindOrderResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindOrderResponse>): string {
    return JSON.stringify(FindOrderResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindOrderResponse from JSON.
   */
  decode: function (json: string): FindOrderResponse {
    return FindOrderResponseJSON._readMessage(
      FindOrderResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindOrderResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindOrderResponse>): FindOrderResponse {
    return {
      order: OrderJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindOrderResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.order) {
      const _order_ = OrderJSON._writeMessage(msg.order);
      if (Object.keys(_order_).length > 0) {
        json["order"] = _order_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindOrderResponse,
    json: any,
  ): FindOrderResponse {
    const _order_ = json["order"];
    if (_order_) {
      OrderJSON._readMessage(msg.order, _order_);
    }
    return msg;
  },
};

export const FindProposalRequestJSON = {
  /**
   * Serializes FindProposalRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindProposalRequest>): string {
    return JSON.stringify(FindProposalRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindProposalRequest from JSON.
   */
  decode: function (json: string): FindProposalRequest {
    return FindProposalRequestJSON._readMessage(
      FindProposalRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindProposalRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindProposalRequest>,
  ): FindProposalRequest {
    return {
      id: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindProposalRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindProposalRequest,
    json: any,
  ): FindProposalRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    return msg;
  },
};

export const FindProposalResponseJSON = {
  /**
   * Serializes FindProposalResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindProposalResponse>): string {
    return JSON.stringify(FindProposalResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindProposalResponse from JSON.
   */
  decode: function (json: string): FindProposalResponse {
    return FindProposalResponseJSON._readMessage(
      FindProposalResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindProposalResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FindProposalResponse>,
  ): FindProposalResponse {
    return {
      proposal: ProposalJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindProposalResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.proposal) {
      const _proposal_ = ProposalJSON._writeMessage(msg.proposal);
      if (Object.keys(_proposal_).length > 0) {
        json["proposal"] = _proposal_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindProposalResponse,
    json: any,
  ): FindProposalResponse {
    const _proposal_ = json["proposal"];
    if (_proposal_) {
      ProposalJSON._readMessage(msg.proposal, _proposal_);
    }
    return msg;
  },
};

export const FindPairRequestJSON = {
  /**
   * Serializes FindPairRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindPairRequest>): string {
    return JSON.stringify(FindPairRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindPairRequest from JSON.
   */
  decode: function (json: string): FindPairRequest {
    return FindPairRequestJSON._readMessage(
      FindPairRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindPairRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPairRequest>): FindPairRequest {
    return {
      id: 0,
      baseAssetId: "",
      quoteAssetId: "",
      liquidityAssetId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPairRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.baseAssetId) {
      json["baseAssetId"] = msg.baseAssetId;
    }
    if (msg.quoteAssetId) {
      json["quoteAssetId"] = msg.quoteAssetId;
    }
    if (msg.liquidityAssetId) {
      json["liquidityAssetId"] = msg.liquidityAssetId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindPairRequest, json: any): FindPairRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _baseAssetId_ = json["baseAssetId"] ?? json["base_asset_id"];
    if (_baseAssetId_) {
      msg.baseAssetId = _baseAssetId_;
    }
    const _quoteAssetId_ = json["quoteAssetId"] ?? json["quote_asset_id"];
    if (_quoteAssetId_) {
      msg.quoteAssetId = _quoteAssetId_;
    }
    const _liquidityAssetId_ =
      json["liquidityAssetId"] ?? json["liquidity_asset_id"];
    if (_liquidityAssetId_) {
      msg.liquidityAssetId = _liquidityAssetId_;
    }
    return msg;
  },
};

export const FindPairResponseJSON = {
  /**
   * Serializes FindPairResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindPairResponse>): string {
    return JSON.stringify(FindPairResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindPairResponse from JSON.
   */
  decode: function (json: string): FindPairResponse {
    return FindPairResponseJSON._readMessage(
      FindPairResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindPairResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPairResponse>): FindPairResponse {
    return {
      pair: PairJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPairResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.pair) {
      const _pair_ = PairJSON._writeMessage(msg.pair);
      if (Object.keys(_pair_).length > 0) {
        json["pair"] = _pair_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindPairResponse, json: any): FindPairResponse {
    const _pair_ = json["pair"];
    if (_pair_) {
      PairJSON._readMessage(msg.pair, _pair_);
    }
    return msg;
  },
};
