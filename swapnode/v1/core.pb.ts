// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: swapnode/v1/core.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "NOT_SET"
  | "ADD"
  | "REMOVE"
  | "SWAP"
  | "EXPIRE_DEPOSIT"
  | "AUDIT"
  | "SWAPV2";

export interface Header {
  version: number;
  userId: string;
  followId: string;
  action: Action;
}

export interface Pair {
  baseAssetId: string;
  quoteAssetId: string;
  baseAmount: string;
  quoteAmount: string;
  liquidity: string;
  liquidityAssetId: string;
  routeId: number;
  feePercent: string;
  maxLiquidity: string;
  swapMethod: string;
  version: number;
}

export interface Output {
  id: string;
  createdAt: protoscript.Timestamp;
  assetId: string;
  amount: string;
  sender: string;
  memo: string;
  transactionHash: string;
  outputIndex: number;
  header: Header;
}

export interface Order {
  id: string;
  createdAt: protoscript.Timestamp;
  userId: string;
  followId: string;
  payAssetId: string;
  payAmount: string;
  fillAssetId: string;
  fillAmount: string;
  minAmount: string;
  routes: string;
}

export interface Deposit {
  id: string;
  createdAt: protoscript.Timestamp;
  expiredAt: protoscript.Timestamp;
  userId: string;
  followId: string;
  status: Deposit.Status;
  baseAssetId: string;
  baseAmount: string;
  quoteAssetId: string;
  quoteAmount: string;
  slippage: string;
}

export declare namespace Deposit {
  export type Status = "NOT_SET" | "PENDING" | "CANCELLED" | "DONE";
}

export interface Transaction {
  id: string;
  createdAt: protoscript.Timestamp;
  userId: string;
  followId: string;
  action: Action;
  baseAssetId: string;
  baseAmount: string;
  quoteAssetId: string;
  quoteAmount: string;
  feeAssetId: string;
  feeAmount: string;
  liquidityAmount: string;
}

export interface Transfer {
  id: string;
  createdAt: protoscript.Timestamp;
  assetId: string;
  amount: string;
  opponents: string[];
  threshold: number;
  memo: string;
  signedTx: string;
  status: Transfer.Status;
}

export declare namespace Transfer {
  export type Status = "PENDING_NOT_SET" | "ASSIGNED" | "HANDLED" | "PASSED";
}

export interface Audit {
  id: string;
  createdAt: protoscript.Timestamp;
  assetId: string;
  amount: string;
  userId: string;
  status: Audit.Status;
  memo: string;
  reviewedBy: string;
}

export declare namespace Audit {
  export type Status = "PENDING_NOT_SET" | "REJECTED" | "APPROVED";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  NOT_SET: "NOT_SET",
  ADD: "ADD",
  REMOVE: "REMOVE",
  SWAP: "SWAP",
  EXPIRE_DEPOSIT: "EXPIRE_DEPOSIT",
  AUDIT: "AUDIT",
  SWAPV2: "SWAPV2",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "NOT_SET";
      }
      case 1: {
        return "ADD";
      }
      case 2: {
        return "REMOVE";
      }
      case 3: {
        return "SWAP";
      }
      case 4: {
        return "EXPIRE_DEPOSIT";
      }
      case 5: {
        return "AUDIT";
      }
      case 6: {
        return "SWAPV2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "NOT_SET": {
        return 0;
      }
      case "ADD": {
        return 1;
      }
      case "REMOVE": {
        return 2;
      }
      case "SWAP": {
        return 3;
      }
      case "EXPIRE_DEPOSIT": {
        return 4;
      }
      case "AUDIT": {
        return 5;
      }
      case "SWAPV2": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Header = {
  /**
   * Serializes Header to protobuf.
   */
  encode: function (msg: PartialDeep<Header>): Uint8Array {
    return Header._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Header from protobuf.
   */
  decode: function (bytes: ByteSource): Header {
    return Header._readMessage(
      Header.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Header with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Header>): Header {
    return {
      version: 0,
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Header>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.version) {
      writer.writeInt32(1, msg.version);
    }
    if (msg.userId) {
      writer.writeString(2, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(3, msg.followId);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(4, Action._toInt(msg.action));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Header,
    reader: protoscript.BinaryReader,
  ): Header {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.version = reader.readInt32();
          break;
        }
        case 2: {
          msg.userId = reader.readString();
          break;
        }
        case 3: {
          msg.followId = reader.readString();
          break;
        }
        case 4: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Pair = {
  /**
   * Serializes Pair to protobuf.
   */
  encode: function (msg: PartialDeep<Pair>): Uint8Array {
    return Pair._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Pair from protobuf.
   */
  decode: function (bytes: ByteSource): Pair {
    return Pair._readMessage(
      Pair.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pair>): Pair {
    return {
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      liquidity: "",
      liquidityAssetId: "",
      routeId: 0,
      feePercent: "",
      maxLiquidity: "",
      swapMethod: "",
      version: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Pair>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.baseAssetId) {
      writer.writeString(1, msg.baseAssetId);
    }
    if (msg.quoteAssetId) {
      writer.writeString(2, msg.quoteAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(3, msg.baseAmount);
    }
    if (msg.quoteAmount) {
      writer.writeString(4, msg.quoteAmount);
    }
    if (msg.liquidity) {
      writer.writeString(5, msg.liquidity);
    }
    if (msg.liquidityAssetId) {
      writer.writeString(6, msg.liquidityAssetId);
    }
    if (msg.routeId) {
      writer.writeInt32(7, msg.routeId);
    }
    if (msg.feePercent) {
      writer.writeString(8, msg.feePercent);
    }
    if (msg.maxLiquidity) {
      writer.writeString(9, msg.maxLiquidity);
    }
    if (msg.swapMethod) {
      writer.writeString(10, msg.swapMethod);
    }
    if (msg.version) {
      writer.writeInt32(11, msg.version);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, reader: protoscript.BinaryReader): Pair {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 2: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 3: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 4: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 5: {
          msg.liquidity = reader.readString();
          break;
        }
        case 6: {
          msg.liquidityAssetId = reader.readString();
          break;
        }
        case 7: {
          msg.routeId = reader.readInt32();
          break;
        }
        case 8: {
          msg.feePercent = reader.readString();
          break;
        }
        case 9: {
          msg.maxLiquidity = reader.readString();
          break;
        }
        case 10: {
          msg.swapMethod = reader.readString();
          break;
        }
        case 11: {
          msg.version = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Output = {
  /**
   * Serializes Output to protobuf.
   */
  encode: function (msg: PartialDeep<Output>): Uint8Array {
    return Output._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Output from protobuf.
   */
  decode: function (bytes: ByteSource): Output {
    return Output._readMessage(
      Output.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Output with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Output>): Output {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      assetId: "",
      amount: "",
      sender: "",
      memo: "",
      transactionHash: "",
      outputIndex: 0,
      header: Header.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Output>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.sender) {
      writer.writeString(5, msg.sender);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    if (msg.transactionHash) {
      writer.writeString(7, msg.transactionHash);
    }
    if (msg.outputIndex) {
      writer.writeInt32(8, msg.outputIndex);
    }
    if (msg.header) {
      writer.writeMessage(9, msg.header, Header._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Output,
    reader: protoscript.BinaryReader,
  ): Output {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.sender = reader.readString();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        case 7: {
          msg.transactionHash = reader.readString();
          break;
        }
        case 8: {
          msg.outputIndex = reader.readInt32();
          break;
        }
        case 9: {
          reader.readMessage(msg.header, Header._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Order = {
  /**
   * Serializes Order to protobuf.
   */
  encode: function (msg: PartialDeep<Order>): Uint8Array {
    return Order._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Order from protobuf.
   */
  decode: function (bytes: ByteSource): Order {
    return Order._readMessage(
      Order.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Order>): Order {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      userId: "",
      followId: "",
      payAssetId: "",
      payAmount: "",
      fillAssetId: "",
      fillAmount: "",
      minAmount: "",
      routes: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Order>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.userId) {
      writer.writeString(3, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(4, msg.followId);
    }
    if (msg.payAssetId) {
      writer.writeString(5, msg.payAssetId);
    }
    if (msg.payAmount) {
      writer.writeString(6, msg.payAmount);
    }
    if (msg.fillAssetId) {
      writer.writeString(7, msg.fillAssetId);
    }
    if (msg.fillAmount) {
      writer.writeString(8, msg.fillAmount);
    }
    if (msg.minAmount) {
      writer.writeString(9, msg.minAmount);
    }
    if (msg.routes) {
      writer.writeString(10, msg.routes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, reader: protoscript.BinaryReader): Order {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.userId = reader.readString();
          break;
        }
        case 4: {
          msg.followId = reader.readString();
          break;
        }
        case 5: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 6: {
          msg.payAmount = reader.readString();
          break;
        }
        case 7: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 8: {
          msg.fillAmount = reader.readString();
          break;
        }
        case 9: {
          msg.minAmount = reader.readString();
          break;
        }
        case 10: {
          msg.routes = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Deposit = {
  /**
   * Serializes Deposit to protobuf.
   */
  encode: function (msg: PartialDeep<Deposit>): Uint8Array {
    return Deposit._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Deposit from protobuf.
   */
  decode: function (bytes: ByteSource): Deposit {
    return Deposit._readMessage(
      Deposit.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deposit>): Deposit {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      expiredAt: protoscript.Timestamp.initialize(),
      userId: "",
      followId: "",
      status: Deposit.Status._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      slippage: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Deposit>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.expiredAt) {
      writer.writeMessage(
        3,
        msg.expiredAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.userId) {
      writer.writeString(4, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(5, msg.followId);
    }
    if (msg.status && Deposit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Deposit.Status._toInt(msg.status));
    }
    if (msg.baseAssetId) {
      writer.writeString(7, msg.baseAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(8, msg.baseAmount);
    }
    if (msg.quoteAssetId) {
      writer.writeString(9, msg.quoteAssetId);
    }
    if (msg.quoteAmount) {
      writer.writeString(10, msg.quoteAmount);
    }
    if (msg.slippage) {
      writer.writeString(11, msg.slippage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Deposit,
    reader: protoscript.BinaryReader,
  ): Deposit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.expiredAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.userId = reader.readString();
          break;
        }
        case 5: {
          msg.followId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Deposit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 8: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 9: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 10: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 11: {
          msg.slippage = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: PartialDeep<Transaction>): Uint8Array {
    return Transaction._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      feeAssetId: "",
      feeAmount: "",
      liquidityAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.userId) {
      writer.writeString(3, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(4, msg.followId);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(5, Action._toInt(msg.action));
    }
    if (msg.baseAssetId) {
      writer.writeString(6, msg.baseAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(7, msg.baseAmount);
    }
    if (msg.quoteAssetId) {
      writer.writeString(8, msg.quoteAssetId);
    }
    if (msg.quoteAmount) {
      writer.writeString(9, msg.quoteAmount);
    }
    if (msg.feeAssetId) {
      writer.writeString(10, msg.feeAssetId);
    }
    if (msg.feeAmount) {
      writer.writeString(11, msg.feeAmount);
    }
    if (msg.liquidityAmount) {
      writer.writeString(12, msg.liquidityAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transaction,
    reader: protoscript.BinaryReader,
  ): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.userId = reader.readString();
          break;
        }
        case 4: {
          msg.followId = reader.readString();
          break;
        }
        case 5: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 7: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 8: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 9: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 10: {
          msg.feeAssetId = reader.readString();
          break;
        }
        case 11: {
          msg.feeAmount = reader.readString();
          break;
        }
        case 12: {
          msg.liquidityAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: PartialDeep<Transfer>): Uint8Array {
    return Transfer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      signedTx: "",
      status: Transfer.Status._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(5, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeInt32(6, msg.threshold);
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.signedTx) {
      writer.writeString(8, msg.signedTx);
    }
    if (msg.status && Transfer.Status._toInt(msg.status)) {
      writer.writeEnum(9, Transfer.Status._toInt(msg.status));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transfer,
    reader: protoscript.BinaryReader,
  ): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 6: {
          msg.threshold = reader.readInt32();
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.signedTx = reader.readString();
          break;
        }
        case 9: {
          msg.status = Transfer.Status._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "ASSIGNED";
        }
        case 2: {
          return "HANDLED";
        }
        case 3: {
          return "PASSED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "ASSIGNED": {
          return 1;
        }
        case "HANDLED": {
          return 2;
        }
        case "PASSED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Audit = {
  /**
   * Serializes Audit to protobuf.
   */
  encode: function (msg: PartialDeep<Audit>): Uint8Array {
    return Audit._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Audit from protobuf.
   */
  decode: function (bytes: ByteSource): Audit {
    return Audit._readMessage(
      Audit.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Audit>): Audit {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Audit>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.userId) {
      writer.writeString(5, msg.userId);
    }
    if (msg.status && Audit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Audit.Status._toInt(msg.status));
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.reviewedBy) {
      writer.writeString(8, msg.reviewedBy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, reader: protoscript.BinaryReader): Audit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.userId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Audit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.reviewedBy = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    REJECTED: "REJECTED",
    APPROVED: "APPROVED",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "REJECTED";
        }
        case 2: {
          return "APPROVED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "REJECTED": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  NOT_SET: "NOT_SET",
  ADD: "ADD",
  REMOVE: "REMOVE",
  SWAP: "SWAP",
  EXPIRE_DEPOSIT: "EXPIRE_DEPOSIT",
  AUDIT: "AUDIT",
  SWAPV2: "SWAPV2",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "NOT_SET";
      }
      case 1: {
        return "ADD";
      }
      case 2: {
        return "REMOVE";
      }
      case 3: {
        return "SWAP";
      }
      case 4: {
        return "EXPIRE_DEPOSIT";
      }
      case 5: {
        return "AUDIT";
      }
      case 6: {
        return "SWAPV2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "NOT_SET": {
        return 0;
      }
      case "ADD": {
        return 1;
      }
      case "REMOVE": {
        return 2;
      }
      case "SWAP": {
        return 3;
      }
      case "EXPIRE_DEPOSIT": {
        return 4;
      }
      case "AUDIT": {
        return 5;
      }
      case "SWAPV2": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const HeaderJSON = {
  /**
   * Serializes Header to JSON.
   */
  encode: function (msg: PartialDeep<Header>): string {
    return JSON.stringify(HeaderJSON._writeMessage(msg));
  },

  /**
   * Deserializes Header from JSON.
   */
  decode: function (json: string): Header {
    return HeaderJSON._readMessage(HeaderJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Header with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Header>): Header {
    return {
      version: 0,
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Header>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.version) {
      json["version"] = msg.version;
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Header, json: any): Header {
    const _version_ = json["version"];
    if (_version_) {
      msg.version = protoscript.parseNumber(_version_);
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    return msg;
  },
};

export const PairJSON = {
  /**
   * Serializes Pair to JSON.
   */
  encode: function (msg: PartialDeep<Pair>): string {
    return JSON.stringify(PairJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pair from JSON.
   */
  decode: function (json: string): Pair {
    return PairJSON._readMessage(PairJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pair>): Pair {
    return {
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      liquidity: "",
      liquidityAssetId: "",
      routeId: 0,
      feePercent: "",
      maxLiquidity: "",
      swapMethod: "",
      version: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Pair>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.baseAssetId) {
      json["baseAssetId"] = msg.baseAssetId;
    }
    if (msg.quoteAssetId) {
      json["quoteAssetId"] = msg.quoteAssetId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.liquidity) {
      json["liquidity"] = msg.liquidity;
    }
    if (msg.liquidityAssetId) {
      json["liquidityAssetId"] = msg.liquidityAssetId;
    }
    if (msg.routeId) {
      json["routeId"] = msg.routeId;
    }
    if (msg.feePercent) {
      json["feePercent"] = msg.feePercent;
    }
    if (msg.maxLiquidity) {
      json["maxLiquidity"] = msg.maxLiquidity;
    }
    if (msg.swapMethod) {
      json["swapMethod"] = msg.swapMethod;
    }
    if (msg.version) {
      json["version"] = msg.version;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, json: any): Pair {
    const _baseAssetId_ = json["baseAssetId"] ?? json["base_asset_id"];
    if (_baseAssetId_) {
      msg.baseAssetId = _baseAssetId_;
    }
    const _quoteAssetId_ = json["quoteAssetId"] ?? json["quote_asset_id"];
    if (_quoteAssetId_) {
      msg.quoteAssetId = _quoteAssetId_;
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _liquidity_ = json["liquidity"];
    if (_liquidity_) {
      msg.liquidity = _liquidity_;
    }
    const _liquidityAssetId_ =
      json["liquidityAssetId"] ?? json["liquidity_asset_id"];
    if (_liquidityAssetId_) {
      msg.liquidityAssetId = _liquidityAssetId_;
    }
    const _routeId_ = json["routeId"] ?? json["route_id"];
    if (_routeId_) {
      msg.routeId = protoscript.parseNumber(_routeId_);
    }
    const _feePercent_ = json["feePercent"] ?? json["fee_percent"];
    if (_feePercent_) {
      msg.feePercent = _feePercent_;
    }
    const _maxLiquidity_ = json["maxLiquidity"] ?? json["max_liquidity"];
    if (_maxLiquidity_) {
      msg.maxLiquidity = _maxLiquidity_;
    }
    const _swapMethod_ = json["swapMethod"] ?? json["swap_method"];
    if (_swapMethod_) {
      msg.swapMethod = _swapMethod_;
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = protoscript.parseNumber(_version_);
    }
    return msg;
  },
};

export const OutputJSON = {
  /**
   * Serializes Output to JSON.
   */
  encode: function (msg: PartialDeep<Output>): string {
    return JSON.stringify(OutputJSON._writeMessage(msg));
  },

  /**
   * Deserializes Output from JSON.
   */
  decode: function (json: string): Output {
    return OutputJSON._readMessage(OutputJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Output with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Output>): Output {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      assetId: "",
      amount: "",
      sender: "",
      memo: "",
      transactionHash: "",
      outputIndex: 0,
      header: HeaderJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Output>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.sender) {
      json["sender"] = msg.sender;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.transactionHash) {
      json["transactionHash"] = msg.transactionHash;
    }
    if (msg.outputIndex) {
      json["outputIndex"] = msg.outputIndex;
    }
    if (msg.header) {
      const _header_ = HeaderJSON._writeMessage(msg.header);
      if (Object.keys(_header_).length > 0) {
        json["header"] = _header_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Output, json: any): Output {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _sender_ = json["sender"];
    if (_sender_) {
      msg.sender = _sender_;
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _transactionHash_ =
      json["transactionHash"] ?? json["transaction_hash"];
    if (_transactionHash_) {
      msg.transactionHash = _transactionHash_;
    }
    const _outputIndex_ = json["outputIndex"] ?? json["output_index"];
    if (_outputIndex_) {
      msg.outputIndex = protoscript.parseNumber(_outputIndex_);
    }
    const _header_ = json["header"];
    if (_header_) {
      HeaderJSON._readMessage(msg.header, _header_);
    }
    return msg;
  },
};

export const OrderJSON = {
  /**
   * Serializes Order to JSON.
   */
  encode: function (msg: PartialDeep<Order>): string {
    return JSON.stringify(OrderJSON._writeMessage(msg));
  },

  /**
   * Deserializes Order from JSON.
   */
  decode: function (json: string): Order {
    return OrderJSON._readMessage(OrderJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Order>): Order {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      userId: "",
      followId: "",
      payAssetId: "",
      payAmount: "",
      fillAssetId: "",
      fillAmount: "",
      minAmount: "",
      routes: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Order>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.payAssetId) {
      json["payAssetId"] = msg.payAssetId;
    }
    if (msg.payAmount) {
      json["payAmount"] = msg.payAmount;
    }
    if (msg.fillAssetId) {
      json["fillAssetId"] = msg.fillAssetId;
    }
    if (msg.fillAmount) {
      json["fillAmount"] = msg.fillAmount;
    }
    if (msg.minAmount) {
      json["minAmount"] = msg.minAmount;
    }
    if (msg.routes) {
      json["routes"] = msg.routes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, json: any): Order {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    const _payAmount_ = json["payAmount"] ?? json["pay_amount"];
    if (_payAmount_) {
      msg.payAmount = _payAmount_;
    }
    const _fillAssetId_ = json["fillAssetId"] ?? json["fill_asset_id"];
    if (_fillAssetId_) {
      msg.fillAssetId = _fillAssetId_;
    }
    const _fillAmount_ = json["fillAmount"] ?? json["fill_amount"];
    if (_fillAmount_) {
      msg.fillAmount = _fillAmount_;
    }
    const _minAmount_ = json["minAmount"] ?? json["min_amount"];
    if (_minAmount_) {
      msg.minAmount = _minAmount_;
    }
    const _routes_ = json["routes"];
    if (_routes_) {
      msg.routes = _routes_;
    }
    return msg;
  },
};

export const DepositJSON = {
  /**
   * Serializes Deposit to JSON.
   */
  encode: function (msg: PartialDeep<Deposit>): string {
    return JSON.stringify(DepositJSON._writeMessage(msg));
  },

  /**
   * Deserializes Deposit from JSON.
   */
  decode: function (json: string): Deposit {
    return DepositJSON._readMessage(DepositJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Deposit>): Deposit {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      expiredAt: protoscript.TimestampJSON.initialize(),
      userId: "",
      followId: "",
      status: Deposit.Status._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      slippage: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Deposit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.expiredAt && msg.expiredAt.seconds && msg.expiredAt.nanos) {
      json["expiredAt"] = protoscript.serializeTimestamp(msg.expiredAt);
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.status && DepositJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.baseAssetId) {
      json["baseAssetId"] = msg.baseAssetId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAssetId) {
      json["quoteAssetId"] = msg.quoteAssetId;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.slippage) {
      json["slippage"] = msg.slippage;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deposit, json: any): Deposit {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _expiredAt_ = json["expiredAt"] ?? json["expired_at"];
    if (_expiredAt_) {
      msg.expiredAt = protoscript.parseTimestamp(_expiredAt_);
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Deposit.Status._fromInt(_status_);
    }
    const _baseAssetId_ = json["baseAssetId"] ?? json["base_asset_id"];
    if (_baseAssetId_) {
      msg.baseAssetId = _baseAssetId_;
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAssetId_ = json["quoteAssetId"] ?? json["quote_asset_id"];
    if (_quoteAssetId_) {
      msg.quoteAssetId = _quoteAssetId_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _slippage_ = json["slippage"];
    if (_slippage_) {
      msg.slippage = _slippage_;
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: PartialDeep<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      feeAssetId: "",
      feeAmount: "",
      liquidityAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.baseAssetId) {
      json["baseAssetId"] = msg.baseAssetId;
    }
    if (msg.baseAmount) {
      json["baseAmount"] = msg.baseAmount;
    }
    if (msg.quoteAssetId) {
      json["quoteAssetId"] = msg.quoteAssetId;
    }
    if (msg.quoteAmount) {
      json["quoteAmount"] = msg.quoteAmount;
    }
    if (msg.feeAssetId) {
      json["feeAssetId"] = msg.feeAssetId;
    }
    if (msg.feeAmount) {
      json["feeAmount"] = msg.feeAmount;
    }
    if (msg.liquidityAmount) {
      json["liquidityAmount"] = msg.liquidityAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _baseAssetId_ = json["baseAssetId"] ?? json["base_asset_id"];
    if (_baseAssetId_) {
      msg.baseAssetId = _baseAssetId_;
    }
    const _baseAmount_ = json["baseAmount"] ?? json["base_amount"];
    if (_baseAmount_) {
      msg.baseAmount = _baseAmount_;
    }
    const _quoteAssetId_ = json["quoteAssetId"] ?? json["quote_asset_id"];
    if (_quoteAssetId_) {
      msg.quoteAssetId = _quoteAssetId_;
    }
    const _quoteAmount_ = json["quoteAmount"] ?? json["quote_amount"];
    if (_quoteAmount_) {
      msg.quoteAmount = _quoteAmount_;
    }
    const _feeAssetId_ = json["feeAssetId"] ?? json["fee_asset_id"];
    if (_feeAssetId_) {
      msg.feeAssetId = _feeAssetId_;
    }
    const _feeAmount_ = json["feeAmount"] ?? json["fee_amount"];
    if (_feeAmount_) {
      msg.feeAmount = _feeAmount_;
    }
    const _liquidityAmount_ =
      json["liquidityAmount"] ?? json["liquidity_amount"];
    if (_liquidityAmount_) {
      msg.liquidityAmount = _liquidityAmount_;
    }
    return msg;
  },
};

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: PartialDeep<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      signedTx: "",
      status: Transfer.Status._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.opponents?.length) {
      json["opponents"] = msg.opponents;
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.signedTx) {
      json["signedTx"] = msg.signedTx;
    }
    if (msg.status && TransferJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _opponents_ = json["opponents"];
    if (_opponents_) {
      msg.opponents = _opponents_;
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _signedTx_ = json["signedTx"] ?? json["signed_tx"];
    if (_signedTx_) {
      msg.signedTx = _signedTx_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Transfer.Status._fromInt(_status_);
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "ASSIGNED";
        }
        case 2: {
          return "HANDLED";
        }
        case 3: {
          return "PASSED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "ASSIGNED": {
          return 1;
        }
        case "HANDLED": {
          return 2;
        }
        case "PASSED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const AuditJSON = {
  /**
   * Serializes Audit to JSON.
   */
  encode: function (msg: PartialDeep<Audit>): string {
    return JSON.stringify(AuditJSON._writeMessage(msg));
  },

  /**
   * Deserializes Audit from JSON.
   */
  decode: function (json: string): Audit {
    return AuditJSON._readMessage(AuditJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Audit>): Audit {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Audit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.status && AuditJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.reviewedBy) {
      json["reviewedBy"] = msg.reviewedBy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, json: any): Audit {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Audit.Status._fromInt(_status_);
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _reviewedBy_ = json["reviewedBy"] ?? json["reviewed_by"];
    if (_reviewedBy_) {
      msg.reviewedBy = _reviewedBy_;
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    REJECTED: "REJECTED",
    APPROVED: "APPROVED",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "REJECTED";
        }
        case 2: {
          return "APPROVED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "REJECTED": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
