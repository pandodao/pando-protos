// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: swapnode/v1/core.proto
/* eslint-disable */

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

import { Timestamp, TimestampJSON } from "../../google/protobuf/timestamp.pb";

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "NOT_SET"
  | "ADD"
  | "REMOVE"
  | "SWAP"
  | "EXPIRE_DEPOSIT"
  | "AUDIT";

export interface Pair {
  baseAssetId: string;
  quoteAssetId: string;
  baseAmount: string;
  quoteAmount: string;
  liquidity: string;
  liquidityAssetId: string;
  routeId: number;
  feePercent: string;
  maxLiquidity: string;
  swapMethod: string;
  version: number;
}

export interface Output {
  id: string;
  createdAt: Timestamp;
  assetId: string;
  amount: string;
  sender: string;
  memo: string;
}

export interface Order {
  id: string;
  createdAt: Timestamp;
  userId: string;
  followId: string;
  payAssetId: string;
  payAmount: string;
  fillAssetId: string;
  fillAmount: string;
  minAmount: string;
  routes: string;
}

export interface Deposit {
  id: string;
  createdAt: Timestamp;
  expiredAt: Timestamp;
  userId: string;
  followId: string;
  status: Deposit.Status;
  baseAssetId: string;
  baseAmount: string;
  quoteAssetId: string;
  quoteAmount: string;
  slippage: string;
}

export declare namespace Deposit {
  export type Status = "NOT_SET" | "PENDING" | "CANCELLED" | "DONE";
}

export interface Transaction {
  id: string;
  createdAt: Timestamp;
  userId: string;
  followId: string;
  action: Action;
  baseAssetId: string;
  baseAmount: string;
  quoteAssetId: string;
  quoteAmount: string;
  feeAssetId: string;
  feeAmount: string;
  liquidityAmount: string;
}

export interface Transfer {
  id: string;
  createdAt: Timestamp;
  assetId: string;
  amount: string;
  opponents: string[];
  threshold: number;
  memo: string;
  signedTx: string;
}

export interface Audit {
  id: string;
  createdAt: Timestamp;
  assetId: string;
  amount: string;
  userId: string;
  status: Audit.Status;
  memo: string;
  reviewedBy: string;
}

export declare namespace Audit {
  export type Status = "PENDING_NOT_SET" | "REJECTED" | "APPROVED";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  NOT_SET: "NOT_SET",
  ADD: "ADD",
  REMOVE: "REMOVE",
  SWAP: "SWAP",
  EXPIRE_DEPOSIT: "EXPIRE_DEPOSIT",
  AUDIT: "AUDIT",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "NOT_SET";
      }
      case 1: {
        return "ADD";
      }
      case 2: {
        return "REMOVE";
      }
      case 3: {
        return "SWAP";
      }
      case 4: {
        return "EXPIRE_DEPOSIT";
      }
      case 5: {
        return "AUDIT";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "NOT_SET": {
        return 0;
      }
      case "ADD": {
        return 1;
      }
      case "REMOVE": {
        return 2;
      }
      case "SWAP": {
        return 3;
      }
      case "EXPIRE_DEPOSIT": {
        return 4;
      }
      case "AUDIT": {
        return 5;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Pair = {
  /**
   * Serializes Pair to protobuf.
   */
  encode: function (msg: Partial<Pair>): Uint8Array {
    return Pair._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Pair from protobuf.
   */
  decode: function (bytes: ByteSource): Pair {
    return Pair._readMessage(Pair.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (): Pair {
    return {
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      liquidity: "",
      liquidityAssetId: "",
      routeId: 0,
      feePercent: "",
      maxLiquidity: "",
      swapMethod: "",
      version: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Pair>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.baseAssetId) {
      writer.writeString(1, msg.baseAssetId);
    }
    if (msg.quoteAssetId) {
      writer.writeString(2, msg.quoteAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(3, msg.baseAmount);
    }
    if (msg.quoteAmount) {
      writer.writeString(4, msg.quoteAmount);
    }
    if (msg.liquidity) {
      writer.writeString(5, msg.liquidity);
    }
    if (msg.liquidityAssetId) {
      writer.writeString(6, msg.liquidityAssetId);
    }
    if (msg.routeId) {
      writer.writeInt32(7, msg.routeId);
    }
    if (msg.feePercent) {
      writer.writeString(8, msg.feePercent);
    }
    if (msg.maxLiquidity) {
      writer.writeString(9, msg.maxLiquidity);
    }
    if (msg.swapMethod) {
      writer.writeString(10, msg.swapMethod);
    }
    if (msg.version) {
      writer.writeInt32(11, msg.version);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, reader: BinaryReader): Pair {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 2: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 3: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 4: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 5: {
          msg.liquidity = reader.readString();
          break;
        }
        case 6: {
          msg.liquidityAssetId = reader.readString();
          break;
        }
        case 7: {
          msg.routeId = reader.readInt32();
          break;
        }
        case 8: {
          msg.feePercent = reader.readString();
          break;
        }
        case 9: {
          msg.maxLiquidity = reader.readString();
          break;
        }
        case 10: {
          msg.swapMethod = reader.readString();
          break;
        }
        case 11: {
          msg.version = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Output = {
  /**
   * Serializes Output to protobuf.
   */
  encode: function (msg: Partial<Output>): Uint8Array {
    return Output._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Output from protobuf.
   */
  decode: function (bytes: ByteSource): Output {
    return Output._readMessage(Output.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Output with all fields set to their default value.
   */
  initialize: function (): Output {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      sender: "",
      memo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Output>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.sender) {
      writer.writeString(5, msg.sender);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Output, reader: BinaryReader): Output {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.sender = reader.readString();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Order = {
  /**
   * Serializes Order to protobuf.
   */
  encode: function (msg: Partial<Order>): Uint8Array {
    return Order._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Order from protobuf.
   */
  decode: function (bytes: ByteSource): Order {
    return Order._readMessage(Order.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (): Order {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      payAssetId: "",
      payAmount: "",
      fillAssetId: "",
      fillAmount: "",
      minAmount: "",
      routes: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Order>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.userId) {
      writer.writeString(3, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(4, msg.followId);
    }
    if (msg.payAssetId) {
      writer.writeString(5, msg.payAssetId);
    }
    if (msg.payAmount) {
      writer.writeString(6, msg.payAmount);
    }
    if (msg.fillAssetId) {
      writer.writeString(7, msg.fillAssetId);
    }
    if (msg.fillAmount) {
      writer.writeString(8, msg.fillAmount);
    }
    if (msg.minAmount) {
      writer.writeString(9, msg.minAmount);
    }
    if (msg.routes) {
      writer.writeString(10, msg.routes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, reader: BinaryReader): Order {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.userId = reader.readString();
          break;
        }
        case 4: {
          msg.followId = reader.readString();
          break;
        }
        case 5: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 6: {
          msg.payAmount = reader.readString();
          break;
        }
        case 7: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 8: {
          msg.fillAmount = reader.readString();
          break;
        }
        case 9: {
          msg.minAmount = reader.readString();
          break;
        }
        case 10: {
          msg.routes = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Deposit = {
  /**
   * Serializes Deposit to protobuf.
   */
  encode: function (msg: Partial<Deposit>): Uint8Array {
    return Deposit._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Deposit from protobuf.
   */
  decode: function (bytes: ByteSource): Deposit {
    return Deposit._readMessage(Deposit.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (): Deposit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      expiredAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      status: Deposit.Status._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      slippage: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Deposit>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.expiredAt) {
      writer.writeMessage(3, msg.expiredAt, Timestamp._writeMessage);
    }
    if (msg.userId) {
      writer.writeString(4, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(5, msg.followId);
    }
    if (msg.status && Deposit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Deposit.Status._toInt(msg.status));
    }
    if (msg.baseAssetId) {
      writer.writeString(7, msg.baseAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(8, msg.baseAmount);
    }
    if (msg.quoteAssetId) {
      writer.writeString(9, msg.quoteAssetId);
    }
    if (msg.quoteAmount) {
      writer.writeString(10, msg.quoteAmount);
    }
    if (msg.slippage) {
      writer.writeString(11, msg.slippage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deposit, reader: BinaryReader): Deposit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.expiredAt, Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.userId = reader.readString();
          break;
        }
        case 5: {
          msg.followId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Deposit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 8: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 9: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 10: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 11: {
          msg.slippage = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: Partial<Transaction>): Uint8Array {
    return Transaction._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (): Transaction {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      feeAssetId: "",
      feeAmount: "",
      liquidityAmount: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Transaction>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.userId) {
      writer.writeString(3, msg.userId);
    }
    if (msg.followId) {
      writer.writeString(4, msg.followId);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(5, Action._toInt(msg.action));
    }
    if (msg.baseAssetId) {
      writer.writeString(6, msg.baseAssetId);
    }
    if (msg.baseAmount) {
      writer.writeString(7, msg.baseAmount);
    }
    if (msg.quoteAssetId) {
      writer.writeString(8, msg.quoteAssetId);
    }
    if (msg.quoteAmount) {
      writer.writeString(9, msg.quoteAmount);
    }
    if (msg.feeAssetId) {
      writer.writeString(10, msg.feeAssetId);
    }
    if (msg.feeAmount) {
      writer.writeString(11, msg.feeAmount);
    }
    if (msg.liquidityAmount) {
      writer.writeString(12, msg.liquidityAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, reader: BinaryReader): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.userId = reader.readString();
          break;
        }
        case 4: {
          msg.followId = reader.readString();
          break;
        }
        case 5: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.baseAssetId = reader.readString();
          break;
        }
        case 7: {
          msg.baseAmount = reader.readString();
          break;
        }
        case 8: {
          msg.quoteAssetId = reader.readString();
          break;
        }
        case 9: {
          msg.quoteAmount = reader.readString();
          break;
        }
        case 10: {
          msg.feeAssetId = reader.readString();
          break;
        }
        case 11: {
          msg.feeAmount = reader.readString();
          break;
        }
        case 12: {
          msg.liquidityAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: Partial<Transfer>): Uint8Array {
    return Transfer._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      signedTx: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Transfer>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(5, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeInt32(6, msg.threshold);
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.signedTx) {
      writer.writeString(8, msg.signedTx);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, reader: BinaryReader): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 6: {
          msg.threshold = reader.readInt32();
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.signedTx = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Audit = {
  /**
   * Serializes Audit to protobuf.
   */
  encode: function (msg: Partial<Audit>): Uint8Array {
    return Audit._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Audit from protobuf.
   */
  decode: function (bytes: ByteSource): Audit {
    return Audit._readMessage(Audit.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (): Audit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Audit>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.userId) {
      writer.writeString(5, msg.userId);
    }
    if (msg.status && Audit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Audit.Status._toInt(msg.status));
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.reviewedBy) {
      writer.writeString(8, msg.reviewedBy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, reader: BinaryReader): Audit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.userId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Audit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.reviewedBy = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    REJECTED: "REJECTED",
    APPROVED: "APPROVED",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "REJECTED";
        }
        case 2: {
          return "APPROVED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "REJECTED": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  NOT_SET: "NOT_SET",
  ADD: "ADD",
  REMOVE: "REMOVE",
  SWAP: "SWAP",
  EXPIRE_DEPOSIT: "EXPIRE_DEPOSIT",
  AUDIT: "AUDIT",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "NOT_SET";
      }
      case 1: {
        return "ADD";
      }
      case 2: {
        return "REMOVE";
      }
      case 3: {
        return "SWAP";
      }
      case 4: {
        return "EXPIRE_DEPOSIT";
      }
      case 5: {
        return "AUDIT";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "NOT_SET": {
        return 0;
      }
      case "ADD": {
        return 1;
      }
      case "REMOVE": {
        return 2;
      }
      case "SWAP": {
        return 3;
      }
      case "EXPIRE_DEPOSIT": {
        return 4;
      }
      case "AUDIT": {
        return 5;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PairJSON = {
  /**
   * Serializes Pair to JSON.
   */
  encode: function (msg: Partial<Pair>): string {
    return JSON.stringify(PairJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pair from JSON.
   */
  decode: function (json: string): Pair {
    return PairJSON._readMessage(PairJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Pair with all fields set to their default value.
   */
  initialize: function (): Pair {
    return {
      baseAssetId: "",
      quoteAssetId: "",
      baseAmount: "",
      quoteAmount: "",
      liquidity: "",
      liquidityAssetId: "",
      routeId: 0,
      feePercent: "",
      maxLiquidity: "",
      swapMethod: "",
      version: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Pair>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.baseAssetId) {
      json.baseAssetId = msg.baseAssetId;
    }
    if (msg.quoteAssetId) {
      json.quoteAssetId = msg.quoteAssetId;
    }
    if (msg.baseAmount) {
      json.baseAmount = msg.baseAmount;
    }
    if (msg.quoteAmount) {
      json.quoteAmount = msg.quoteAmount;
    }
    if (msg.liquidity) {
      json.liquidity = msg.liquidity;
    }
    if (msg.liquidityAssetId) {
      json.liquidityAssetId = msg.liquidityAssetId;
    }
    if (msg.routeId) {
      json.routeId = msg.routeId;
    }
    if (msg.feePercent) {
      json.feePercent = msg.feePercent;
    }
    if (msg.maxLiquidity) {
      json.maxLiquidity = msg.maxLiquidity;
    }
    if (msg.swapMethod) {
      json.swapMethod = msg.swapMethod;
    }
    if (msg.version) {
      json.version = msg.version;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pair, json: any): Pair {
    const _baseAssetId = json.baseAssetId ?? json.base_asset_id;
    if (_baseAssetId) {
      msg.baseAssetId = _baseAssetId;
    }
    const _quoteAssetId = json.quoteAssetId ?? json.quote_asset_id;
    if (_quoteAssetId) {
      msg.quoteAssetId = _quoteAssetId;
    }
    const _baseAmount = json.baseAmount ?? json.base_amount;
    if (_baseAmount) {
      msg.baseAmount = _baseAmount;
    }
    const _quoteAmount = json.quoteAmount ?? json.quote_amount;
    if (_quoteAmount) {
      msg.quoteAmount = _quoteAmount;
    }
    const _liquidity = json.liquidity;
    if (_liquidity) {
      msg.liquidity = _liquidity;
    }
    const _liquidityAssetId = json.liquidityAssetId ?? json.liquidity_asset_id;
    if (_liquidityAssetId) {
      msg.liquidityAssetId = _liquidityAssetId;
    }
    const _routeId = json.routeId ?? json.route_id;
    if (_routeId) {
      msg.routeId = _routeId;
    }
    const _feePercent = json.feePercent ?? json.fee_percent;
    if (_feePercent) {
      msg.feePercent = _feePercent;
    }
    const _maxLiquidity = json.maxLiquidity ?? json.max_liquidity;
    if (_maxLiquidity) {
      msg.maxLiquidity = _maxLiquidity;
    }
    const _swapMethod = json.swapMethod ?? json.swap_method;
    if (_swapMethod) {
      msg.swapMethod = _swapMethod;
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    return msg;
  },
};

export const OutputJSON = {
  /**
   * Serializes Output to JSON.
   */
  encode: function (msg: Partial<Output>): string {
    return JSON.stringify(OutputJSON._writeMessage(msg));
  },

  /**
   * Deserializes Output from JSON.
   */
  decode: function (json: string): Output {
    return OutputJSON._readMessage(OutputJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Output with all fields set to their default value.
   */
  initialize: function (): Output {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      sender: "",
      memo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Output>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.sender) {
      json.sender = msg.sender;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Output, json: any): Output {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _sender = json.sender;
    if (_sender) {
      msg.sender = _sender;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    return msg;
  },
};

export const OrderJSON = {
  /**
   * Serializes Order to JSON.
   */
  encode: function (msg: Partial<Order>): string {
    return JSON.stringify(OrderJSON._writeMessage(msg));
  },

  /**
   * Deserializes Order from JSON.
   */
  decode: function (json: string): Order {
    return OrderJSON._readMessage(OrderJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (): Order {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      payAssetId: "",
      payAmount: "",
      fillAssetId: "",
      fillAmount: "",
      minAmount: "",
      routes: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Order>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.followId) {
      json.followId = msg.followId;
    }
    if (msg.payAssetId) {
      json.payAssetId = msg.payAssetId;
    }
    if (msg.payAmount) {
      json.payAmount = msg.payAmount;
    }
    if (msg.fillAssetId) {
      json.fillAssetId = msg.fillAssetId;
    }
    if (msg.fillAmount) {
      json.fillAmount = msg.fillAmount;
    }
    if (msg.minAmount) {
      json.minAmount = msg.minAmount;
    }
    if (msg.routes) {
      json.routes = msg.routes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, json: any): Order {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _followId = json.followId ?? json.follow_id;
    if (_followId) {
      msg.followId = _followId;
    }
    const _payAssetId = json.payAssetId ?? json.pay_asset_id;
    if (_payAssetId) {
      msg.payAssetId = _payAssetId;
    }
    const _payAmount = json.payAmount ?? json.pay_amount;
    if (_payAmount) {
      msg.payAmount = _payAmount;
    }
    const _fillAssetId = json.fillAssetId ?? json.fill_asset_id;
    if (_fillAssetId) {
      msg.fillAssetId = _fillAssetId;
    }
    const _fillAmount = json.fillAmount ?? json.fill_amount;
    if (_fillAmount) {
      msg.fillAmount = _fillAmount;
    }
    const _minAmount = json.minAmount ?? json.min_amount;
    if (_minAmount) {
      msg.minAmount = _minAmount;
    }
    const _routes = json.routes;
    if (_routes) {
      msg.routes = _routes;
    }
    return msg;
  },
};

export const DepositJSON = {
  /**
   * Serializes Deposit to JSON.
   */
  encode: function (msg: Partial<Deposit>): string {
    return JSON.stringify(DepositJSON._writeMessage(msg));
  },

  /**
   * Deserializes Deposit from JSON.
   */
  decode: function (json: string): Deposit {
    return DepositJSON._readMessage(DepositJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Deposit with all fields set to their default value.
   */
  initialize: function (): Deposit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      expiredAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      status: Deposit.Status._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      slippage: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Deposit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.expiredAt) {
      const expiredAt = TimestampJSON._writeMessage(msg.expiredAt);
      if (Object.keys(expiredAt).length > 0) {
        json.expiredAt = expiredAt;
      }
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.followId) {
      json.followId = msg.followId;
    }
    if (msg.status && DepositJSON.Status._toInt(msg.status)) {
      json.status = msg.status;
    }
    if (msg.baseAssetId) {
      json.baseAssetId = msg.baseAssetId;
    }
    if (msg.baseAmount) {
      json.baseAmount = msg.baseAmount;
    }
    if (msg.quoteAssetId) {
      json.quoteAssetId = msg.quoteAssetId;
    }
    if (msg.quoteAmount) {
      json.quoteAmount = msg.quoteAmount;
    }
    if (msg.slippage) {
      json.slippage = msg.slippage;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Deposit, json: any): Deposit {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _expiredAt = json.expiredAt ?? json.expired_at;
    if (_expiredAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _expiredAt);
      msg.expiredAt = m;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _followId = json.followId ?? json.follow_id;
    if (_followId) {
      msg.followId = _followId;
    }
    const _status = json.status;
    if (_status) {
      msg.status = _status;
    }
    const _baseAssetId = json.baseAssetId ?? json.base_asset_id;
    if (_baseAssetId) {
      msg.baseAssetId = _baseAssetId;
    }
    const _baseAmount = json.baseAmount ?? json.base_amount;
    if (_baseAmount) {
      msg.baseAmount = _baseAmount;
    }
    const _quoteAssetId = json.quoteAssetId ?? json.quote_asset_id;
    if (_quoteAssetId) {
      msg.quoteAssetId = _quoteAssetId;
    }
    const _quoteAmount = json.quoteAmount ?? json.quote_amount;
    if (_quoteAmount) {
      msg.quoteAmount = _quoteAmount;
    }
    const _slippage = json.slippage;
    if (_slippage) {
      msg.slippage = _slippage;
    }
    return msg;
  },

  Status: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Deposit.Status {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Deposit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Deposit.Status): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: Partial<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (): Transaction {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      userId: "",
      followId: "",
      action: Action._fromInt(0),
      baseAssetId: "",
      baseAmount: "",
      quoteAssetId: "",
      quoteAmount: "",
      feeAssetId: "",
      feeAmount: "",
      liquidityAmount: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Transaction>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.followId) {
      json.followId = msg.followId;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json.action = msg.action;
    }
    if (msg.baseAssetId) {
      json.baseAssetId = msg.baseAssetId;
    }
    if (msg.baseAmount) {
      json.baseAmount = msg.baseAmount;
    }
    if (msg.quoteAssetId) {
      json.quoteAssetId = msg.quoteAssetId;
    }
    if (msg.quoteAmount) {
      json.quoteAmount = msg.quoteAmount;
    }
    if (msg.feeAssetId) {
      json.feeAssetId = msg.feeAssetId;
    }
    if (msg.feeAmount) {
      json.feeAmount = msg.feeAmount;
    }
    if (msg.liquidityAmount) {
      json.liquidityAmount = msg.liquidityAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _followId = json.followId ?? json.follow_id;
    if (_followId) {
      msg.followId = _followId;
    }
    const _action = json.action;
    if (_action) {
      msg.action = _action;
    }
    const _baseAssetId = json.baseAssetId ?? json.base_asset_id;
    if (_baseAssetId) {
      msg.baseAssetId = _baseAssetId;
    }
    const _baseAmount = json.baseAmount ?? json.base_amount;
    if (_baseAmount) {
      msg.baseAmount = _baseAmount;
    }
    const _quoteAssetId = json.quoteAssetId ?? json.quote_asset_id;
    if (_quoteAssetId) {
      msg.quoteAssetId = _quoteAssetId;
    }
    const _quoteAmount = json.quoteAmount ?? json.quote_amount;
    if (_quoteAmount) {
      msg.quoteAmount = _quoteAmount;
    }
    const _feeAssetId = json.feeAssetId ?? json.fee_asset_id;
    if (_feeAssetId) {
      msg.feeAssetId = _feeAssetId;
    }
    const _feeAmount = json.feeAmount ?? json.fee_amount;
    if (_feeAmount) {
      msg.feeAmount = _feeAmount;
    }
    const _liquidityAmount = json.liquidityAmount ?? json.liquidity_amount;
    if (_liquidityAmount) {
      msg.liquidityAmount = _liquidityAmount;
    }
    return msg;
  },
};

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: Partial<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      opponents: [],
      threshold: 0,
      memo: "",
      signedTx: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Transfer>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.opponents?.length) {
      json.opponents = msg.opponents;
    }
    if (msg.threshold) {
      json.threshold = msg.threshold;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    if (msg.signedTx) {
      json.signedTx = msg.signedTx;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _opponents = json.opponents;
    if (_opponents) {
      msg.opponents = _opponents;
    }
    const _threshold = json.threshold;
    if (_threshold) {
      msg.threshold = _threshold;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    const _signedTx = json.signedTx ?? json.signed_tx;
    if (_signedTx) {
      msg.signedTx = _signedTx;
    }
    return msg;
  },
};

export const AuditJSON = {
  /**
   * Serializes Audit to JSON.
   */
  encode: function (msg: Partial<Audit>): string {
    return JSON.stringify(AuditJSON._writeMessage(msg));
  },

  /**
   * Deserializes Audit from JSON.
   */
  decode: function (json: string): Audit {
    return AuditJSON._readMessage(AuditJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (): Audit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Audit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.status && AuditJSON.Status._toInt(msg.status)) {
      json.status = msg.status;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    if (msg.reviewedBy) {
      json.reviewedBy = msg.reviewedBy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, json: any): Audit {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _status = json.status;
    if (_status) {
      msg.status = _status;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    const _reviewedBy = json.reviewedBy ?? json.reviewed_by;
    if (_reviewedBy) {
      msg.reviewedBy = _reviewedBy;
    }
    return msg;
  },

  Status: {
    PENDING_NOT_SET: "PENDING_NOT_SET",
    REJECTED: "REJECTED",
    APPROVED: "APPROVED",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "PENDING_NOT_SET";
        }
        case 1: {
          return "REJECTED";
        }
        case 2: {
          return "APPROVED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "PENDING_NOT_SET": {
          return 0;
        }
        case "REJECTED": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
