// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: hfox/v1/hfox.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export interface Range {
  minAmount: string;
  maxAmount: string;
}

export interface Asset {
  id: string;
  symbol: string;
  name: string;
  logo: string;
  chainId: string;
  chain: Asset | null | undefined;
  hash: string;
  priceUsd: string;
  range: Range;
}

export interface Quota {
  assetId: string;
  amount: string;
}

export interface Gem {
  assetId: string;
  quota: string;
  paid: string;
  filled: string;
}

export interface User {
  id: string;
  number: string;
  name: string;
  avatar: string;
}

export interface Plan {
  id: string;
  createdAt: string;
  updatedAt: string;
  status: Plan.Status;
  tickedAt: string;
  nextTickAt: string;
  tickNumber: number;
  name: string;
  userId: string;
  period: string;
  payAssetId: string;
  payAmount: string;
  gems: Gem[];
  quotas: Quota[];
  visibility: Plan.Visibility;
  user: User;
}

export declare namespace Plan {
  export type Status = "STATUS_NOT_SET" | "RUNNING" | "STOPPED" | "DELETED";

  export type Visibility =
    | "VISIBILITY_NOT_SET"
    | "PRIVATE"
    | "PUBLIC"
    | "ANONYMOUS";
}

export interface Tick {
  id: string;
  createdAt: string;
  updatedAt: string;
  expiredAt: string;
  type: Tick.Type;
  status: Tick.Status;
  planId: string;
  number: number;
  payAssetId: string;
  payAmount: string;
  gems: Gem[];
}

export declare namespace Tick {
  export type Type = "TYPE_NOT_SET" | "SCHEDULE" | "MANUAL";

  export type Status =
    | "STATUS_NOT_SET"
    | "PENDING"
    | "EXPIRED"
    | "CANCELLED"
    | "PAID"
    | "FILLED"
    | "SETTLED";
}

export interface Payment {
  traceId: string;
  opponents: string[];
  threshold: number;
  assetId: string;
  amount: string;
  memo: string;
}

export interface CreatePlanRequest {
  name: string;
  payAssetId: string;
  period: string;
  quotas: Quota[];
  visibility: Plan.Visibility;
}

export interface CreatePlanResponse {
  plan: Plan;
}

export interface UpdatePlanRequest {
  id: string;
  name?: string | null | undefined;
  period?: string | null | undefined;
  quotas: Quota[];
  status?: Plan.Status | null | undefined;
  visibility?: Plan.Visibility | null | undefined;
  payAssetId?: string | null | undefined;
}

export interface UpdatePlanResponse {
  plan: Plan;
}

export interface ListPlansRequest {}

export interface ListPlansResponse {
  plans: Plan[];
}

export interface CreateTickRequest {
  planId: string;
  quotas: Quota[];
}

export interface CreateTickResponse {
  plan: Plan;
  tick: Tick;
  payment: Payment;
}

export interface FindTickRequest {
  tickId: string;
}

export interface FindTickResponse {
  plan: Plan;
  tick: Tick;
  payment: Payment;
}

export interface CancelTickRequest {
  tickId: string;
}

export interface CancelTickResponse {
  plan: Plan;
  tick: Tick;
}

export interface ListBalancesRequest {}

export interface Balance {
  assetId: string;
  amount: string;
}

export interface ListBalancesResponse {
  balances: Balance[];
}

export interface Point {
  date: string;
  ts: string;
  paidValue: string;
  filledValue: string;
  price: string;
}

export interface ListStatsRequest {
  planId: string;
}

export interface ListStatsResponse {
  points: Point[];
}

export interface GetInfoRequest {}

export interface GetInfoResponse {
  clientId: string;
  payAssetIds: string[];
  fillAssetIds: string[];
  payAssets: Asset[];
  fillAssets: Asset[];
}

export interface RefreshStatRequest {
  planId: string;
}

export interface RefreshStatResponse {}

export interface CreateMultisigRequest {
  payment: Payment;
}

export interface CreateMultisigResponse {
  requestId: string;
  txHash: string;
  assetId: string;
  assetHash: string;
  amount: string;
  extra: string;
  rawTx: string;
  senders: string[];
  signers: string[];
}

export interface ListTicksRequest {
  planId: string;
  offset: string;
  limit: number;
}

export interface ListTicksResponse {
  ticks: Tick[];
  nextOffset: string;
  hasNext: boolean;
}

export interface ReadRankingListRequest {
  id: string;
  page: number;
  count: number;
}

export interface PlanStat {
  plan: Plan;
  paidValue: string;
  filledValue: string;
  rate: string;
  extra: string;
}

export interface ReadRankingListResponse {
  id: string;
  name: string;
  updatedAt: string;
  updatedTs: string;
  plans: PlanStat[];
}

export interface CopyPlanRequest {
  planId: string;
}

export interface CopyPlanResponse {
  plan: Plan;
}

export interface FindPlanRequest {
  planId: string;
}

export interface FindPlanResponse {
  plan: Plan;
}

//========================================//
//      HfoxService Protobuf Client       //
//========================================//

export async function GetInfo(
  getInfoRequest: GetInfoRequest,
  config?: ClientConfiguration,
): Promise<GetInfoResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/GetInfo",
    GetInfoRequest.encode(getInfoRequest),
    config,
  );
  return GetInfoResponse.decode(response);
}

export async function CreatePlan(
  createPlanRequest: CreatePlanRequest,
  config?: ClientConfiguration,
): Promise<CreatePlanResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/CreatePlan",
    CreatePlanRequest.encode(createPlanRequest),
    config,
  );
  return CreatePlanResponse.decode(response);
}

export async function UpdatePlan(
  updatePlanRequest: UpdatePlanRequest,
  config?: ClientConfiguration,
): Promise<UpdatePlanResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/UpdatePlan",
    UpdatePlanRequest.encode(updatePlanRequest),
    config,
  );
  return UpdatePlanResponse.decode(response);
}

export async function FindPlan(
  findPlanRequest: FindPlanRequest,
  config?: ClientConfiguration,
): Promise<FindPlanResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/FindPlan",
    FindPlanRequest.encode(findPlanRequest),
    config,
  );
  return FindPlanResponse.decode(response);
}

export async function ListPlans(
  listPlansRequest: ListPlansRequest,
  config?: ClientConfiguration,
): Promise<ListPlansResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/ListPlans",
    ListPlansRequest.encode(listPlansRequest),
    config,
  );
  return ListPlansResponse.decode(response);
}

export async function CreateTick(
  createTickRequest: CreateTickRequest,
  config?: ClientConfiguration,
): Promise<CreateTickResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/CreateTick",
    CreateTickRequest.encode(createTickRequest),
    config,
  );
  return CreateTickResponse.decode(response);
}

export async function FindTick(
  findTickRequest: FindTickRequest,
  config?: ClientConfiguration,
): Promise<FindTickResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/FindTick",
    FindTickRequest.encode(findTickRequest),
    config,
  );
  return FindTickResponse.decode(response);
}

export async function CancelTick(
  cancelTickRequest: CancelTickRequest,
  config?: ClientConfiguration,
): Promise<CancelTickResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/CancelTick",
    CancelTickRequest.encode(cancelTickRequest),
    config,
  );
  return CancelTickResponse.decode(response);
}

export async function ListTicks(
  listTicksRequest: ListTicksRequest,
  config?: ClientConfiguration,
): Promise<ListTicksResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/ListTicks",
    ListTicksRequest.encode(listTicksRequest),
    config,
  );
  return ListTicksResponse.decode(response);
}

export async function ListBalances(
  listBalancesRequest: ListBalancesRequest,
  config?: ClientConfiguration,
): Promise<ListBalancesResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/ListBalances",
    ListBalancesRequest.encode(listBalancesRequest),
    config,
  );
  return ListBalancesResponse.decode(response);
}

export async function ListStats(
  listStatsRequest: ListStatsRequest,
  config?: ClientConfiguration,
): Promise<ListStatsResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/ListStats",
    ListStatsRequest.encode(listStatsRequest),
    config,
  );
  return ListStatsResponse.decode(response);
}

export async function RefreshStat(
  refreshStatRequest: RefreshStatRequest,
  config?: ClientConfiguration,
): Promise<RefreshStatResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/RefreshStat",
    RefreshStatRequest.encode(refreshStatRequest),
    config,
  );
  return RefreshStatResponse.decode(response);
}

export async function CreateMultisig(
  createMultisigRequest: CreateMultisigRequest,
  config?: ClientConfiguration,
): Promise<CreateMultisigResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/CreateMultisig",
    CreateMultisigRequest.encode(createMultisigRequest),
    config,
  );
  return CreateMultisigResponse.decode(response);
}

export async function ReadRankingList(
  readRankingListRequest: ReadRankingListRequest,
  config?: ClientConfiguration,
): Promise<ReadRankingListResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/ReadRankingList",
    ReadRankingListRequest.encode(readRankingListRequest),
    config,
  );
  return ReadRankingListResponse.decode(response);
}

export async function CopyPlan(
  copyPlanRequest: CopyPlanRequest,
  config?: ClientConfiguration,
): Promise<CopyPlanResponse> {
  const response = await PBrequest(
    "/hfox.v1.HfoxService/CopyPlan",
    CopyPlanRequest.encode(copyPlanRequest),
    config,
  );
  return CopyPlanResponse.decode(response);
}

//========================================//
//        HfoxService JSON Client         //
//========================================//

export async function GetInfoJSON(
  getInfoRequest: GetInfoRequest,
  config?: ClientConfiguration,
): Promise<GetInfoResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/GetInfo",
    GetInfoRequestJSON.encode(getInfoRequest),
    config,
  );
  return GetInfoResponseJSON.decode(response);
}

export async function CreatePlanJSON(
  createPlanRequest: CreatePlanRequest,
  config?: ClientConfiguration,
): Promise<CreatePlanResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/CreatePlan",
    CreatePlanRequestJSON.encode(createPlanRequest),
    config,
  );
  return CreatePlanResponseJSON.decode(response);
}

export async function UpdatePlanJSON(
  updatePlanRequest: UpdatePlanRequest,
  config?: ClientConfiguration,
): Promise<UpdatePlanResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/UpdatePlan",
    UpdatePlanRequestJSON.encode(updatePlanRequest),
    config,
  );
  return UpdatePlanResponseJSON.decode(response);
}

export async function FindPlanJSON(
  findPlanRequest: FindPlanRequest,
  config?: ClientConfiguration,
): Promise<FindPlanResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/FindPlan",
    FindPlanRequestJSON.encode(findPlanRequest),
    config,
  );
  return FindPlanResponseJSON.decode(response);
}

export async function ListPlansJSON(
  listPlansRequest: ListPlansRequest,
  config?: ClientConfiguration,
): Promise<ListPlansResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/ListPlans",
    ListPlansRequestJSON.encode(listPlansRequest),
    config,
  );
  return ListPlansResponseJSON.decode(response);
}

export async function CreateTickJSON(
  createTickRequest: CreateTickRequest,
  config?: ClientConfiguration,
): Promise<CreateTickResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/CreateTick",
    CreateTickRequestJSON.encode(createTickRequest),
    config,
  );
  return CreateTickResponseJSON.decode(response);
}

export async function FindTickJSON(
  findTickRequest: FindTickRequest,
  config?: ClientConfiguration,
): Promise<FindTickResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/FindTick",
    FindTickRequestJSON.encode(findTickRequest),
    config,
  );
  return FindTickResponseJSON.decode(response);
}

export async function CancelTickJSON(
  cancelTickRequest: CancelTickRequest,
  config?: ClientConfiguration,
): Promise<CancelTickResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/CancelTick",
    CancelTickRequestJSON.encode(cancelTickRequest),
    config,
  );
  return CancelTickResponseJSON.decode(response);
}

export async function ListTicksJSON(
  listTicksRequest: ListTicksRequest,
  config?: ClientConfiguration,
): Promise<ListTicksResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/ListTicks",
    ListTicksRequestJSON.encode(listTicksRequest),
    config,
  );
  return ListTicksResponseJSON.decode(response);
}

export async function ListBalancesJSON(
  listBalancesRequest: ListBalancesRequest,
  config?: ClientConfiguration,
): Promise<ListBalancesResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/ListBalances",
    ListBalancesRequestJSON.encode(listBalancesRequest),
    config,
  );
  return ListBalancesResponseJSON.decode(response);
}

export async function ListStatsJSON(
  listStatsRequest: ListStatsRequest,
  config?: ClientConfiguration,
): Promise<ListStatsResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/ListStats",
    ListStatsRequestJSON.encode(listStatsRequest),
    config,
  );
  return ListStatsResponseJSON.decode(response);
}

export async function RefreshStatJSON(
  refreshStatRequest: RefreshStatRequest,
  config?: ClientConfiguration,
): Promise<RefreshStatResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/RefreshStat",
    RefreshStatRequestJSON.encode(refreshStatRequest),
    config,
  );
  return RefreshStatResponseJSON.decode(response);
}

export async function CreateMultisigJSON(
  createMultisigRequest: CreateMultisigRequest,
  config?: ClientConfiguration,
): Promise<CreateMultisigResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/CreateMultisig",
    CreateMultisigRequestJSON.encode(createMultisigRequest),
    config,
  );
  return CreateMultisigResponseJSON.decode(response);
}

export async function ReadRankingListJSON(
  readRankingListRequest: ReadRankingListRequest,
  config?: ClientConfiguration,
): Promise<ReadRankingListResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/ReadRankingList",
    ReadRankingListRequestJSON.encode(readRankingListRequest),
    config,
  );
  return ReadRankingListResponseJSON.decode(response);
}

export async function CopyPlanJSON(
  copyPlanRequest: CopyPlanRequest,
  config?: ClientConfiguration,
): Promise<CopyPlanResponse> {
  const response = await JSONrequest(
    "/hfox.v1.HfoxService/CopyPlan",
    CopyPlanRequestJSON.encode(copyPlanRequest),
    config,
  );
  return CopyPlanResponseJSON.decode(response);
}

//========================================//
//              HfoxService               //
//========================================//

export interface HfoxService<Context = unknown> {
  GetInfo: (
    getInfoRequest: GetInfoRequest,
    context: Context,
  ) => Promise<GetInfoResponse> | GetInfoResponse;
  CreatePlan: (
    createPlanRequest: CreatePlanRequest,
    context: Context,
  ) => Promise<CreatePlanResponse> | CreatePlanResponse;
  UpdatePlan: (
    updatePlanRequest: UpdatePlanRequest,
    context: Context,
  ) => Promise<UpdatePlanResponse> | UpdatePlanResponse;
  FindPlan: (
    findPlanRequest: FindPlanRequest,
    context: Context,
  ) => Promise<FindPlanResponse> | FindPlanResponse;
  ListPlans: (
    listPlansRequest: ListPlansRequest,
    context: Context,
  ) => Promise<ListPlansResponse> | ListPlansResponse;
  CreateTick: (
    createTickRequest: CreateTickRequest,
    context: Context,
  ) => Promise<CreateTickResponse> | CreateTickResponse;
  FindTick: (
    findTickRequest: FindTickRequest,
    context: Context,
  ) => Promise<FindTickResponse> | FindTickResponse;
  CancelTick: (
    cancelTickRequest: CancelTickRequest,
    context: Context,
  ) => Promise<CancelTickResponse> | CancelTickResponse;
  ListTicks: (
    listTicksRequest: ListTicksRequest,
    context: Context,
  ) => Promise<ListTicksResponse> | ListTicksResponse;
  ListBalances: (
    listBalancesRequest: ListBalancesRequest,
    context: Context,
  ) => Promise<ListBalancesResponse> | ListBalancesResponse;
  ListStats: (
    listStatsRequest: ListStatsRequest,
    context: Context,
  ) => Promise<ListStatsResponse> | ListStatsResponse;
  RefreshStat: (
    refreshStatRequest: RefreshStatRequest,
    context: Context,
  ) => Promise<RefreshStatResponse> | RefreshStatResponse;
  CreateMultisig: (
    createMultisigRequest: CreateMultisigRequest,
    context: Context,
  ) => Promise<CreateMultisigResponse> | CreateMultisigResponse;
  ReadRankingList: (
    readRankingListRequest: ReadRankingListRequest,
    context: Context,
  ) => Promise<ReadRankingListResponse> | ReadRankingListResponse;
  CopyPlan: (
    copyPlanRequest: CopyPlanRequest,
    context: Context,
  ) => Promise<CopyPlanResponse> | CopyPlanResponse;
}

export function createHfoxService<Context>(service: HfoxService<Context>) {
  return {
    name: "hfox.v1.HfoxService",
    methods: {
      GetInfo: {
        name: "GetInfo",
        handler: service.GetInfo,
        input: { protobuf: GetInfoRequest, json: GetInfoRequestJSON },
        output: { protobuf: GetInfoResponse, json: GetInfoResponseJSON },
      },
      CreatePlan: {
        name: "CreatePlan",
        handler: service.CreatePlan,
        input: { protobuf: CreatePlanRequest, json: CreatePlanRequestJSON },
        output: { protobuf: CreatePlanResponse, json: CreatePlanResponseJSON },
      },
      UpdatePlan: {
        name: "UpdatePlan",
        handler: service.UpdatePlan,
        input: { protobuf: UpdatePlanRequest, json: UpdatePlanRequestJSON },
        output: { protobuf: UpdatePlanResponse, json: UpdatePlanResponseJSON },
      },
      FindPlan: {
        name: "FindPlan",
        handler: service.FindPlan,
        input: { protobuf: FindPlanRequest, json: FindPlanRequestJSON },
        output: { protobuf: FindPlanResponse, json: FindPlanResponseJSON },
      },
      ListPlans: {
        name: "ListPlans",
        handler: service.ListPlans,
        input: { protobuf: ListPlansRequest, json: ListPlansRequestJSON },
        output: { protobuf: ListPlansResponse, json: ListPlansResponseJSON },
      },
      CreateTick: {
        name: "CreateTick",
        handler: service.CreateTick,
        input: { protobuf: CreateTickRequest, json: CreateTickRequestJSON },
        output: { protobuf: CreateTickResponse, json: CreateTickResponseJSON },
      },
      FindTick: {
        name: "FindTick",
        handler: service.FindTick,
        input: { protobuf: FindTickRequest, json: FindTickRequestJSON },
        output: { protobuf: FindTickResponse, json: FindTickResponseJSON },
      },
      CancelTick: {
        name: "CancelTick",
        handler: service.CancelTick,
        input: { protobuf: CancelTickRequest, json: CancelTickRequestJSON },
        output: { protobuf: CancelTickResponse, json: CancelTickResponseJSON },
      },
      ListTicks: {
        name: "ListTicks",
        handler: service.ListTicks,
        input: { protobuf: ListTicksRequest, json: ListTicksRequestJSON },
        output: { protobuf: ListTicksResponse, json: ListTicksResponseJSON },
      },
      ListBalances: {
        name: "ListBalances",
        handler: service.ListBalances,
        input: { protobuf: ListBalancesRequest, json: ListBalancesRequestJSON },
        output: {
          protobuf: ListBalancesResponse,
          json: ListBalancesResponseJSON,
        },
      },
      ListStats: {
        name: "ListStats",
        handler: service.ListStats,
        input: { protobuf: ListStatsRequest, json: ListStatsRequestJSON },
        output: { protobuf: ListStatsResponse, json: ListStatsResponseJSON },
      },
      RefreshStat: {
        name: "RefreshStat",
        handler: service.RefreshStat,
        input: { protobuf: RefreshStatRequest, json: RefreshStatRequestJSON },
        output: {
          protobuf: RefreshStatResponse,
          json: RefreshStatResponseJSON,
        },
      },
      CreateMultisig: {
        name: "CreateMultisig",
        handler: service.CreateMultisig,
        input: {
          protobuf: CreateMultisigRequest,
          json: CreateMultisigRequestJSON,
        },
        output: {
          protobuf: CreateMultisigResponse,
          json: CreateMultisigResponseJSON,
        },
      },
      ReadRankingList: {
        name: "ReadRankingList",
        handler: service.ReadRankingList,
        input: {
          protobuf: ReadRankingListRequest,
          json: ReadRankingListRequestJSON,
        },
        output: {
          protobuf: ReadRankingListResponse,
          json: ReadRankingListResponseJSON,
        },
      },
      CopyPlan: {
        name: "CopyPlan",
        handler: service.CopyPlan,
        input: { protobuf: CopyPlanRequest, json: CopyPlanRequestJSON },
        output: { protobuf: CopyPlanResponse, json: CopyPlanResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Range = {
  /**
   * Serializes Range to protobuf.
   */
  encode: function (msg: PartialDeep<Range>): Uint8Array {
    return Range._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Range from protobuf.
   */
  decode: function (bytes: ByteSource): Range {
    return Range._readMessage(
      Range.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Range with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Range>): Range {
    return {
      minAmount: "",
      maxAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Range>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.minAmount) {
      writer.writeString(1, msg.minAmount);
    }
    if (msg.maxAmount) {
      writer.writeString(2, msg.maxAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Range, reader: protoscript.BinaryReader): Range {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.minAmount = reader.readString();
          break;
        }
        case 2: {
          msg.maxAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Asset = {
  /**
   * Serializes Asset to protobuf.
   */
  encode: function (msg: PartialDeep<Asset>): Uint8Array {
    return Asset._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Asset from protobuf.
   */
  decode: function (bytes: ByteSource): Asset {
    return Asset._readMessage(
      Asset.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      symbol: "",
      name: "",
      logo: "",
      chainId: "",
      chain: undefined,
      hash: "",
      priceUsd: "",
      range: Range.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Asset>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.symbol) {
      writer.writeString(2, msg.symbol);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.logo) {
      writer.writeString(4, msg.logo);
    }
    if (msg.chainId) {
      writer.writeString(5, msg.chainId);
    }
    if (msg.chain) {
      writer.writeMessage(6, msg.chain, Asset._writeMessage);
    }
    if (msg.hash) {
      writer.writeString(7, msg.hash);
    }
    if (msg.priceUsd) {
      writer.writeString(8, msg.priceUsd);
    }
    if (msg.range) {
      writer.writeMessage(9, msg.range, Range._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, reader: protoscript.BinaryReader): Asset {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.symbol = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.logo = reader.readString();
          break;
        }
        case 5: {
          msg.chainId = reader.readString();
          break;
        }
        case 6: {
          msg.chain = Asset.initialize();
          reader.readMessage(msg.chain, Asset._readMessage);
          break;
        }
        case 7: {
          msg.hash = reader.readString();
          break;
        }
        case 8: {
          msg.priceUsd = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.range, Range._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Quota = {
  /**
   * Serializes Quota to protobuf.
   */
  encode: function (msg: PartialDeep<Quota>): Uint8Array {
    return Quota._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Quota from protobuf.
   */
  decode: function (bytes: ByteSource): Quota {
    return Quota._readMessage(
      Quota.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Quota with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Quota>): Quota {
    return {
      assetId: "",
      amount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Quota>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(2, msg.amount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Quota, reader: protoscript.BinaryReader): Quota {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.amount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Gem = {
  /**
   * Serializes Gem to protobuf.
   */
  encode: function (msg: PartialDeep<Gem>): Uint8Array {
    return Gem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Gem from protobuf.
   */
  decode: function (bytes: ByteSource): Gem {
    return Gem._readMessage(
      Gem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Gem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Gem>): Gem {
    return {
      assetId: "",
      quota: "",
      paid: "",
      filled: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Gem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.quota) {
      writer.writeString(2, msg.quota);
    }
    if (msg.paid) {
      writer.writeString(3, msg.paid);
    }
    if (msg.filled) {
      writer.writeString(4, msg.filled);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Gem, reader: protoscript.BinaryReader): Gem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.quota = reader.readString();
          break;
        }
        case 3: {
          msg.paid = reader.readString();
          break;
        }
        case 4: {
          msg.filled = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const User = {
  /**
   * Serializes User to protobuf.
   */
  encode: function (msg: PartialDeep<User>): Uint8Array {
    return User._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes User from protobuf.
   */
  decode: function (bytes: ByteSource): User {
    return User._readMessage(
      User.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      id: "",
      number: "",
      name: "",
      avatar: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<User>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.number) {
      writer.writeString(2, msg.number);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.avatar) {
      writer.writeString(4, msg.avatar);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, reader: protoscript.BinaryReader): User {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.avatar = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Plan = {
  /**
   * Serializes Plan to protobuf.
   */
  encode: function (msg: PartialDeep<Plan>): Uint8Array {
    return Plan._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Plan from protobuf.
   */
  decode: function (bytes: ByteSource): Plan {
    return Plan._readMessage(
      Plan.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Plan with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Plan>): Plan {
    return {
      id: "",
      createdAt: "",
      updatedAt: "",
      status: Plan.Status._fromInt(0),
      tickedAt: "",
      nextTickAt: "",
      tickNumber: 0,
      name: "",
      userId: "",
      period: "",
      payAssetId: "",
      payAmount: "",
      gems: [],
      quotas: [],
      visibility: Plan.Visibility._fromInt(0),
      user: User.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Plan>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeString(2, msg.createdAt);
    }
    if (msg.updatedAt) {
      writer.writeString(3, msg.updatedAt);
    }
    if (msg.status && Plan.Status._toInt(msg.status)) {
      writer.writeEnum(4, Plan.Status._toInt(msg.status));
    }
    if (msg.tickedAt) {
      writer.writeString(5, msg.tickedAt);
    }
    if (msg.nextTickAt) {
      writer.writeString(6, msg.nextTickAt);
    }
    if (msg.tickNumber) {
      writer.writeInt32(7, msg.tickNumber);
    }
    if (msg.name) {
      writer.writeString(8, msg.name);
    }
    if (msg.userId) {
      writer.writeString(9, msg.userId);
    }
    if (msg.period) {
      writer.writeString(10, msg.period);
    }
    if (msg.payAssetId) {
      writer.writeString(11, msg.payAssetId);
    }
    if (msg.payAmount) {
      writer.writeString(12, msg.payAmount);
    }
    if (msg.gems?.length) {
      writer.writeRepeatedMessage(13, msg.gems as any, Gem._writeMessage);
    }
    if (msg.quotas?.length) {
      writer.writeRepeatedMessage(14, msg.quotas as any, Quota._writeMessage);
    }
    if (msg.visibility && Plan.Visibility._toInt(msg.visibility)) {
      writer.writeEnum(15, Plan.Visibility._toInt(msg.visibility));
    }
    if (msg.user) {
      writer.writeMessage(16, msg.user, User._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Plan, reader: protoscript.BinaryReader): Plan {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.createdAt = reader.readString();
          break;
        }
        case 3: {
          msg.updatedAt = reader.readString();
          break;
        }
        case 4: {
          msg.status = Plan.Status._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.tickedAt = reader.readString();
          break;
        }
        case 6: {
          msg.nextTickAt = reader.readString();
          break;
        }
        case 7: {
          msg.tickNumber = reader.readInt32();
          break;
        }
        case 8: {
          msg.name = reader.readString();
          break;
        }
        case 9: {
          msg.userId = reader.readString();
          break;
        }
        case 10: {
          msg.period = reader.readString();
          break;
        }
        case 11: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 12: {
          msg.payAmount = reader.readString();
          break;
        }
        case 13: {
          const m = Gem.initialize();
          reader.readMessage(m, Gem._readMessage);
          msg.gems.push(m);
          break;
        }
        case 14: {
          const m = Quota.initialize();
          reader.readMessage(m, Quota._readMessage);
          msg.quotas.push(m);
          break;
        }
        case 15: {
          msg.visibility = Plan.Visibility._fromInt(reader.readEnum());
          break;
        }
        case 16: {
          reader.readMessage(msg.user, User._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    RUNNING: "RUNNING",
    STOPPED: "STOPPED",
    DELETED: "DELETED",
    /**
     * @private
     */
    _fromInt: function (i: number): Plan.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "RUNNING";
        }
        case 2: {
          return "STOPPED";
        }
        case 3: {
          return "DELETED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Plan.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Plan.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "RUNNING": {
          return 1;
        }
        case "STOPPED": {
          return 2;
        }
        case "DELETED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Visibility: {
    VISIBILITY_NOT_SET: "VISIBILITY_NOT_SET",
    PRIVATE: "PRIVATE",
    PUBLIC: "PUBLIC",
    ANONYMOUS: "ANONYMOUS",
    /**
     * @private
     */
    _fromInt: function (i: number): Plan.Visibility {
      switch (i) {
        case 0: {
          return "VISIBILITY_NOT_SET";
        }
        case 1: {
          return "PRIVATE";
        }
        case 2: {
          return "PUBLIC";
        }
        case 3: {
          return "ANONYMOUS";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Plan.Visibility;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Plan.Visibility): number {
      switch (i) {
        case "VISIBILITY_NOT_SET": {
          return 0;
        }
        case "PRIVATE": {
          return 1;
        }
        case "PUBLIC": {
          return 2;
        }
        case "ANONYMOUS": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Tick = {
  /**
   * Serializes Tick to protobuf.
   */
  encode: function (msg: PartialDeep<Tick>): Uint8Array {
    return Tick._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Tick from protobuf.
   */
  decode: function (bytes: ByteSource): Tick {
    return Tick._readMessage(
      Tick.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Tick with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Tick>): Tick {
    return {
      id: "",
      createdAt: "",
      updatedAt: "",
      expiredAt: "",
      type: Tick.Type._fromInt(0),
      status: Tick.Status._fromInt(0),
      planId: "",
      number: 0,
      payAssetId: "",
      payAmount: "",
      gems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Tick>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeString(2, msg.createdAt);
    }
    if (msg.updatedAt) {
      writer.writeString(3, msg.updatedAt);
    }
    if (msg.expiredAt) {
      writer.writeString(4, msg.expiredAt);
    }
    if (msg.type && Tick.Type._toInt(msg.type)) {
      writer.writeEnum(5, Tick.Type._toInt(msg.type));
    }
    if (msg.status && Tick.Status._toInt(msg.status)) {
      writer.writeEnum(6, Tick.Status._toInt(msg.status));
    }
    if (msg.planId) {
      writer.writeString(7, msg.planId);
    }
    if (msg.number) {
      writer.writeInt32(8, msg.number);
    }
    if (msg.payAssetId) {
      writer.writeString(9, msg.payAssetId);
    }
    if (msg.payAmount) {
      writer.writeString(10, msg.payAmount);
    }
    if (msg.gems?.length) {
      writer.writeRepeatedMessage(11, msg.gems as any, Gem._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Tick, reader: protoscript.BinaryReader): Tick {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.createdAt = reader.readString();
          break;
        }
        case 3: {
          msg.updatedAt = reader.readString();
          break;
        }
        case 4: {
          msg.expiredAt = reader.readString();
          break;
        }
        case 5: {
          msg.type = Tick.Type._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.status = Tick.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.planId = reader.readString();
          break;
        }
        case 8: {
          msg.number = reader.readInt32();
          break;
        }
        case 9: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 10: {
          msg.payAmount = reader.readString();
          break;
        }
        case 11: {
          const m = Gem.initialize();
          reader.readMessage(m, Gem._readMessage);
          msg.gems.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Type: {
    TYPE_NOT_SET: "TYPE_NOT_SET",
    SCHEDULE: "SCHEDULE",
    MANUAL: "MANUAL",
    /**
     * @private
     */
    _fromInt: function (i: number): Tick.Type {
      switch (i) {
        case 0: {
          return "TYPE_NOT_SET";
        }
        case 1: {
          return "SCHEDULE";
        }
        case 2: {
          return "MANUAL";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Tick.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Tick.Type): number {
      switch (i) {
        case "TYPE_NOT_SET": {
          return 0;
        }
        case "SCHEDULE": {
          return 1;
        }
        case "MANUAL": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    PENDING: "PENDING",
    EXPIRED: "EXPIRED",
    CANCELLED: "CANCELLED",
    PAID: "PAID",
    FILLED: "FILLED",
    SETTLED: "SETTLED",
    /**
     * @private
     */
    _fromInt: function (i: number): Tick.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "EXPIRED";
        }
        case 3: {
          return "CANCELLED";
        }
        case 4: {
          return "PAID";
        }
        case 5: {
          return "FILLED";
        }
        case 6: {
          return "SETTLED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Tick.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Tick.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "EXPIRED": {
          return 2;
        }
        case "CANCELLED": {
          return 3;
        }
        case "PAID": {
          return 4;
        }
        case "FILLED": {
          return 5;
        }
        case "SETTLED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Payment = {
  /**
   * Serializes Payment to protobuf.
   */
  encode: function (msg: PartialDeep<Payment>): Uint8Array {
    return Payment._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Payment from protobuf.
   */
  decode: function (bytes: ByteSource): Payment {
    return Payment._readMessage(
      Payment.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Payment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Payment>): Payment {
    return {
      traceId: "",
      opponents: [],
      threshold: 0,
      assetId: "",
      amount: "",
      memo: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Payment>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.traceId) {
      writer.writeString(1, msg.traceId);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(2, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeUint32(3, msg.threshold);
    }
    if (msg.assetId) {
      writer.writeString(4, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(5, msg.amount);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Payment,
    reader: protoscript.BinaryReader,
  ): Payment {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.traceId = reader.readString();
          break;
        }
        case 2: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 3: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 4: {
          msg.assetId = reader.readString();
          break;
        }
        case 5: {
          msg.amount = reader.readString();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreatePlanRequest = {
  /**
   * Serializes CreatePlanRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CreatePlanRequest>): Uint8Array {
    return CreatePlanRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreatePlanRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreatePlanRequest {
    return CreatePlanRequest._readMessage(
      CreatePlanRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreatePlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreatePlanRequest>): CreatePlanRequest {
    return {
      name: "",
      payAssetId: "",
      period: "",
      quotas: [],
      visibility: Plan.Visibility._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreatePlanRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.payAssetId) {
      writer.writeString(2, msg.payAssetId);
    }
    if (msg.period) {
      writer.writeString(3, msg.period);
    }
    if (msg.quotas?.length) {
      writer.writeRepeatedMessage(4, msg.quotas as any, Quota._writeMessage);
    }
    if (msg.visibility && Plan.Visibility._toInt(msg.visibility)) {
      writer.writeEnum(5, Plan.Visibility._toInt(msg.visibility));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreatePlanRequest,
    reader: protoscript.BinaryReader,
  ): CreatePlanRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 3: {
          msg.period = reader.readString();
          break;
        }
        case 4: {
          const m = Quota.initialize();
          reader.readMessage(m, Quota._readMessage);
          msg.quotas.push(m);
          break;
        }
        case 5: {
          msg.visibility = Plan.Visibility._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreatePlanResponse = {
  /**
   * Serializes CreatePlanResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CreatePlanResponse>): Uint8Array {
    return CreatePlanResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreatePlanResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CreatePlanResponse {
    return CreatePlanResponse._readMessage(
      CreatePlanResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreatePlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreatePlanResponse>): CreatePlanResponse {
    return {
      plan: Plan.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreatePlanResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreatePlanResponse,
    reader: protoscript.BinaryReader,
  ): CreatePlanResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UpdatePlanRequest = {
  /**
   * Serializes UpdatePlanRequest to protobuf.
   */
  encode: function (msg: PartialDeep<UpdatePlanRequest>): Uint8Array {
    return UpdatePlanRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UpdatePlanRequest from protobuf.
   */
  decode: function (bytes: ByteSource): UpdatePlanRequest {
    return UpdatePlanRequest._readMessage(
      UpdatePlanRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes UpdatePlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdatePlanRequest>): UpdatePlanRequest {
    return {
      id: "",
      name: undefined,
      period: undefined,
      quotas: [],
      status: undefined,
      visibility: undefined,
      payAssetId: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdatePlanRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name != undefined) {
      writer.writeString(2, msg.name);
    }
    if (msg.period != undefined) {
      writer.writeString(3, msg.period);
    }
    if (msg.quotas?.length) {
      writer.writeRepeatedMessage(4, msg.quotas as any, Quota._writeMessage);
    }
    if (msg.status != undefined) {
      writer.writeEnum(5, Plan.Status._toInt(msg.status));
    }
    if (msg.visibility != undefined) {
      writer.writeEnum(6, Plan.Visibility._toInt(msg.visibility));
    }
    if (msg.payAssetId != undefined) {
      writer.writeString(7, msg.payAssetId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdatePlanRequest,
    reader: protoscript.BinaryReader,
  ): UpdatePlanRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.period = reader.readString();
          break;
        }
        case 4: {
          const m = Quota.initialize();
          reader.readMessage(m, Quota._readMessage);
          msg.quotas.push(m);
          break;
        }
        case 5: {
          msg.status = Plan.Status._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.visibility = Plan.Visibility._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.payAssetId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UpdatePlanResponse = {
  /**
   * Serializes UpdatePlanResponse to protobuf.
   */
  encode: function (msg: PartialDeep<UpdatePlanResponse>): Uint8Array {
    return UpdatePlanResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UpdatePlanResponse from protobuf.
   */
  decode: function (bytes: ByteSource): UpdatePlanResponse {
    return UpdatePlanResponse._readMessage(
      UpdatePlanResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes UpdatePlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdatePlanResponse>): UpdatePlanResponse {
    return {
      plan: Plan.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdatePlanResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdatePlanResponse,
    reader: protoscript.BinaryReader,
  ): UpdatePlanResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListPlansRequest = {
  /**
   * Serializes ListPlansRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<ListPlansRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes ListPlansRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): ListPlansRequest {
    return {};
  },

  /**
   * Initializes ListPlansRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPlansRequest>): ListPlansRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListPlansRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: ListPlansRequest,
    _reader: protoscript.BinaryReader,
  ): ListPlansRequest {
    return _msg;
  },
};

export const ListPlansResponse = {
  /**
   * Serializes ListPlansResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListPlansResponse>): Uint8Array {
    return ListPlansResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListPlansResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListPlansResponse {
    return ListPlansResponse._readMessage(
      ListPlansResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListPlansResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPlansResponse>): ListPlansResponse {
    return {
      plans: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListPlansResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plans?.length) {
      writer.writeRepeatedMessage(1, msg.plans as any, Plan._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListPlansResponse,
    reader: protoscript.BinaryReader,
  ): ListPlansResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Plan.initialize();
          reader.readMessage(m, Plan._readMessage);
          msg.plans.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreateTickRequest = {
  /**
   * Serializes CreateTickRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CreateTickRequest>): Uint8Array {
    return CreateTickRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateTickRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreateTickRequest {
    return CreateTickRequest._readMessage(
      CreateTickRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateTickRequest>): CreateTickRequest {
    return {
      planId: "",
      quotas: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateTickRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    if (msg.quotas?.length) {
      writer.writeRepeatedMessage(2, msg.quotas as any, Quota._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateTickRequest,
    reader: protoscript.BinaryReader,
  ): CreateTickRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        case 2: {
          const m = Quota.initialize();
          reader.readMessage(m, Quota._readMessage);
          msg.quotas.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreateTickResponse = {
  /**
   * Serializes CreateTickResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CreateTickResponse>): Uint8Array {
    return CreateTickResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateTickResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CreateTickResponse {
    return CreateTickResponse._readMessage(
      CreateTickResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateTickResponse>): CreateTickResponse {
    return {
      plan: Plan.initialize(),
      tick: Tick.initialize(),
      payment: Payment.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateTickResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    if (msg.tick) {
      writer.writeMessage(2, msg.tick, Tick._writeMessage);
    }
    if (msg.payment) {
      writer.writeMessage(3, msg.payment, Payment._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateTickResponse,
    reader: protoscript.BinaryReader,
  ): CreateTickResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.tick, Tick._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.payment, Payment._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindTickRequest = {
  /**
   * Serializes FindTickRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindTickRequest>): Uint8Array {
    return FindTickRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindTickRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindTickRequest {
    return FindTickRequest._readMessage(
      FindTickRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindTickRequest>): FindTickRequest {
    return {
      tickId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTickRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tickId) {
      writer.writeString(1, msg.tickId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTickRequest,
    reader: protoscript.BinaryReader,
  ): FindTickRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.tickId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindTickResponse = {
  /**
   * Serializes FindTickResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindTickResponse>): Uint8Array {
    return FindTickResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindTickResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindTickResponse {
    return FindTickResponse._readMessage(
      FindTickResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindTickResponse>): FindTickResponse {
    return {
      plan: Plan.initialize(),
      tick: Tick.initialize(),
      payment: Payment.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTickResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    if (msg.tick) {
      writer.writeMessage(2, msg.tick, Tick._writeMessage);
    }
    if (msg.payment) {
      writer.writeMessage(3, msg.payment, Payment._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindTickResponse,
    reader: protoscript.BinaryReader,
  ): FindTickResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.tick, Tick._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.payment, Payment._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelTickRequest = {
  /**
   * Serializes CancelTickRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CancelTickRequest>): Uint8Array {
    return CancelTickRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelTickRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CancelTickRequest {
    return CancelTickRequest._readMessage(
      CancelTickRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CancelTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CancelTickRequest>): CancelTickRequest {
    return {
      tickId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelTickRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tickId) {
      writer.writeString(1, msg.tickId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelTickRequest,
    reader: protoscript.BinaryReader,
  ): CancelTickRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.tickId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelTickResponse = {
  /**
   * Serializes CancelTickResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CancelTickResponse>): Uint8Array {
    return CancelTickResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelTickResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CancelTickResponse {
    return CancelTickResponse._readMessage(
      CancelTickResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CancelTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CancelTickResponse>): CancelTickResponse {
    return {
      plan: Plan.initialize(),
      tick: Tick.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelTickResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    if (msg.tick) {
      writer.writeMessage(2, msg.tick, Tick._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelTickResponse,
    reader: protoscript.BinaryReader,
  ): CancelTickResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.tick, Tick._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListBalancesRequest = {
  /**
   * Serializes ListBalancesRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<ListBalancesRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes ListBalancesRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): ListBalancesRequest {
    return {};
  },

  /**
   * Initializes ListBalancesRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListBalancesRequest>,
  ): ListBalancesRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListBalancesRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: ListBalancesRequest,
    _reader: protoscript.BinaryReader,
  ): ListBalancesRequest {
    return _msg;
  },
};

export const Balance = {
  /**
   * Serializes Balance to protobuf.
   */
  encode: function (msg: PartialDeep<Balance>): Uint8Array {
    return Balance._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Balance from protobuf.
   */
  decode: function (bytes: ByteSource): Balance {
    return Balance._readMessage(
      Balance.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Balance with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Balance>): Balance {
    return {
      assetId: "",
      amount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Balance>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(2, msg.amount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Balance,
    reader: protoscript.BinaryReader,
  ): Balance {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.amount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListBalancesResponse = {
  /**
   * Serializes ListBalancesResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListBalancesResponse>): Uint8Array {
    return ListBalancesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListBalancesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListBalancesResponse {
    return ListBalancesResponse._readMessage(
      ListBalancesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListBalancesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListBalancesResponse>,
  ): ListBalancesResponse {
    return {
      balances: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListBalancesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.balances?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.balances as any,
        Balance._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListBalancesResponse,
    reader: protoscript.BinaryReader,
  ): ListBalancesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Balance.initialize();
          reader.readMessage(m, Balance._readMessage);
          msg.balances.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Point = {
  /**
   * Serializes Point to protobuf.
   */
  encode: function (msg: PartialDeep<Point>): Uint8Array {
    return Point._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Point from protobuf.
   */
  decode: function (bytes: ByteSource): Point {
    return Point._readMessage(
      Point.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Point with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Point>): Point {
    return {
      date: "",
      ts: "",
      paidValue: "",
      filledValue: "",
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Point>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.date) {
      writer.writeString(1, msg.date);
    }
    if (msg.ts) {
      writer.writeString(2, msg.ts);
    }
    if (msg.paidValue) {
      writer.writeString(3, msg.paidValue);
    }
    if (msg.filledValue) {
      writer.writeString(4, msg.filledValue);
    }
    if (msg.price) {
      writer.writeString(5, msg.price);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Point, reader: protoscript.BinaryReader): Point {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.date = reader.readString();
          break;
        }
        case 2: {
          msg.ts = reader.readString();
          break;
        }
        case 3: {
          msg.paidValue = reader.readString();
          break;
        }
        case 4: {
          msg.filledValue = reader.readString();
          break;
        }
        case 5: {
          msg.price = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListStatsRequest = {
  /**
   * Serializes ListStatsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListStatsRequest>): Uint8Array {
    return ListStatsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListStatsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListStatsRequest {
    return ListStatsRequest._readMessage(
      ListStatsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListStatsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListStatsRequest>): ListStatsRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListStatsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListStatsRequest,
    reader: protoscript.BinaryReader,
  ): ListStatsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListStatsResponse = {
  /**
   * Serializes ListStatsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListStatsResponse>): Uint8Array {
    return ListStatsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListStatsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListStatsResponse {
    return ListStatsResponse._readMessage(
      ListStatsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListStatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListStatsResponse>): ListStatsResponse {
    return {
      points: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListStatsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.points?.length) {
      writer.writeRepeatedMessage(1, msg.points as any, Point._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListStatsResponse,
    reader: protoscript.BinaryReader,
  ): ListStatsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Point.initialize();
          reader.readMessage(m, Point._readMessage);
          msg.points.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetInfoRequest = {
  /**
   * Serializes GetInfoRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<GetInfoRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes GetInfoRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): GetInfoRequest {
    return {};
  },

  /**
   * Initializes GetInfoRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoRequest>): GetInfoRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<GetInfoRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: GetInfoRequest,
    _reader: protoscript.BinaryReader,
  ): GetInfoRequest {
    return _msg;
  },
};

export const GetInfoResponse = {
  /**
   * Serializes GetInfoResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GetInfoResponse>): Uint8Array {
    return GetInfoResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetInfoResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetInfoResponse {
    return GetInfoResponse._readMessage(
      GetInfoResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetInfoResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoResponse>): GetInfoResponse {
    return {
      clientId: "",
      payAssetIds: [],
      fillAssetIds: [],
      payAssets: [],
      fillAssets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetInfoResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.clientId) {
      writer.writeString(1, msg.clientId);
    }
    if (msg.payAssetIds?.length) {
      writer.writeRepeatedString(2, msg.payAssetIds);
    }
    if (msg.fillAssetIds?.length) {
      writer.writeRepeatedString(3, msg.fillAssetIds);
    }
    if (msg.payAssets?.length) {
      writer.writeRepeatedMessage(4, msg.payAssets as any, Asset._writeMessage);
    }
    if (msg.fillAssets?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fillAssets as any,
        Asset._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetInfoResponse,
    reader: protoscript.BinaryReader,
  ): GetInfoResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.clientId = reader.readString();
          break;
        }
        case 2: {
          msg.payAssetIds.push(reader.readString());
          break;
        }
        case 3: {
          msg.fillAssetIds.push(reader.readString());
          break;
        }
        case 4: {
          const m = Asset.initialize();
          reader.readMessage(m, Asset._readMessage);
          msg.payAssets.push(m);
          break;
        }
        case 5: {
          const m = Asset.initialize();
          reader.readMessage(m, Asset._readMessage);
          msg.fillAssets.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RefreshStatRequest = {
  /**
   * Serializes RefreshStatRequest to protobuf.
   */
  encode: function (msg: PartialDeep<RefreshStatRequest>): Uint8Array {
    return RefreshStatRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RefreshStatRequest from protobuf.
   */
  decode: function (bytes: ByteSource): RefreshStatRequest {
    return RefreshStatRequest._readMessage(
      RefreshStatRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RefreshStatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RefreshStatRequest>): RefreshStatRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RefreshStatRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RefreshStatRequest,
    reader: protoscript.BinaryReader,
  ): RefreshStatRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RefreshStatResponse = {
  /**
   * Serializes RefreshStatResponse to protobuf.
   */
  encode: function (_msg?: PartialDeep<RefreshStatResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes RefreshStatResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): RefreshStatResponse {
    return {};
  },

  /**
   * Initializes RefreshStatResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RefreshStatResponse>,
  ): RefreshStatResponse {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<RefreshStatResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: RefreshStatResponse,
    _reader: protoscript.BinaryReader,
  ): RefreshStatResponse {
    return _msg;
  },
};

export const CreateMultisigRequest = {
  /**
   * Serializes CreateMultisigRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CreateMultisigRequest>): Uint8Array {
    return CreateMultisigRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateMultisigRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreateMultisigRequest {
    return CreateMultisigRequest._readMessage(
      CreateMultisigRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateMultisigRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateMultisigRequest>,
  ): CreateMultisigRequest {
    return {
      payment: Payment.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateMultisigRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.payment) {
      writer.writeMessage(1, msg.payment, Payment._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateMultisigRequest,
    reader: protoscript.BinaryReader,
  ): CreateMultisigRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.payment, Payment._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreateMultisigResponse = {
  /**
   * Serializes CreateMultisigResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CreateMultisigResponse>): Uint8Array {
    return CreateMultisigResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateMultisigResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CreateMultisigResponse {
    return CreateMultisigResponse._readMessage(
      CreateMultisigResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateMultisigResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateMultisigResponse>,
  ): CreateMultisigResponse {
    return {
      requestId: "",
      txHash: "",
      assetId: "",
      assetHash: "",
      amount: "",
      extra: "",
      rawTx: "",
      senders: [],
      signers: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateMultisigResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.requestId) {
      writer.writeString(1, msg.requestId);
    }
    if (msg.txHash) {
      writer.writeString(2, msg.txHash);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.assetHash) {
      writer.writeString(4, msg.assetHash);
    }
    if (msg.amount) {
      writer.writeString(5, msg.amount);
    }
    if (msg.extra) {
      writer.writeString(6, msg.extra);
    }
    if (msg.rawTx) {
      writer.writeString(7, msg.rawTx);
    }
    if (msg.senders?.length) {
      writer.writeRepeatedString(8, msg.senders);
    }
    if (msg.signers?.length) {
      writer.writeRepeatedString(9, msg.signers);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateMultisigResponse,
    reader: protoscript.BinaryReader,
  ): CreateMultisigResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.requestId = reader.readString();
          break;
        }
        case 2: {
          msg.txHash = reader.readString();
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.assetHash = reader.readString();
          break;
        }
        case 5: {
          msg.amount = reader.readString();
          break;
        }
        case 6: {
          msg.extra = reader.readString();
          break;
        }
        case 7: {
          msg.rawTx = reader.readString();
          break;
        }
        case 8: {
          msg.senders.push(reader.readString());
          break;
        }
        case 9: {
          msg.signers.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTicksRequest = {
  /**
   * Serializes ListTicksRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListTicksRequest>): Uint8Array {
    return ListTicksRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTicksRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListTicksRequest {
    return ListTicksRequest._readMessage(
      ListTicksRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTicksRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTicksRequest>): ListTicksRequest {
    return {
      planId: "",
      offset: "",
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTicksRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    if (msg.offset) {
      writer.writeString(2, msg.offset);
    }
    if (msg.limit) {
      writer.writeInt32(3, msg.limit);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTicksRequest,
    reader: protoscript.BinaryReader,
  ): ListTicksRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        case 2: {
          msg.offset = reader.readString();
          break;
        }
        case 3: {
          msg.limit = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTicksResponse = {
  /**
   * Serializes ListTicksResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListTicksResponse>): Uint8Array {
    return ListTicksResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTicksResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListTicksResponse {
    return ListTicksResponse._readMessage(
      ListTicksResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTicksResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTicksResponse>): ListTicksResponse {
    return {
      ticks: [],
      nextOffset: "",
      hasNext: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTicksResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ticks?.length) {
      writer.writeRepeatedMessage(1, msg.ticks as any, Tick._writeMessage);
    }
    if (msg.nextOffset) {
      writer.writeString(2, msg.nextOffset);
    }
    if (msg.hasNext) {
      writer.writeBool(3, msg.hasNext);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTicksResponse,
    reader: protoscript.BinaryReader,
  ): ListTicksResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Tick.initialize();
          reader.readMessage(m, Tick._readMessage);
          msg.ticks.push(m);
          break;
        }
        case 2: {
          msg.nextOffset = reader.readString();
          break;
        }
        case 3: {
          msg.hasNext = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ReadRankingListRequest = {
  /**
   * Serializes ReadRankingListRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ReadRankingListRequest>): Uint8Array {
    return ReadRankingListRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ReadRankingListRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ReadRankingListRequest {
    return ReadRankingListRequest._readMessage(
      ReadRankingListRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ReadRankingListRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ReadRankingListRequest>,
  ): ReadRankingListRequest {
    return {
      id: "",
      page: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReadRankingListRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.page) {
      writer.writeInt32(2, msg.page);
    }
    if (msg.count) {
      writer.writeInt32(3, msg.count);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReadRankingListRequest,
    reader: protoscript.BinaryReader,
  ): ReadRankingListRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.page = reader.readInt32();
          break;
        }
        case 3: {
          msg.count = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlanStat = {
  /**
   * Serializes PlanStat to protobuf.
   */
  encode: function (msg: PartialDeep<PlanStat>): Uint8Array {
    return PlanStat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlanStat from protobuf.
   */
  decode: function (bytes: ByteSource): PlanStat {
    return PlanStat._readMessage(
      PlanStat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlanStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlanStat>): PlanStat {
    return {
      plan: Plan.initialize(),
      paidValue: "",
      filledValue: "",
      rate: "",
      extra: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlanStat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    if (msg.paidValue) {
      writer.writeString(2, msg.paidValue);
    }
    if (msg.filledValue) {
      writer.writeString(3, msg.filledValue);
    }
    if (msg.rate) {
      writer.writeString(4, msg.rate);
    }
    if (msg.extra) {
      writer.writeString(5, msg.extra);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlanStat,
    reader: protoscript.BinaryReader,
  ): PlanStat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        case 2: {
          msg.paidValue = reader.readString();
          break;
        }
        case 3: {
          msg.filledValue = reader.readString();
          break;
        }
        case 4: {
          msg.rate = reader.readString();
          break;
        }
        case 5: {
          msg.extra = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ReadRankingListResponse = {
  /**
   * Serializes ReadRankingListResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ReadRankingListResponse>): Uint8Array {
    return ReadRankingListResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ReadRankingListResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ReadRankingListResponse {
    return ReadRankingListResponse._readMessage(
      ReadRankingListResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ReadRankingListResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ReadRankingListResponse>,
  ): ReadRankingListResponse {
    return {
      id: "",
      name: "",
      updatedAt: "",
      updatedTs: "",
      plans: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReadRankingListResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.updatedAt) {
      writer.writeString(3, msg.updatedAt);
    }
    if (msg.updatedTs) {
      writer.writeString(4, msg.updatedTs);
    }
    if (msg.plans?.length) {
      writer.writeRepeatedMessage(5, msg.plans as any, PlanStat._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReadRankingListResponse,
    reader: protoscript.BinaryReader,
  ): ReadRankingListResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.updatedAt = reader.readString();
          break;
        }
        case 4: {
          msg.updatedTs = reader.readString();
          break;
        }
        case 5: {
          const m = PlanStat.initialize();
          reader.readMessage(m, PlanStat._readMessage);
          msg.plans.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CopyPlanRequest = {
  /**
   * Serializes CopyPlanRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CopyPlanRequest>): Uint8Array {
    return CopyPlanRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CopyPlanRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CopyPlanRequest {
    return CopyPlanRequest._readMessage(
      CopyPlanRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CopyPlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CopyPlanRequest>): CopyPlanRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CopyPlanRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CopyPlanRequest,
    reader: protoscript.BinaryReader,
  ): CopyPlanRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CopyPlanResponse = {
  /**
   * Serializes CopyPlanResponse to protobuf.
   */
  encode: function (msg: PartialDeep<CopyPlanResponse>): Uint8Array {
    return CopyPlanResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CopyPlanResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CopyPlanResponse {
    return CopyPlanResponse._readMessage(
      CopyPlanResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CopyPlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CopyPlanResponse>): CopyPlanResponse {
    return {
      plan: Plan.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CopyPlanResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CopyPlanResponse,
    reader: protoscript.BinaryReader,
  ): CopyPlanResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindPlanRequest = {
  /**
   * Serializes FindPlanRequest to protobuf.
   */
  encode: function (msg: PartialDeep<FindPlanRequest>): Uint8Array {
    return FindPlanRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindPlanRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FindPlanRequest {
    return FindPlanRequest._readMessage(
      FindPlanRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindPlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPlanRequest>): FindPlanRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPlanRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.planId) {
      writer.writeString(1, msg.planId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindPlanRequest,
    reader: protoscript.BinaryReader,
  ): FindPlanRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.planId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FindPlanResponse = {
  /**
   * Serializes FindPlanResponse to protobuf.
   */
  encode: function (msg: PartialDeep<FindPlanResponse>): Uint8Array {
    return FindPlanResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FindPlanResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FindPlanResponse {
    return FindPlanResponse._readMessage(
      FindPlanResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FindPlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPlanResponse>): FindPlanResponse {
    return {
      plan: Plan.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPlanResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.plan) {
      writer.writeMessage(1, msg.plan, Plan._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FindPlanResponse,
    reader: protoscript.BinaryReader,
  ): FindPlanResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.plan, Plan._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const RangeJSON = {
  /**
   * Serializes Range to JSON.
   */
  encode: function (msg: PartialDeep<Range>): string {
    return JSON.stringify(RangeJSON._writeMessage(msg));
  },

  /**
   * Deserializes Range from JSON.
   */
  decode: function (json: string): Range {
    return RangeJSON._readMessage(RangeJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Range with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Range>): Range {
    return {
      minAmount: "",
      maxAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Range>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.minAmount) {
      json["minAmount"] = msg.minAmount;
    }
    if (msg.maxAmount) {
      json["maxAmount"] = msg.maxAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Range, json: any): Range {
    const _minAmount_ = json["minAmount"] ?? json["min_amount"];
    if (_minAmount_) {
      msg.minAmount = _minAmount_;
    }
    const _maxAmount_ = json["maxAmount"] ?? json["max_amount"];
    if (_maxAmount_) {
      msg.maxAmount = _maxAmount_;
    }
    return msg;
  },
};

export const AssetJSON = {
  /**
   * Serializes Asset to JSON.
   */
  encode: function (msg: PartialDeep<Asset>): string {
    return JSON.stringify(AssetJSON._writeMessage(msg));
  },

  /**
   * Deserializes Asset from JSON.
   */
  decode: function (json: string): Asset {
    return AssetJSON._readMessage(AssetJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      symbol: "",
      name: "",
      logo: "",
      chainId: "",
      chain: undefined,
      hash: "",
      priceUsd: "",
      range: RangeJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Asset>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.symbol) {
      json["symbol"] = msg.symbol;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.logo) {
      json["logo"] = msg.logo;
    }
    if (msg.chainId) {
      json["chainId"] = msg.chainId;
    }
    if (msg.chain) {
      const _chain_ = AssetJSON._writeMessage(msg.chain);
      if (Object.keys(_chain_).length > 0) {
        json["chain"] = _chain_;
      }
    }
    if (msg.hash) {
      json["hash"] = msg.hash;
    }
    if (msg.priceUsd) {
      json["priceUsd"] = msg.priceUsd;
    }
    if (msg.range) {
      const _range_ = RangeJSON._writeMessage(msg.range);
      if (Object.keys(_range_).length > 0) {
        json["range"] = _range_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, json: any): Asset {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _symbol_ = json["symbol"];
    if (_symbol_) {
      msg.symbol = _symbol_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _logo_ = json["logo"];
    if (_logo_) {
      msg.logo = _logo_;
    }
    const _chainId_ = json["chainId"] ?? json["chain_id"];
    if (_chainId_) {
      msg.chainId = _chainId_;
    }
    const _chain_ = json["chain"];
    if (_chain_) {
      msg.chain = AssetJSON.initialize();
      AssetJSON._readMessage(msg.chain, _chain_);
    }
    const _hash_ = json["hash"];
    if (_hash_) {
      msg.hash = _hash_;
    }
    const _priceUsd_ = json["priceUsd"] ?? json["price_usd"];
    if (_priceUsd_) {
      msg.priceUsd = _priceUsd_;
    }
    const _range_ = json["range"];
    if (_range_) {
      RangeJSON._readMessage(msg.range, _range_);
    }
    return msg;
  },
};

export const QuotaJSON = {
  /**
   * Serializes Quota to JSON.
   */
  encode: function (msg: PartialDeep<Quota>): string {
    return JSON.stringify(QuotaJSON._writeMessage(msg));
  },

  /**
   * Deserializes Quota from JSON.
   */
  decode: function (json: string): Quota {
    return QuotaJSON._readMessage(QuotaJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Quota with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Quota>): Quota {
    return {
      assetId: "",
      amount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Quota>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Quota, json: any): Quota {
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    return msg;
  },
};

export const GemJSON = {
  /**
   * Serializes Gem to JSON.
   */
  encode: function (msg: PartialDeep<Gem>): string {
    return JSON.stringify(GemJSON._writeMessage(msg));
  },

  /**
   * Deserializes Gem from JSON.
   */
  decode: function (json: string): Gem {
    return GemJSON._readMessage(GemJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Gem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Gem>): Gem {
    return {
      assetId: "",
      quota: "",
      paid: "",
      filled: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Gem>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.quota) {
      json["quota"] = msg.quota;
    }
    if (msg.paid) {
      json["paid"] = msg.paid;
    }
    if (msg.filled) {
      json["filled"] = msg.filled;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Gem, json: any): Gem {
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _quota_ = json["quota"];
    if (_quota_) {
      msg.quota = _quota_;
    }
    const _paid_ = json["paid"];
    if (_paid_) {
      msg.paid = _paid_;
    }
    const _filled_ = json["filled"];
    if (_filled_) {
      msg.filled = _filled_;
    }
    return msg;
  },
};

export const UserJSON = {
  /**
   * Serializes User to JSON.
   */
  encode: function (msg: PartialDeep<User>): string {
    return JSON.stringify(UserJSON._writeMessage(msg));
  },

  /**
   * Deserializes User from JSON.
   */
  decode: function (json: string): User {
    return UserJSON._readMessage(UserJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      id: "",
      number: "",
      name: "",
      avatar: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<User>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.avatar) {
      json["avatar"] = msg.avatar;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, json: any): User {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _number_ = json["number"];
    if (_number_) {
      msg.number = _number_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _avatar_ = json["avatar"];
    if (_avatar_) {
      msg.avatar = _avatar_;
    }
    return msg;
  },
};

export const PlanJSON = {
  /**
   * Serializes Plan to JSON.
   */
  encode: function (msg: PartialDeep<Plan>): string {
    return JSON.stringify(PlanJSON._writeMessage(msg));
  },

  /**
   * Deserializes Plan from JSON.
   */
  decode: function (json: string): Plan {
    return PlanJSON._readMessage(PlanJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Plan with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Plan>): Plan {
    return {
      id: "",
      createdAt: "",
      updatedAt: "",
      status: Plan.Status._fromInt(0),
      tickedAt: "",
      nextTickAt: "",
      tickNumber: 0,
      name: "",
      userId: "",
      period: "",
      payAssetId: "",
      payAmount: "",
      gems: [],
      quotas: [],
      visibility: Plan.Visibility._fromInt(0),
      user: UserJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Plan>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt) {
      json["createdAt"] = msg.createdAt;
    }
    if (msg.updatedAt) {
      json["updatedAt"] = msg.updatedAt;
    }
    if (msg.status && PlanJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.tickedAt) {
      json["tickedAt"] = msg.tickedAt;
    }
    if (msg.nextTickAt) {
      json["nextTickAt"] = msg.nextTickAt;
    }
    if (msg.tickNumber) {
      json["tickNumber"] = msg.tickNumber;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.period) {
      json["period"] = msg.period;
    }
    if (msg.payAssetId) {
      json["payAssetId"] = msg.payAssetId;
    }
    if (msg.payAmount) {
      json["payAmount"] = msg.payAmount;
    }
    if (msg.gems?.length) {
      json["gems"] = msg.gems.map(GemJSON._writeMessage);
    }
    if (msg.quotas?.length) {
      json["quotas"] = msg.quotas.map(QuotaJSON._writeMessage);
    }
    if (msg.visibility && PlanJSON.Visibility._toInt(msg.visibility)) {
      json["visibility"] = msg.visibility;
    }
    if (msg.user) {
      const _user_ = UserJSON._writeMessage(msg.user);
      if (Object.keys(_user_).length > 0) {
        json["user"] = _user_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Plan, json: any): Plan {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = _createdAt_;
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = _updatedAt_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Plan.Status._fromInt(_status_);
    }
    const _tickedAt_ = json["tickedAt"] ?? json["ticked_at"];
    if (_tickedAt_) {
      msg.tickedAt = _tickedAt_;
    }
    const _nextTickAt_ = json["nextTickAt"] ?? json["next_tick_at"];
    if (_nextTickAt_) {
      msg.nextTickAt = _nextTickAt_;
    }
    const _tickNumber_ = json["tickNumber"] ?? json["tick_number"];
    if (_tickNumber_) {
      msg.tickNumber = protoscript.parseNumber(_tickNumber_);
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _period_ = json["period"];
    if (_period_) {
      msg.period = _period_;
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    const _payAmount_ = json["payAmount"] ?? json["pay_amount"];
    if (_payAmount_) {
      msg.payAmount = _payAmount_;
    }
    const _gems_ = json["gems"];
    if (_gems_) {
      for (const item of _gems_) {
        const m = GemJSON.initialize();
        GemJSON._readMessage(m, item);
        msg.gems.push(m);
      }
    }
    const _quotas_ = json["quotas"];
    if (_quotas_) {
      for (const item of _quotas_) {
        const m = QuotaJSON.initialize();
        QuotaJSON._readMessage(m, item);
        msg.quotas.push(m);
      }
    }
    const _visibility_ = json["visibility"];
    if (_visibility_) {
      msg.visibility = Plan.Visibility._fromInt(_visibility_);
    }
    const _user_ = json["user"];
    if (_user_) {
      UserJSON._readMessage(msg.user, _user_);
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    RUNNING: "RUNNING",
    STOPPED: "STOPPED",
    DELETED: "DELETED",
    /**
     * @private
     */
    _fromInt: function (i: number): Plan.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "RUNNING";
        }
        case 2: {
          return "STOPPED";
        }
        case 3: {
          return "DELETED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Plan.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Plan.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "RUNNING": {
          return 1;
        }
        case "STOPPED": {
          return 2;
        }
        case "DELETED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Visibility: {
    VISIBILITY_NOT_SET: "VISIBILITY_NOT_SET",
    PRIVATE: "PRIVATE",
    PUBLIC: "PUBLIC",
    ANONYMOUS: "ANONYMOUS",
    /**
     * @private
     */
    _fromInt: function (i: number): Plan.Visibility {
      switch (i) {
        case 0: {
          return "VISIBILITY_NOT_SET";
        }
        case 1: {
          return "PRIVATE";
        }
        case 2: {
          return "PUBLIC";
        }
        case 3: {
          return "ANONYMOUS";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Plan.Visibility;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Plan.Visibility): number {
      switch (i) {
        case "VISIBILITY_NOT_SET": {
          return 0;
        }
        case "PRIVATE": {
          return 1;
        }
        case "PUBLIC": {
          return 2;
        }
        case "ANONYMOUS": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const TickJSON = {
  /**
   * Serializes Tick to JSON.
   */
  encode: function (msg: PartialDeep<Tick>): string {
    return JSON.stringify(TickJSON._writeMessage(msg));
  },

  /**
   * Deserializes Tick from JSON.
   */
  decode: function (json: string): Tick {
    return TickJSON._readMessage(TickJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Tick with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Tick>): Tick {
    return {
      id: "",
      createdAt: "",
      updatedAt: "",
      expiredAt: "",
      type: Tick.Type._fromInt(0),
      status: Tick.Status._fromInt(0),
      planId: "",
      number: 0,
      payAssetId: "",
      payAmount: "",
      gems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Tick>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt) {
      json["createdAt"] = msg.createdAt;
    }
    if (msg.updatedAt) {
      json["updatedAt"] = msg.updatedAt;
    }
    if (msg.expiredAt) {
      json["expiredAt"] = msg.expiredAt;
    }
    if (msg.type && TickJSON.Type._toInt(msg.type)) {
      json["type"] = msg.type;
    }
    if (msg.status && TickJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.payAssetId) {
      json["payAssetId"] = msg.payAssetId;
    }
    if (msg.payAmount) {
      json["payAmount"] = msg.payAmount;
    }
    if (msg.gems?.length) {
      json["gems"] = msg.gems.map(GemJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Tick, json: any): Tick {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = _createdAt_;
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = _updatedAt_;
    }
    const _expiredAt_ = json["expiredAt"] ?? json["expired_at"];
    if (_expiredAt_) {
      msg.expiredAt = _expiredAt_;
    }
    const _type_ = json["type"];
    if (_type_) {
      msg.type = Tick.Type._fromInt(_type_);
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Tick.Status._fromInt(_status_);
    }
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    const _number_ = json["number"];
    if (_number_) {
      msg.number = protoscript.parseNumber(_number_);
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    const _payAmount_ = json["payAmount"] ?? json["pay_amount"];
    if (_payAmount_) {
      msg.payAmount = _payAmount_;
    }
    const _gems_ = json["gems"];
    if (_gems_) {
      for (const item of _gems_) {
        const m = GemJSON.initialize();
        GemJSON._readMessage(m, item);
        msg.gems.push(m);
      }
    }
    return msg;
  },

  Type: {
    TYPE_NOT_SET: "TYPE_NOT_SET",
    SCHEDULE: "SCHEDULE",
    MANUAL: "MANUAL",
    /**
     * @private
     */
    _fromInt: function (i: number): Tick.Type {
      switch (i) {
        case 0: {
          return "TYPE_NOT_SET";
        }
        case 1: {
          return "SCHEDULE";
        }
        case 2: {
          return "MANUAL";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Tick.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Tick.Type): number {
      switch (i) {
        case "TYPE_NOT_SET": {
          return 0;
        }
        case "SCHEDULE": {
          return 1;
        }
        case "MANUAL": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    PENDING: "PENDING",
    EXPIRED: "EXPIRED",
    CANCELLED: "CANCELLED",
    PAID: "PAID",
    FILLED: "FILLED",
    SETTLED: "SETTLED",
    /**
     * @private
     */
    _fromInt: function (i: number): Tick.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "EXPIRED";
        }
        case 3: {
          return "CANCELLED";
        }
        case 4: {
          return "PAID";
        }
        case 5: {
          return "FILLED";
        }
        case 6: {
          return "SETTLED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Tick.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Tick.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "EXPIRED": {
          return 2;
        }
        case "CANCELLED": {
          return 3;
        }
        case "PAID": {
          return 4;
        }
        case "FILLED": {
          return 5;
        }
        case "SETTLED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const PaymentJSON = {
  /**
   * Serializes Payment to JSON.
   */
  encode: function (msg: PartialDeep<Payment>): string {
    return JSON.stringify(PaymentJSON._writeMessage(msg));
  },

  /**
   * Deserializes Payment from JSON.
   */
  decode: function (json: string): Payment {
    return PaymentJSON._readMessage(PaymentJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Payment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Payment>): Payment {
    return {
      traceId: "",
      opponents: [],
      threshold: 0,
      assetId: "",
      amount: "",
      memo: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Payment>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.traceId) {
      json["traceId"] = msg.traceId;
    }
    if (msg.opponents?.length) {
      json["opponents"] = msg.opponents;
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Payment, json: any): Payment {
    const _traceId_ = json["traceId"] ?? json["trace_id"];
    if (_traceId_) {
      msg.traceId = _traceId_;
    }
    const _opponents_ = json["opponents"];
    if (_opponents_) {
      msg.opponents = _opponents_;
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    return msg;
  },
};

export const CreatePlanRequestJSON = {
  /**
   * Serializes CreatePlanRequest to JSON.
   */
  encode: function (msg: PartialDeep<CreatePlanRequest>): string {
    return JSON.stringify(CreatePlanRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreatePlanRequest from JSON.
   */
  decode: function (json: string): CreatePlanRequest {
    return CreatePlanRequestJSON._readMessage(
      CreatePlanRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreatePlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreatePlanRequest>): CreatePlanRequest {
    return {
      name: "",
      payAssetId: "",
      period: "",
      quotas: [],
      visibility: Plan.Visibility._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreatePlanRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.payAssetId) {
      json["payAssetId"] = msg.payAssetId;
    }
    if (msg.period) {
      json["period"] = msg.period;
    }
    if (msg.quotas?.length) {
      json["quotas"] = msg.quotas.map(QuotaJSON._writeMessage);
    }
    if (msg.visibility && PlanJSON.Visibility._toInt(msg.visibility)) {
      json["visibility"] = msg.visibility;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreatePlanRequest,
    json: any,
  ): CreatePlanRequest {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    const _period_ = json["period"];
    if (_period_) {
      msg.period = _period_;
    }
    const _quotas_ = json["quotas"];
    if (_quotas_) {
      for (const item of _quotas_) {
        const m = QuotaJSON.initialize();
        QuotaJSON._readMessage(m, item);
        msg.quotas.push(m);
      }
    }
    const _visibility_ = json["visibility"];
    if (_visibility_) {
      msg.visibility = Plan.Visibility._fromInt(_visibility_);
    }
    return msg;
  },
};

export const CreatePlanResponseJSON = {
  /**
   * Serializes CreatePlanResponse to JSON.
   */
  encode: function (msg: PartialDeep<CreatePlanResponse>): string {
    return JSON.stringify(CreatePlanResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreatePlanResponse from JSON.
   */
  decode: function (json: string): CreatePlanResponse {
    return CreatePlanResponseJSON._readMessage(
      CreatePlanResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreatePlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreatePlanResponse>): CreatePlanResponse {
    return {
      plan: PlanJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreatePlanResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreatePlanResponse,
    json: any,
  ): CreatePlanResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    return msg;
  },
};

export const UpdatePlanRequestJSON = {
  /**
   * Serializes UpdatePlanRequest to JSON.
   */
  encode: function (msg: PartialDeep<UpdatePlanRequest>): string {
    return JSON.stringify(UpdatePlanRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes UpdatePlanRequest from JSON.
   */
  decode: function (json: string): UpdatePlanRequest {
    return UpdatePlanRequestJSON._readMessage(
      UpdatePlanRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UpdatePlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdatePlanRequest>): UpdatePlanRequest {
    return {
      id: "",
      name: undefined,
      period: undefined,
      quotas: [],
      status: undefined,
      visibility: undefined,
      payAssetId: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdatePlanRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name != undefined) {
      json["name"] = msg.name;
    }
    if (msg.period != undefined) {
      json["period"] = msg.period;
    }
    if (msg.quotas?.length) {
      json["quotas"] = msg.quotas.map(QuotaJSON._writeMessage);
    }
    if (msg.status != undefined) {
      json["status"] = msg.status;
    }
    if (msg.visibility != undefined) {
      json["visibility"] = msg.visibility;
    }
    if (msg.payAssetId != undefined) {
      json["payAssetId"] = msg.payAssetId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdatePlanRequest,
    json: any,
  ): UpdatePlanRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _period_ = json["period"];
    if (_period_) {
      msg.period = _period_;
    }
    const _quotas_ = json["quotas"];
    if (_quotas_) {
      for (const item of _quotas_) {
        const m = QuotaJSON.initialize();
        QuotaJSON._readMessage(m, item);
        msg.quotas.push(m);
      }
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Plan.Status._fromInt(_status_);
    }
    const _visibility_ = json["visibility"];
    if (_visibility_) {
      msg.visibility = Plan.Visibility._fromInt(_visibility_);
    }
    const _payAssetId_ = json["payAssetId"] ?? json["pay_asset_id"];
    if (_payAssetId_) {
      msg.payAssetId = _payAssetId_;
    }
    return msg;
  },
};

export const UpdatePlanResponseJSON = {
  /**
   * Serializes UpdatePlanResponse to JSON.
   */
  encode: function (msg: PartialDeep<UpdatePlanResponse>): string {
    return JSON.stringify(UpdatePlanResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes UpdatePlanResponse from JSON.
   */
  decode: function (json: string): UpdatePlanResponse {
    return UpdatePlanResponseJSON._readMessage(
      UpdatePlanResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UpdatePlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdatePlanResponse>): UpdatePlanResponse {
    return {
      plan: PlanJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdatePlanResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdatePlanResponse,
    json: any,
  ): UpdatePlanResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    return msg;
  },
};

export const ListPlansRequestJSON = {
  /**
   * Serializes ListPlansRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<ListPlansRequest>): string {
    return "{}";
  },

  /**
   * Deserializes ListPlansRequest from JSON.
   */
  decode: function (_json?: string): ListPlansRequest {
    return {};
  },

  /**
   * Initializes ListPlansRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPlansRequest>): ListPlansRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListPlansRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListPlansRequest, _json: any): ListPlansRequest {
    return msg;
  },
};

export const ListPlansResponseJSON = {
  /**
   * Serializes ListPlansResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListPlansResponse>): string {
    return JSON.stringify(ListPlansResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListPlansResponse from JSON.
   */
  decode: function (json: string): ListPlansResponse {
    return ListPlansResponseJSON._readMessage(
      ListPlansResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListPlansResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListPlansResponse>): ListPlansResponse {
    return {
      plans: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListPlansResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plans?.length) {
      json["plans"] = msg.plans.map(PlanJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListPlansResponse,
    json: any,
  ): ListPlansResponse {
    const _plans_ = json["plans"];
    if (_plans_) {
      for (const item of _plans_) {
        const m = PlanJSON.initialize();
        PlanJSON._readMessage(m, item);
        msg.plans.push(m);
      }
    }
    return msg;
  },
};

export const CreateTickRequestJSON = {
  /**
   * Serializes CreateTickRequest to JSON.
   */
  encode: function (msg: PartialDeep<CreateTickRequest>): string {
    return JSON.stringify(CreateTickRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateTickRequest from JSON.
   */
  decode: function (json: string): CreateTickRequest {
    return CreateTickRequestJSON._readMessage(
      CreateTickRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateTickRequest>): CreateTickRequest {
    return {
      planId: "",
      quotas: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateTickRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    if (msg.quotas?.length) {
      json["quotas"] = msg.quotas.map(QuotaJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateTickRequest,
    json: any,
  ): CreateTickRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    const _quotas_ = json["quotas"];
    if (_quotas_) {
      for (const item of _quotas_) {
        const m = QuotaJSON.initialize();
        QuotaJSON._readMessage(m, item);
        msg.quotas.push(m);
      }
    }
    return msg;
  },
};

export const CreateTickResponseJSON = {
  /**
   * Serializes CreateTickResponse to JSON.
   */
  encode: function (msg: PartialDeep<CreateTickResponse>): string {
    return JSON.stringify(CreateTickResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateTickResponse from JSON.
   */
  decode: function (json: string): CreateTickResponse {
    return CreateTickResponseJSON._readMessage(
      CreateTickResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateTickResponse>): CreateTickResponse {
    return {
      plan: PlanJSON.initialize(),
      tick: TickJSON.initialize(),
      payment: PaymentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateTickResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    if (msg.tick) {
      const _tick_ = TickJSON._writeMessage(msg.tick);
      if (Object.keys(_tick_).length > 0) {
        json["tick"] = _tick_;
      }
    }
    if (msg.payment) {
      const _payment_ = PaymentJSON._writeMessage(msg.payment);
      if (Object.keys(_payment_).length > 0) {
        json["payment"] = _payment_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateTickResponse,
    json: any,
  ): CreateTickResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    const _tick_ = json["tick"];
    if (_tick_) {
      TickJSON._readMessage(msg.tick, _tick_);
    }
    const _payment_ = json["payment"];
    if (_payment_) {
      PaymentJSON._readMessage(msg.payment, _payment_);
    }
    return msg;
  },
};

export const FindTickRequestJSON = {
  /**
   * Serializes FindTickRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindTickRequest>): string {
    return JSON.stringify(FindTickRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindTickRequest from JSON.
   */
  decode: function (json: string): FindTickRequest {
    return FindTickRequestJSON._readMessage(
      FindTickRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindTickRequest>): FindTickRequest {
    return {
      tickId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTickRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tickId) {
      json["tickId"] = msg.tickId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindTickRequest, json: any): FindTickRequest {
    const _tickId_ = json["tickId"] ?? json["tick_id"];
    if (_tickId_) {
      msg.tickId = _tickId_;
    }
    return msg;
  },
};

export const FindTickResponseJSON = {
  /**
   * Serializes FindTickResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindTickResponse>): string {
    return JSON.stringify(FindTickResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindTickResponse from JSON.
   */
  decode: function (json: string): FindTickResponse {
    return FindTickResponseJSON._readMessage(
      FindTickResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindTickResponse>): FindTickResponse {
    return {
      plan: PlanJSON.initialize(),
      tick: TickJSON.initialize(),
      payment: PaymentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindTickResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    if (msg.tick) {
      const _tick_ = TickJSON._writeMessage(msg.tick);
      if (Object.keys(_tick_).length > 0) {
        json["tick"] = _tick_;
      }
    }
    if (msg.payment) {
      const _payment_ = PaymentJSON._writeMessage(msg.payment);
      if (Object.keys(_payment_).length > 0) {
        json["payment"] = _payment_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindTickResponse, json: any): FindTickResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    const _tick_ = json["tick"];
    if (_tick_) {
      TickJSON._readMessage(msg.tick, _tick_);
    }
    const _payment_ = json["payment"];
    if (_payment_) {
      PaymentJSON._readMessage(msg.payment, _payment_);
    }
    return msg;
  },
};

export const CancelTickRequestJSON = {
  /**
   * Serializes CancelTickRequest to JSON.
   */
  encode: function (msg: PartialDeep<CancelTickRequest>): string {
    return JSON.stringify(CancelTickRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CancelTickRequest from JSON.
   */
  decode: function (json: string): CancelTickRequest {
    return CancelTickRequestJSON._readMessage(
      CancelTickRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CancelTickRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CancelTickRequest>): CancelTickRequest {
    return {
      tickId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelTickRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tickId) {
      json["tickId"] = msg.tickId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelTickRequest,
    json: any,
  ): CancelTickRequest {
    const _tickId_ = json["tickId"] ?? json["tick_id"];
    if (_tickId_) {
      msg.tickId = _tickId_;
    }
    return msg;
  },
};

export const CancelTickResponseJSON = {
  /**
   * Serializes CancelTickResponse to JSON.
   */
  encode: function (msg: PartialDeep<CancelTickResponse>): string {
    return JSON.stringify(CancelTickResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CancelTickResponse from JSON.
   */
  decode: function (json: string): CancelTickResponse {
    return CancelTickResponseJSON._readMessage(
      CancelTickResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CancelTickResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CancelTickResponse>): CancelTickResponse {
    return {
      plan: PlanJSON.initialize(),
      tick: TickJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelTickResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    if (msg.tick) {
      const _tick_ = TickJSON._writeMessage(msg.tick);
      if (Object.keys(_tick_).length > 0) {
        json["tick"] = _tick_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelTickResponse,
    json: any,
  ): CancelTickResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    const _tick_ = json["tick"];
    if (_tick_) {
      TickJSON._readMessage(msg.tick, _tick_);
    }
    return msg;
  },
};

export const ListBalancesRequestJSON = {
  /**
   * Serializes ListBalancesRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<ListBalancesRequest>): string {
    return "{}";
  },

  /**
   * Deserializes ListBalancesRequest from JSON.
   */
  decode: function (_json?: string): ListBalancesRequest {
    return {};
  },

  /**
   * Initializes ListBalancesRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListBalancesRequest>,
  ): ListBalancesRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<ListBalancesRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListBalancesRequest,
    _json: any,
  ): ListBalancesRequest {
    return msg;
  },
};

export const BalanceJSON = {
  /**
   * Serializes Balance to JSON.
   */
  encode: function (msg: PartialDeep<Balance>): string {
    return JSON.stringify(BalanceJSON._writeMessage(msg));
  },

  /**
   * Deserializes Balance from JSON.
   */
  decode: function (json: string): Balance {
    return BalanceJSON._readMessage(BalanceJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Balance with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Balance>): Balance {
    return {
      assetId: "",
      amount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Balance>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Balance, json: any): Balance {
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    return msg;
  },
};

export const ListBalancesResponseJSON = {
  /**
   * Serializes ListBalancesResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListBalancesResponse>): string {
    return JSON.stringify(ListBalancesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListBalancesResponse from JSON.
   */
  decode: function (json: string): ListBalancesResponse {
    return ListBalancesResponseJSON._readMessage(
      ListBalancesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListBalancesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListBalancesResponse>,
  ): ListBalancesResponse {
    return {
      balances: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListBalancesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.balances?.length) {
      json["balances"] = msg.balances.map(BalanceJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListBalancesResponse,
    json: any,
  ): ListBalancesResponse {
    const _balances_ = json["balances"];
    if (_balances_) {
      for (const item of _balances_) {
        const m = BalanceJSON.initialize();
        BalanceJSON._readMessage(m, item);
        msg.balances.push(m);
      }
    }
    return msg;
  },
};

export const PointJSON = {
  /**
   * Serializes Point to JSON.
   */
  encode: function (msg: PartialDeep<Point>): string {
    return JSON.stringify(PointJSON._writeMessage(msg));
  },

  /**
   * Deserializes Point from JSON.
   */
  decode: function (json: string): Point {
    return PointJSON._readMessage(PointJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Point with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Point>): Point {
    return {
      date: "",
      ts: "",
      paidValue: "",
      filledValue: "",
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Point>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.date) {
      json["date"] = msg.date;
    }
    if (msg.ts) {
      json["ts"] = msg.ts;
    }
    if (msg.paidValue) {
      json["paidValue"] = msg.paidValue;
    }
    if (msg.filledValue) {
      json["filledValue"] = msg.filledValue;
    }
    if (msg.price) {
      json["price"] = msg.price;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Point, json: any): Point {
    const _date_ = json["date"];
    if (_date_) {
      msg.date = _date_;
    }
    const _ts_ = json["ts"];
    if (_ts_) {
      msg.ts = _ts_;
    }
    const _paidValue_ = json["paidValue"] ?? json["paid_value"];
    if (_paidValue_) {
      msg.paidValue = _paidValue_;
    }
    const _filledValue_ = json["filledValue"] ?? json["filled_value"];
    if (_filledValue_) {
      msg.filledValue = _filledValue_;
    }
    const _price_ = json["price"];
    if (_price_) {
      msg.price = _price_;
    }
    return msg;
  },
};

export const ListStatsRequestJSON = {
  /**
   * Serializes ListStatsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListStatsRequest>): string {
    return JSON.stringify(ListStatsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListStatsRequest from JSON.
   */
  decode: function (json: string): ListStatsRequest {
    return ListStatsRequestJSON._readMessage(
      ListStatsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListStatsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListStatsRequest>): ListStatsRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListStatsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListStatsRequest, json: any): ListStatsRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    return msg;
  },
};

export const ListStatsResponseJSON = {
  /**
   * Serializes ListStatsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListStatsResponse>): string {
    return JSON.stringify(ListStatsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListStatsResponse from JSON.
   */
  decode: function (json: string): ListStatsResponse {
    return ListStatsResponseJSON._readMessage(
      ListStatsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListStatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListStatsResponse>): ListStatsResponse {
    return {
      points: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListStatsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.points?.length) {
      json["points"] = msg.points.map(PointJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListStatsResponse,
    json: any,
  ): ListStatsResponse {
    const _points_ = json["points"];
    if (_points_) {
      for (const item of _points_) {
        const m = PointJSON.initialize();
        PointJSON._readMessage(m, item);
        msg.points.push(m);
      }
    }
    return msg;
  },
};

export const GetInfoRequestJSON = {
  /**
   * Serializes GetInfoRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<GetInfoRequest>): string {
    return "{}";
  },

  /**
   * Deserializes GetInfoRequest from JSON.
   */
  decode: function (_json?: string): GetInfoRequest {
    return {};
  },

  /**
   * Initializes GetInfoRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoRequest>): GetInfoRequest {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<GetInfoRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetInfoRequest, _json: any): GetInfoRequest {
    return msg;
  },
};

export const GetInfoResponseJSON = {
  /**
   * Serializes GetInfoResponse to JSON.
   */
  encode: function (msg: PartialDeep<GetInfoResponse>): string {
    return JSON.stringify(GetInfoResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetInfoResponse from JSON.
   */
  decode: function (json: string): GetInfoResponse {
    return GetInfoResponseJSON._readMessage(
      GetInfoResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetInfoResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetInfoResponse>): GetInfoResponse {
    return {
      clientId: "",
      payAssetIds: [],
      fillAssetIds: [],
      payAssets: [],
      fillAssets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetInfoResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.clientId) {
      json["clientId"] = msg.clientId;
    }
    if (msg.payAssetIds?.length) {
      json["payAssetIds"] = msg.payAssetIds;
    }
    if (msg.fillAssetIds?.length) {
      json["fillAssetIds"] = msg.fillAssetIds;
    }
    if (msg.payAssets?.length) {
      json["payAssets"] = msg.payAssets.map(AssetJSON._writeMessage);
    }
    if (msg.fillAssets?.length) {
      json["fillAssets"] = msg.fillAssets.map(AssetJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetInfoResponse, json: any): GetInfoResponse {
    const _clientId_ = json["clientId"] ?? json["client_id"];
    if (_clientId_) {
      msg.clientId = _clientId_;
    }
    const _payAssetIds_ = json["payAssetIds"] ?? json["pay_asset_ids"];
    if (_payAssetIds_) {
      msg.payAssetIds = _payAssetIds_;
    }
    const _fillAssetIds_ = json["fillAssetIds"] ?? json["fill_asset_ids"];
    if (_fillAssetIds_) {
      msg.fillAssetIds = _fillAssetIds_;
    }
    const _payAssets_ = json["payAssets"] ?? json["pay_assets"];
    if (_payAssets_) {
      for (const item of _payAssets_) {
        const m = AssetJSON.initialize();
        AssetJSON._readMessage(m, item);
        msg.payAssets.push(m);
      }
    }
    const _fillAssets_ = json["fillAssets"] ?? json["fill_assets"];
    if (_fillAssets_) {
      for (const item of _fillAssets_) {
        const m = AssetJSON.initialize();
        AssetJSON._readMessage(m, item);
        msg.fillAssets.push(m);
      }
    }
    return msg;
  },
};

export const RefreshStatRequestJSON = {
  /**
   * Serializes RefreshStatRequest to JSON.
   */
  encode: function (msg: PartialDeep<RefreshStatRequest>): string {
    return JSON.stringify(RefreshStatRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes RefreshStatRequest from JSON.
   */
  decode: function (json: string): RefreshStatRequest {
    return RefreshStatRequestJSON._readMessage(
      RefreshStatRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RefreshStatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RefreshStatRequest>): RefreshStatRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RefreshStatRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RefreshStatRequest,
    json: any,
  ): RefreshStatRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    return msg;
  },
};

export const RefreshStatResponseJSON = {
  /**
   * Serializes RefreshStatResponse to JSON.
   */
  encode: function (_msg?: PartialDeep<RefreshStatResponse>): string {
    return "{}";
  },

  /**
   * Deserializes RefreshStatResponse from JSON.
   */
  decode: function (_json?: string): RefreshStatResponse {
    return {};
  },

  /**
   * Initializes RefreshStatResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<RefreshStatResponse>,
  ): RefreshStatResponse {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<RefreshStatResponse>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RefreshStatResponse,
    _json: any,
  ): RefreshStatResponse {
    return msg;
  },
};

export const CreateMultisigRequestJSON = {
  /**
   * Serializes CreateMultisigRequest to JSON.
   */
  encode: function (msg: PartialDeep<CreateMultisigRequest>): string {
    return JSON.stringify(CreateMultisigRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateMultisigRequest from JSON.
   */
  decode: function (json: string): CreateMultisigRequest {
    return CreateMultisigRequestJSON._readMessage(
      CreateMultisigRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateMultisigRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateMultisigRequest>,
  ): CreateMultisigRequest {
    return {
      payment: PaymentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateMultisigRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.payment) {
      const _payment_ = PaymentJSON._writeMessage(msg.payment);
      if (Object.keys(_payment_).length > 0) {
        json["payment"] = _payment_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateMultisigRequest,
    json: any,
  ): CreateMultisigRequest {
    const _payment_ = json["payment"];
    if (_payment_) {
      PaymentJSON._readMessage(msg.payment, _payment_);
    }
    return msg;
  },
};

export const CreateMultisigResponseJSON = {
  /**
   * Serializes CreateMultisigResponse to JSON.
   */
  encode: function (msg: PartialDeep<CreateMultisigResponse>): string {
    return JSON.stringify(CreateMultisigResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateMultisigResponse from JSON.
   */
  decode: function (json: string): CreateMultisigResponse {
    return CreateMultisigResponseJSON._readMessage(
      CreateMultisigResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateMultisigResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateMultisigResponse>,
  ): CreateMultisigResponse {
    return {
      requestId: "",
      txHash: "",
      assetId: "",
      assetHash: "",
      amount: "",
      extra: "",
      rawTx: "",
      senders: [],
      signers: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateMultisigResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requestId) {
      json["requestId"] = msg.requestId;
    }
    if (msg.txHash) {
      json["txHash"] = msg.txHash;
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.assetHash) {
      json["assetHash"] = msg.assetHash;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.extra) {
      json["extra"] = msg.extra;
    }
    if (msg.rawTx) {
      json["rawTx"] = msg.rawTx;
    }
    if (msg.senders?.length) {
      json["senders"] = msg.senders;
    }
    if (msg.signers?.length) {
      json["signers"] = msg.signers;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateMultisigResponse,
    json: any,
  ): CreateMultisigResponse {
    const _requestId_ = json["requestId"] ?? json["request_id"];
    if (_requestId_) {
      msg.requestId = _requestId_;
    }
    const _txHash_ = json["txHash"] ?? json["tx_hash"];
    if (_txHash_) {
      msg.txHash = _txHash_;
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _assetHash_ = json["assetHash"] ?? json["asset_hash"];
    if (_assetHash_) {
      msg.assetHash = _assetHash_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _extra_ = json["extra"];
    if (_extra_) {
      msg.extra = _extra_;
    }
    const _rawTx_ = json["rawTx"] ?? json["raw_tx"];
    if (_rawTx_) {
      msg.rawTx = _rawTx_;
    }
    const _senders_ = json["senders"];
    if (_senders_) {
      msg.senders = _senders_;
    }
    const _signers_ = json["signers"];
    if (_signers_) {
      msg.signers = _signers_;
    }
    return msg;
  },
};

export const ListTicksRequestJSON = {
  /**
   * Serializes ListTicksRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListTicksRequest>): string {
    return JSON.stringify(ListTicksRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTicksRequest from JSON.
   */
  decode: function (json: string): ListTicksRequest {
    return ListTicksRequestJSON._readMessage(
      ListTicksRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTicksRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTicksRequest>): ListTicksRequest {
    return {
      planId: "",
      offset: "",
      limit: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTicksRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    if (msg.offset) {
      json["offset"] = msg.offset;
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListTicksRequest, json: any): ListTicksRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = _offset_;
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    return msg;
  },
};

export const ListTicksResponseJSON = {
  /**
   * Serializes ListTicksResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListTicksResponse>): string {
    return JSON.stringify(ListTicksResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTicksResponse from JSON.
   */
  decode: function (json: string): ListTicksResponse {
    return ListTicksResponseJSON._readMessage(
      ListTicksResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTicksResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTicksResponse>): ListTicksResponse {
    return {
      ticks: [],
      nextOffset: "",
      hasNext: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTicksResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ticks?.length) {
      json["ticks"] = msg.ticks.map(TickJSON._writeMessage);
    }
    if (msg.nextOffset) {
      json["nextOffset"] = msg.nextOffset;
    }
    if (msg.hasNext) {
      json["hasNext"] = msg.hasNext;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTicksResponse,
    json: any,
  ): ListTicksResponse {
    const _ticks_ = json["ticks"];
    if (_ticks_) {
      for (const item of _ticks_) {
        const m = TickJSON.initialize();
        TickJSON._readMessage(m, item);
        msg.ticks.push(m);
      }
    }
    const _nextOffset_ = json["nextOffset"] ?? json["next_offset"];
    if (_nextOffset_) {
      msg.nextOffset = _nextOffset_;
    }
    const _hasNext_ = json["hasNext"] ?? json["has_next"];
    if (_hasNext_) {
      msg.hasNext = _hasNext_;
    }
    return msg;
  },
};

export const ReadRankingListRequestJSON = {
  /**
   * Serializes ReadRankingListRequest to JSON.
   */
  encode: function (msg: PartialDeep<ReadRankingListRequest>): string {
    return JSON.stringify(ReadRankingListRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ReadRankingListRequest from JSON.
   */
  decode: function (json: string): ReadRankingListRequest {
    return ReadRankingListRequestJSON._readMessage(
      ReadRankingListRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ReadRankingListRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ReadRankingListRequest>,
  ): ReadRankingListRequest {
    return {
      id: "",
      page: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReadRankingListRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.count) {
      json["count"] = msg.count;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReadRankingListRequest,
    json: any,
  ): ReadRankingListRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _count_ = json["count"];
    if (_count_) {
      msg.count = protoscript.parseNumber(_count_);
    }
    return msg;
  },
};

export const PlanStatJSON = {
  /**
   * Serializes PlanStat to JSON.
   */
  encode: function (msg: PartialDeep<PlanStat>): string {
    return JSON.stringify(PlanStatJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlanStat from JSON.
   */
  decode: function (json: string): PlanStat {
    return PlanStatJSON._readMessage(
      PlanStatJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlanStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlanStat>): PlanStat {
    return {
      plan: PlanJSON.initialize(),
      paidValue: "",
      filledValue: "",
      rate: "",
      extra: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlanStat>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    if (msg.paidValue) {
      json["paidValue"] = msg.paidValue;
    }
    if (msg.filledValue) {
      json["filledValue"] = msg.filledValue;
    }
    if (msg.rate) {
      json["rate"] = msg.rate;
    }
    if (msg.extra) {
      json["extra"] = msg.extra;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PlanStat, json: any): PlanStat {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    const _paidValue_ = json["paidValue"] ?? json["paid_value"];
    if (_paidValue_) {
      msg.paidValue = _paidValue_;
    }
    const _filledValue_ = json["filledValue"] ?? json["filled_value"];
    if (_filledValue_) {
      msg.filledValue = _filledValue_;
    }
    const _rate_ = json["rate"];
    if (_rate_) {
      msg.rate = _rate_;
    }
    const _extra_ = json["extra"];
    if (_extra_) {
      msg.extra = _extra_;
    }
    return msg;
  },
};

export const ReadRankingListResponseJSON = {
  /**
   * Serializes ReadRankingListResponse to JSON.
   */
  encode: function (msg: PartialDeep<ReadRankingListResponse>): string {
    return JSON.stringify(ReadRankingListResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ReadRankingListResponse from JSON.
   */
  decode: function (json: string): ReadRankingListResponse {
    return ReadRankingListResponseJSON._readMessage(
      ReadRankingListResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ReadRankingListResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ReadRankingListResponse>,
  ): ReadRankingListResponse {
    return {
      id: "",
      name: "",
      updatedAt: "",
      updatedTs: "",
      plans: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReadRankingListResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.updatedAt) {
      json["updatedAt"] = msg.updatedAt;
    }
    if (msg.updatedTs) {
      json["updatedTs"] = msg.updatedTs;
    }
    if (msg.plans?.length) {
      json["plans"] = msg.plans.map(PlanStatJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReadRankingListResponse,
    json: any,
  ): ReadRankingListResponse {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = _updatedAt_;
    }
    const _updatedTs_ = json["updatedTs"] ?? json["updated_ts"];
    if (_updatedTs_) {
      msg.updatedTs = _updatedTs_;
    }
    const _plans_ = json["plans"];
    if (_plans_) {
      for (const item of _plans_) {
        const m = PlanStatJSON.initialize();
        PlanStatJSON._readMessage(m, item);
        msg.plans.push(m);
      }
    }
    return msg;
  },
};

export const CopyPlanRequestJSON = {
  /**
   * Serializes CopyPlanRequest to JSON.
   */
  encode: function (msg: PartialDeep<CopyPlanRequest>): string {
    return JSON.stringify(CopyPlanRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CopyPlanRequest from JSON.
   */
  decode: function (json: string): CopyPlanRequest {
    return CopyPlanRequestJSON._readMessage(
      CopyPlanRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CopyPlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CopyPlanRequest>): CopyPlanRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CopyPlanRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CopyPlanRequest, json: any): CopyPlanRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    return msg;
  },
};

export const CopyPlanResponseJSON = {
  /**
   * Serializes CopyPlanResponse to JSON.
   */
  encode: function (msg: PartialDeep<CopyPlanResponse>): string {
    return JSON.stringify(CopyPlanResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CopyPlanResponse from JSON.
   */
  decode: function (json: string): CopyPlanResponse {
    return CopyPlanResponseJSON._readMessage(
      CopyPlanResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CopyPlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CopyPlanResponse>): CopyPlanResponse {
    return {
      plan: PlanJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CopyPlanResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CopyPlanResponse, json: any): CopyPlanResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    return msg;
  },
};

export const FindPlanRequestJSON = {
  /**
   * Serializes FindPlanRequest to JSON.
   */
  encode: function (msg: PartialDeep<FindPlanRequest>): string {
    return JSON.stringify(FindPlanRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindPlanRequest from JSON.
   */
  decode: function (json: string): FindPlanRequest {
    return FindPlanRequestJSON._readMessage(
      FindPlanRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindPlanRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPlanRequest>): FindPlanRequest {
    return {
      planId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPlanRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.planId) {
      json["planId"] = msg.planId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindPlanRequest, json: any): FindPlanRequest {
    const _planId_ = json["planId"] ?? json["plan_id"];
    if (_planId_) {
      msg.planId = _planId_;
    }
    return msg;
  },
};

export const FindPlanResponseJSON = {
  /**
   * Serializes FindPlanResponse to JSON.
   */
  encode: function (msg: PartialDeep<FindPlanResponse>): string {
    return JSON.stringify(FindPlanResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes FindPlanResponse from JSON.
   */
  decode: function (json: string): FindPlanResponse {
    return FindPlanResponseJSON._readMessage(
      FindPlanResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FindPlanResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FindPlanResponse>): FindPlanResponse {
    return {
      plan: PlanJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FindPlanResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.plan) {
      const _plan_ = PlanJSON._writeMessage(msg.plan);
      if (Object.keys(_plan_).length > 0) {
        json["plan"] = _plan_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FindPlanResponse, json: any): FindPlanResponse {
    const _plan_ = json["plan"];
    if (_plan_) {
      PlanJSON._readMessage(msg.plan, _plan_);
    }
    return msg;
  },
};
