// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: pando/v1/pando.proto
/* eslint-disable */

import type { ByteSource, ClientConfiguration } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import { Timestamp, TimestampJSON } from "../../google/protobuf/timestamp.pb";

//========================================//
//         Pando Protobuf Client          //
//========================================//

/**
 * assets
 */
export async function FindAsset(
  findAsset: Req.FindAsset,
  config?: ClientConfiguration
): Promise<Asset> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindAsset",
    Req.FindAsset.encode(findAsset),
    config
  );
  return Asset.decode(response);
}

export async function ListAssets(
  listAssets: Req.ListAssets,
  config?: ClientConfiguration
): Promise<Resp.ListAssets> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAssets",
    Req.ListAssets.encode(listAssets),
    config
  );
  return Resp.ListAssets.decode(response);
}

/**
 * oracles
 */
export async function FindOracle(
  findOracle: Req.FindOracle,
  config?: ClientConfiguration
): Promise<Oracle> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindOracle",
    Req.FindOracle.encode(findOracle),
    config
  );
  return Oracle.decode(response);
}

export async function ListOracles(
  listOracles: Req.ListOracles,
  config?: ClientConfiguration
): Promise<Resp.ListOracles> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListOracles",
    Req.ListOracles.encode(listOracles),
    config
  );
  return Resp.ListOracles.decode(response);
}

/**
 * collaterals
 */
export async function ListCollaterals(
  listCollaterals: Req.ListCollaterals,
  config?: ClientConfiguration
): Promise<Resp.ListCollaterals> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListCollaterals",
    Req.ListCollaterals.encode(listCollaterals),
    config
  );
  return Resp.ListCollaterals.decode(response);
}

export async function FindCollateral(
  findCollateral: Req.FindCollateral,
  config?: ClientConfiguration
): Promise<Collateral> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindCollateral",
    Req.FindCollateral.encode(findCollateral),
    config
  );
  return Collateral.decode(response);
}

/**
 * vaults
 */
export async function FindVault(
  findVault: Req.FindVault,
  config?: ClientConfiguration
): Promise<Vault> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindVault",
    Req.FindVault.encode(findVault),
    config
  );
  return Vault.decode(response);
}

export async function ListVaults(
  listVaults: Req.ListVaults,
  config?: ClientConfiguration
): Promise<Resp.ListVaults> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListVaults",
    Req.ListVaults.encode(listVaults),
    config
  );
  return Resp.ListVaults.decode(response);
}

export async function ListMyVaults(
  listMyVaults: Req.ListMyVaults,
  config?: ClientConfiguration
): Promise<Resp.ListMyVaults> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListMyVaults",
    Req.ListMyVaults.encode(listMyVaults),
    config
  );
  return Resp.ListMyVaults.decode(response);
}

export async function ListVaultEvents(
  listVaultEvents: Req.ListVaultEvents,
  config?: ClientConfiguration
): Promise<Resp.ListVaultEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListVaultEvents",
    Req.ListVaultEvents.encode(listVaultEvents),
    config
  );
  return Resp.ListVaultEvents.decode(response);
}

export async function QueryVaultEvents(
  queryVaultEvents: Req.QueryVaultEvents,
  config?: ClientConfiguration
): Promise<Resp.QueryVaultEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/QueryVaultEvents",
    Req.QueryVaultEvents.encode(queryVaultEvents),
    config
  );
  return Resp.QueryVaultEvents.decode(response);
}

/**
 * flips
 */
export async function FindFlip(
  findFlip: Req.FindFlip,
  config?: ClientConfiguration
): Promise<Flip> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindFlip",
    Req.FindFlip.encode(findFlip),
    config
  );
  return Flip.decode(response);
}

export async function ListFlips(
  listFlips: Req.ListFlips,
  config?: ClientConfiguration
): Promise<Resp.ListFlips> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListFlips",
    Req.ListFlips.encode(listFlips),
    config
  );
  return Resp.ListFlips.decode(response);
}

export async function ListFlipEvents(
  listFlipEvents: Req.ListFlipEvents,
  config?: ClientConfiguration
): Promise<Resp.ListFlipEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListFlipEvents",
    Req.ListFlipEvents.encode(listFlipEvents),
    config
  );
  return Resp.ListFlipEvents.decode(response);
}

export async function QueryFlips(
  queryFlips: Req.QueryFlips,
  config?: ClientConfiguration
): Promise<Resp.QueryFlips> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/QueryFlips",
    Req.QueryFlips.encode(queryFlips),
    config
  );
  return Resp.QueryFlips.decode(response);
}

/**
 * tx
 */
export async function FindTransaction(
  findTransaction: Req.FindTransaction,
  config?: ClientConfiguration
): Promise<Transaction> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindTransaction",
    Req.FindTransaction.encode(findTransaction),
    config
  );
  return Transaction.decode(response);
}

export async function ListTransactions(
  listTransactions: Req.ListTransactions,
  config?: ClientConfiguration
): Promise<Resp.ListTransactions> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListTransactions",
    Req.ListTransactions.encode(listTransactions),
    config
  );
  return Resp.ListTransactions.decode(response);
}

/**
 * proposals
 */
export async function FindProposal(
  findProposal: Req.FindProposal,
  config?: ClientConfiguration
): Promise<Proposal> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindProposal",
    Req.FindProposal.encode(findProposal),
    config
  );
  return Proposal.decode(response);
}

export async function ListProposals(
  listProposals: Req.ListProposals,
  config?: ClientConfiguration
): Promise<Resp.ListProposals> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListProposals",
    Req.ListProposals.encode(listProposals),
    config
  );
  return Resp.ListProposals.decode(response);
}

/**
 * stats
 */
export async function ListStats(
  listStats: Req.ListStats,
  config?: ClientConfiguration
): Promise<Resp.ListStats> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListStats",
    Req.ListStats.encode(listStats),
    config
  );
  return Resp.ListStats.decode(response);
}

export async function ListAggregatedStats(
  listAggregatedStats: Req.ListAggregatedStats,
  config?: ClientConfiguration
): Promise<Resp.ListAggregatedStats> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAggregatedStats",
    Req.ListAggregatedStats.encode(listAggregatedStats),
    config
  );
  return Resp.ListAggregatedStats.decode(response);
}

/**
 * info
 */
export async function GetInfo(
  getInfo: Req.GetInfo,
  config?: ClientConfiguration
): Promise<Resp.GetInfo> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/GetInfo",
    Req.GetInfo.encode(getInfo),
    config
  );
  return Resp.GetInfo.decode(response);
}

/**
 * audit
 */
export async function ListAudit(
  listAudit: Req.ListAudit,
  config?: ClientConfiguration
): Promise<Resp.ListAudit> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAudit",
    Req.ListAudit.encode(listAudit),
    config
  );
  return Resp.ListAudit.decode(response);
}

//========================================//
//           Pando JSON Client            //
//========================================//

/**
 * assets
 */
export async function FindAssetJSON(
  findAsset: Req.FindAsset,
  config?: ClientConfiguration
): Promise<Asset> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindAsset",
    ReqJSON.FindAsset.encode(findAsset),
    config
  );
  return AssetJSON.decode(response);
}

export async function ListAssetsJSON(
  listAssets: Req.ListAssets,
  config?: ClientConfiguration
): Promise<Resp.ListAssets> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAssets",
    ReqJSON.ListAssets.encode(listAssets),
    config
  );
  return RespJSON.ListAssets.decode(response);
}

/**
 * oracles
 */
export async function FindOracleJSON(
  findOracle: Req.FindOracle,
  config?: ClientConfiguration
): Promise<Oracle> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindOracle",
    ReqJSON.FindOracle.encode(findOracle),
    config
  );
  return OracleJSON.decode(response);
}

export async function ListOraclesJSON(
  listOracles: Req.ListOracles,
  config?: ClientConfiguration
): Promise<Resp.ListOracles> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListOracles",
    ReqJSON.ListOracles.encode(listOracles),
    config
  );
  return RespJSON.ListOracles.decode(response);
}

/**
 * collaterals
 */
export async function ListCollateralsJSON(
  listCollaterals: Req.ListCollaterals,
  config?: ClientConfiguration
): Promise<Resp.ListCollaterals> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListCollaterals",
    ReqJSON.ListCollaterals.encode(listCollaterals),
    config
  );
  return RespJSON.ListCollaterals.decode(response);
}

export async function FindCollateralJSON(
  findCollateral: Req.FindCollateral,
  config?: ClientConfiguration
): Promise<Collateral> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindCollateral",
    ReqJSON.FindCollateral.encode(findCollateral),
    config
  );
  return CollateralJSON.decode(response);
}

/**
 * vaults
 */
export async function FindVaultJSON(
  findVault: Req.FindVault,
  config?: ClientConfiguration
): Promise<Vault> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindVault",
    ReqJSON.FindVault.encode(findVault),
    config
  );
  return VaultJSON.decode(response);
}

export async function ListVaultsJSON(
  listVaults: Req.ListVaults,
  config?: ClientConfiguration
): Promise<Resp.ListVaults> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListVaults",
    ReqJSON.ListVaults.encode(listVaults),
    config
  );
  return RespJSON.ListVaults.decode(response);
}

export async function ListMyVaultsJSON(
  listMyVaults: Req.ListMyVaults,
  config?: ClientConfiguration
): Promise<Resp.ListMyVaults> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListMyVaults",
    ReqJSON.ListMyVaults.encode(listMyVaults),
    config
  );
  return RespJSON.ListMyVaults.decode(response);
}

export async function ListVaultEventsJSON(
  listVaultEvents: Req.ListVaultEvents,
  config?: ClientConfiguration
): Promise<Resp.ListVaultEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListVaultEvents",
    ReqJSON.ListVaultEvents.encode(listVaultEvents),
    config
  );
  return RespJSON.ListVaultEvents.decode(response);
}

export async function QueryVaultEventsJSON(
  queryVaultEvents: Req.QueryVaultEvents,
  config?: ClientConfiguration
): Promise<Resp.QueryVaultEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/QueryVaultEvents",
    ReqJSON.QueryVaultEvents.encode(queryVaultEvents),
    config
  );
  return RespJSON.QueryVaultEvents.decode(response);
}

/**
 * flips
 */
export async function FindFlipJSON(
  findFlip: Req.FindFlip,
  config?: ClientConfiguration
): Promise<Flip> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindFlip",
    ReqJSON.FindFlip.encode(findFlip),
    config
  );
  return FlipJSON.decode(response);
}

export async function ListFlipsJSON(
  listFlips: Req.ListFlips,
  config?: ClientConfiguration
): Promise<Resp.ListFlips> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListFlips",
    ReqJSON.ListFlips.encode(listFlips),
    config
  );
  return RespJSON.ListFlips.decode(response);
}

export async function ListFlipEventsJSON(
  listFlipEvents: Req.ListFlipEvents,
  config?: ClientConfiguration
): Promise<Resp.ListFlipEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListFlipEvents",
    ReqJSON.ListFlipEvents.encode(listFlipEvents),
    config
  );
  return RespJSON.ListFlipEvents.decode(response);
}

export async function QueryFlipsJSON(
  queryFlips: Req.QueryFlips,
  config?: ClientConfiguration
): Promise<Resp.QueryFlips> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/QueryFlips",
    ReqJSON.QueryFlips.encode(queryFlips),
    config
  );
  return RespJSON.QueryFlips.decode(response);
}

/**
 * tx
 */
export async function FindTransactionJSON(
  findTransaction: Req.FindTransaction,
  config?: ClientConfiguration
): Promise<Transaction> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindTransaction",
    ReqJSON.FindTransaction.encode(findTransaction),
    config
  );
  return TransactionJSON.decode(response);
}

export async function ListTransactionsJSON(
  listTransactions: Req.ListTransactions,
  config?: ClientConfiguration
): Promise<Resp.ListTransactions> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListTransactions",
    ReqJSON.ListTransactions.encode(listTransactions),
    config
  );
  return RespJSON.ListTransactions.decode(response);
}

/**
 * proposals
 */
export async function FindProposalJSON(
  findProposal: Req.FindProposal,
  config?: ClientConfiguration
): Promise<Proposal> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindProposal",
    ReqJSON.FindProposal.encode(findProposal),
    config
  );
  return ProposalJSON.decode(response);
}

export async function ListProposalsJSON(
  listProposals: Req.ListProposals,
  config?: ClientConfiguration
): Promise<Resp.ListProposals> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListProposals",
    ReqJSON.ListProposals.encode(listProposals),
    config
  );
  return RespJSON.ListProposals.decode(response);
}

/**
 * stats
 */
export async function ListStatsJSON(
  listStats: Req.ListStats,
  config?: ClientConfiguration
): Promise<Resp.ListStats> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListStats",
    ReqJSON.ListStats.encode(listStats),
    config
  );
  return RespJSON.ListStats.decode(response);
}

export async function ListAggregatedStatsJSON(
  listAggregatedStats: Req.ListAggregatedStats,
  config?: ClientConfiguration
): Promise<Resp.ListAggregatedStats> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAggregatedStats",
    ReqJSON.ListAggregatedStats.encode(listAggregatedStats),
    config
  );
  return RespJSON.ListAggregatedStats.decode(response);
}

/**
 * info
 */
export async function GetInfoJSON(
  getInfo: Req.GetInfo,
  config?: ClientConfiguration
): Promise<Resp.GetInfo> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/GetInfo",
    ReqJSON.GetInfo.encode(getInfo),
    config
  );
  return RespJSON.GetInfo.decode(response);
}

/**
 * audit
 */
export async function ListAuditJSON(
  listAudit: Req.ListAudit,
  config?: ClientConfiguration
): Promise<Resp.ListAudit> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAudit",
    ReqJSON.ListAudit.encode(listAudit),
    config
  );
  return RespJSON.ListAudit.decode(response);
}

//========================================//
//                 Pando                  //
//========================================//

export interface Pando<Context = unknown> {
  /**
   * assets
   */
  FindAsset: (
    findAsset: Req.FindAsset,
    context: Context
  ) => Promise<Asset> | Asset;
  ListAssets: (
    listAssets: Req.ListAssets,
    context: Context
  ) => Promise<Resp.ListAssets> | Resp.ListAssets;
  /**
   * oracles
   */
  FindOracle: (
    findOracle: Req.FindOracle,
    context: Context
  ) => Promise<Oracle> | Oracle;
  ListOracles: (
    listOracles: Req.ListOracles,
    context: Context
  ) => Promise<Resp.ListOracles> | Resp.ListOracles;
  /**
   * collaterals
   */
  ListCollaterals: (
    listCollaterals: Req.ListCollaterals,
    context: Context
  ) => Promise<Resp.ListCollaterals> | Resp.ListCollaterals;
  FindCollateral: (
    findCollateral: Req.FindCollateral,
    context: Context
  ) => Promise<Collateral> | Collateral;
  /**
   * vaults
   */
  FindVault: (
    findVault: Req.FindVault,
    context: Context
  ) => Promise<Vault> | Vault;
  ListVaults: (
    listVaults: Req.ListVaults,
    context: Context
  ) => Promise<Resp.ListVaults> | Resp.ListVaults;
  ListMyVaults: (
    listMyVaults: Req.ListMyVaults,
    context: Context
  ) => Promise<Resp.ListMyVaults> | Resp.ListMyVaults;
  ListVaultEvents: (
    listVaultEvents: Req.ListVaultEvents,
    context: Context
  ) => Promise<Resp.ListVaultEvents> | Resp.ListVaultEvents;
  QueryVaultEvents: (
    queryVaultEvents: Req.QueryVaultEvents,
    context: Context
  ) => Promise<Resp.QueryVaultEvents> | Resp.QueryVaultEvents;
  /**
   * flips
   */
  FindFlip: (findFlip: Req.FindFlip, context: Context) => Promise<Flip> | Flip;
  ListFlips: (
    listFlips: Req.ListFlips,
    context: Context
  ) => Promise<Resp.ListFlips> | Resp.ListFlips;
  ListFlipEvents: (
    listFlipEvents: Req.ListFlipEvents,
    context: Context
  ) => Promise<Resp.ListFlipEvents> | Resp.ListFlipEvents;
  QueryFlips: (
    queryFlips: Req.QueryFlips,
    context: Context
  ) => Promise<Resp.QueryFlips> | Resp.QueryFlips;
  /**
   * tx
   */
  FindTransaction: (
    findTransaction: Req.FindTransaction,
    context: Context
  ) => Promise<Transaction> | Transaction;
  ListTransactions: (
    listTransactions: Req.ListTransactions,
    context: Context
  ) => Promise<Resp.ListTransactions> | Resp.ListTransactions;
  /**
   * proposals
   */
  FindProposal: (
    findProposal: Req.FindProposal,
    context: Context
  ) => Promise<Proposal> | Proposal;
  ListProposals: (
    listProposals: Req.ListProposals,
    context: Context
  ) => Promise<Resp.ListProposals> | Resp.ListProposals;
  /**
   * stats
   */
  ListStats: (
    listStats: Req.ListStats,
    context: Context
  ) => Promise<Resp.ListStats> | Resp.ListStats;
  ListAggregatedStats: (
    listAggregatedStats: Req.ListAggregatedStats,
    context: Context
  ) => Promise<Resp.ListAggregatedStats> | Resp.ListAggregatedStats;
  /**
   * info
   */
  GetInfo: (
    getInfo: Req.GetInfo,
    context: Context
  ) => Promise<Resp.GetInfo> | Resp.GetInfo;
  /**
   * audit
   */
  ListAudit: (
    listAudit: Req.ListAudit,
    context: Context
  ) => Promise<Resp.ListAudit> | Resp.ListAudit;
}

export function createPando<Context>(service: Pando<Context>) {
  return {
    name: "fox.pando.service.Pando",
    methods: {
      FindAsset: {
        name: "FindAsset",
        handler: service.FindAsset,
        input: { protobuf: Req.FindAsset, json: ReqJSON.FindAsset },
        output: { protobuf: Asset, json: AssetJSON },
      },
      ListAssets: {
        name: "ListAssets",
        handler: service.ListAssets,
        input: { protobuf: Req.ListAssets, json: ReqJSON.ListAssets },
        output: { protobuf: Resp.ListAssets, json: RespJSON.ListAssets },
      },
      FindOracle: {
        name: "FindOracle",
        handler: service.FindOracle,
        input: { protobuf: Req.FindOracle, json: ReqJSON.FindOracle },
        output: { protobuf: Oracle, json: OracleJSON },
      },
      ListOracles: {
        name: "ListOracles",
        handler: service.ListOracles,
        input: { protobuf: Req.ListOracles, json: ReqJSON.ListOracles },
        output: { protobuf: Resp.ListOracles, json: RespJSON.ListOracles },
      },
      ListCollaterals: {
        name: "ListCollaterals",
        handler: service.ListCollaterals,
        input: { protobuf: Req.ListCollaterals, json: ReqJSON.ListCollaterals },
        output: {
          protobuf: Resp.ListCollaterals,
          json: RespJSON.ListCollaterals,
        },
      },
      FindCollateral: {
        name: "FindCollateral",
        handler: service.FindCollateral,
        input: { protobuf: Req.FindCollateral, json: ReqJSON.FindCollateral },
        output: { protobuf: Collateral, json: CollateralJSON },
      },
      FindVault: {
        name: "FindVault",
        handler: service.FindVault,
        input: { protobuf: Req.FindVault, json: ReqJSON.FindVault },
        output: { protobuf: Vault, json: VaultJSON },
      },
      ListVaults: {
        name: "ListVaults",
        handler: service.ListVaults,
        input: { protobuf: Req.ListVaults, json: ReqJSON.ListVaults },
        output: { protobuf: Resp.ListVaults, json: RespJSON.ListVaults },
      },
      ListMyVaults: {
        name: "ListMyVaults",
        handler: service.ListMyVaults,
        input: { protobuf: Req.ListMyVaults, json: ReqJSON.ListMyVaults },
        output: { protobuf: Resp.ListMyVaults, json: RespJSON.ListMyVaults },
      },
      ListVaultEvents: {
        name: "ListVaultEvents",
        handler: service.ListVaultEvents,
        input: { protobuf: Req.ListVaultEvents, json: ReqJSON.ListVaultEvents },
        output: {
          protobuf: Resp.ListVaultEvents,
          json: RespJSON.ListVaultEvents,
        },
      },
      QueryVaultEvents: {
        name: "QueryVaultEvents",
        handler: service.QueryVaultEvents,
        input: {
          protobuf: Req.QueryVaultEvents,
          json: ReqJSON.QueryVaultEvents,
        },
        output: {
          protobuf: Resp.QueryVaultEvents,
          json: RespJSON.QueryVaultEvents,
        },
      },
      FindFlip: {
        name: "FindFlip",
        handler: service.FindFlip,
        input: { protobuf: Req.FindFlip, json: ReqJSON.FindFlip },
        output: { protobuf: Flip, json: FlipJSON },
      },
      ListFlips: {
        name: "ListFlips",
        handler: service.ListFlips,
        input: { protobuf: Req.ListFlips, json: ReqJSON.ListFlips },
        output: { protobuf: Resp.ListFlips, json: RespJSON.ListFlips },
      },
      ListFlipEvents: {
        name: "ListFlipEvents",
        handler: service.ListFlipEvents,
        input: { protobuf: Req.ListFlipEvents, json: ReqJSON.ListFlipEvents },
        output: {
          protobuf: Resp.ListFlipEvents,
          json: RespJSON.ListFlipEvents,
        },
      },
      QueryFlips: {
        name: "QueryFlips",
        handler: service.QueryFlips,
        input: { protobuf: Req.QueryFlips, json: ReqJSON.QueryFlips },
        output: { protobuf: Resp.QueryFlips, json: RespJSON.QueryFlips },
      },
      FindTransaction: {
        name: "FindTransaction",
        handler: service.FindTransaction,
        input: { protobuf: Req.FindTransaction, json: ReqJSON.FindTransaction },
        output: { protobuf: Transaction, json: TransactionJSON },
      },
      ListTransactions: {
        name: "ListTransactions",
        handler: service.ListTransactions,
        input: {
          protobuf: Req.ListTransactions,
          json: ReqJSON.ListTransactions,
        },
        output: {
          protobuf: Resp.ListTransactions,
          json: RespJSON.ListTransactions,
        },
      },
      FindProposal: {
        name: "FindProposal",
        handler: service.FindProposal,
        input: { protobuf: Req.FindProposal, json: ReqJSON.FindProposal },
        output: { protobuf: Proposal, json: ProposalJSON },
      },
      ListProposals: {
        name: "ListProposals",
        handler: service.ListProposals,
        input: { protobuf: Req.ListProposals, json: ReqJSON.ListProposals },
        output: { protobuf: Resp.ListProposals, json: RespJSON.ListProposals },
      },
      ListStats: {
        name: "ListStats",
        handler: service.ListStats,
        input: { protobuf: Req.ListStats, json: ReqJSON.ListStats },
        output: { protobuf: Resp.ListStats, json: RespJSON.ListStats },
      },
      ListAggregatedStats: {
        name: "ListAggregatedStats",
        handler: service.ListAggregatedStats,
        input: {
          protobuf: Req.ListAggregatedStats,
          json: ReqJSON.ListAggregatedStats,
        },
        output: {
          protobuf: Resp.ListAggregatedStats,
          json: RespJSON.ListAggregatedStats,
        },
      },
      GetInfo: {
        name: "GetInfo",
        handler: service.GetInfo,
        input: { protobuf: Req.GetInfo, json: ReqJSON.GetInfo },
        output: { protobuf: Resp.GetInfo, json: RespJSON.GetInfo },
      },
      ListAudit: {
        name: "ListAudit",
        handler: service.ListAudit,
        input: { protobuf: Req.ListAudit, json: ReqJSON.ListAudit },
        output: { protobuf: Resp.ListAudit, json: RespJSON.ListAudit },
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "_"
  | "SysWithdraw"
  | "ActionSysProperty"
  | "ProposalMake"
  | "ProposalShout"
  | "ProposalVote"
  | "CatCreate"
  | "CatSupply"
  | "CatEdit"
  | "CatFold"
  | "CatMove"
  | "CatGain"
  | "CatFill"
  | "VatOpen"
  | "VatDeposit"
  | "VatWithdraw"
  | "VatPayback"
  | "VatGenerate"
  | "FlipKick"
  | "FlipBid"
  | "FlipDeal"
  | "OracleCreate"
  | "OracleEdit"
  | "OraclePoke"
  | "OracleRely"
  | "OracleDeny";

export interface Pagination {
  nextCursor: string;
  hasNext: boolean;
}

export interface Asset {
  /**
   * mixin asset id
   */
  id: string;
  name: string;
  symbol: string;
  logo: string;
  chainId: string;
  chain: Asset;
  price: string;
}

export interface Collateral {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  name: string;
  gem: string;
  dai: string;
  ink: string;
  art: string;
  rate: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  rho: Timestamp;
  debt: string;
  line: string;
  dust: string;
  price: string;
  mat: string;
  duty: string;
  chop: string;
  dunk: string;
  beg: string;
  ttl: number;
  tau: number;
  live: boolean;
  numberOfVaults: bigint;
  box: string;
  litter: string;
  supply: string;
}

export interface Vault {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  collateralId: string;
  ink: string;
  art: string;
  identityId: bigint;
}

export declare namespace Vault {
  export interface Event {
    vaultId: string;
    /**
     * @inject_tag: swaggertype:"string" format:"date"
     */
    createdAt: Timestamp;
    action: Action;
    dink: string;
    dart: string;
    debt: string;
    id: string;
  }
}

export interface Flip {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  tic: Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  end: Timestamp;
  bid: string;
  lot: string;
  tab: string;
  art: string;
  collateralId: string;
  vaultId: string;
  guy: string;
  action: Action;
  tags: Flip.Tag[];
}

export declare namespace Flip {
  export type Tag = "MyVault" | "Participated" | "Leading";

  export interface Event {
    flipId: string;
    /**
     * @inject_tag: swaggertype:"string" format:"date"
     */
    createdAt: Timestamp;
    action: Action;
    bid: string;
    lot: string;
    isMe: boolean;
  }
}

export interface Proposal {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  passedAt: Timestamp;
  creator: string;
  assetId: string;
  amount: string;
  action: Action;
  data: string;
  votes: string[];
  items: Proposal.Item[];
}

export declare namespace Proposal {
  export interface Item {
    key: string;
    value: string;
    hint: string;
    action: string;
  }
}

export interface Oracle {
  assetId: string;
  hop: number;
  current: string;
  next: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   * last update of current price
   */
  peekAt: Timestamp;
  threshold: number;
  governors: string[];
}

export interface Transaction {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  assetId: string;
  amount: string;
  action: Action;
  status: Transaction.Status;
  msg: string;
  parameters: string;
}

export declare namespace Transaction {
  export type Status = "Pending" | "Abort" | "OK";
}

export interface Stat {
  collateralId: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  date: Timestamp;
  timestamp: bigint;
  gem: string;
  dai: string;
  ink: string;
  debt: string;
  gemPrice: string;
  daiPrice: string;
}

export interface AggregatedStat {
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  date: Timestamp;
  timestamp: bigint;
  gemValue: string;
  daiValue: string;
}

export interface Audit {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: Timestamp;
  assetId: string;
  amount: string;
  userId: string;
  status: Audit.Status;
  memo: string;
  reviewedBy: string;
}

export declare namespace Audit {
  export type Status = "Pending" | "Rejected" | "Approved";
}

export interface Req {}

export declare namespace Req {
  export interface FindAsset {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListAssets {}

  export interface FindOracle {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListOracles {}

  /**
   * List All Collaterals
   */
  export interface ListCollaterals {}

  /**
   * Find Collateral By TraceID
   */
  export interface FindCollateral {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface FindVault {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  /**
   * List All Vaults
   */
  export interface ListVaults {
    collateralId: string;
    userId: string;
    cursor: string;
    limit: bigint;
  }

  export interface ListMyVaults {
    cursor: string;
    limit: bigint;
  }

  export interface ListVaultEvents {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface QueryVaultEvents {
    cursor: string;
    limit: bigint;
  }

  export interface FindFlip {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListFlips {
    cursor: string;
    limit: bigint;
  }

  export interface QueryFlips {
    offset: bigint;
    limit: bigint;
    phase: string;
    myVaults: string;
    myBids: string;
  }

  export interface ListFlipEvents {
    id: string;
  }

  /**
   * Find Tx By FollowID
   */
  export interface FindTransaction {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListTransactions {
    cursor: string;
    limit: bigint;
  }

  export interface ListProposals {
    cursor: string;
    limit: bigint;
  }

  export interface FindProposal {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListStats {
    /**
     * collateral id
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
    from: bigint;
    to: bigint;
  }

  export interface ListAggregatedStats {
    from: bigint;
    to: bigint;
  }

  export interface GetInfo {}

  export interface ListAudit {
    cursor: string;
    limit: bigint;
  }
}

export interface Resp {}

export declare namespace Resp {
  export interface ListAssets {
    assets: Asset[];
  }

  export interface ListOracles {
    oracles: Oracle[];
  }

  export interface ListCollaterals {
    collaterals: Collateral[];
  }

  export interface ListVaults {
    vaults: Vault[];
    pagination: Pagination;
  }

  export interface ListMyVaults {
    vaults: Vault[];
  }

  export interface ListVaultEvents {
    events: Vault.Event[];
  }

  export interface QueryVaultEvents {
    events: Vault.Event[];
    pagination: Pagination;
  }

  export interface ListFlips {
    flips: Flip[];
    pagination: Pagination;
  }

  export interface QueryFlips {
    flips: Flip[];
    total: number;
  }

  export interface ListFlipEvents {
    events: Flip.Event[];
  }

  export interface ListTransactions {
    transactions: Transaction[];
    pagination: Pagination;
  }

  export interface ListProposals {
    proposals: Proposal[];
    pagination: Pagination;
  }

  export interface ListStats {
    stats: Stat[];
  }

  export interface ListAggregatedStats {
    stats: AggregatedStat[];
  }

  export interface GetInfo {
    oauthClientId: string;
    members: string[];
    threshold: number;
    publicKey: string;
    mode: number;
    composedMode: number;
  }

  export interface ListAudit {
    audits: Audit[];
    pagination: Pagination;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  _: "_",
  /**
   * sys
   */
  SysWithdraw: "SysWithdraw",
  ActionSysProperty: "ActionSysProperty",
  /**
   * proposal
   */
  ProposalMake: "ProposalMake",
  ProposalShout: "ProposalShout",
  ProposalVote: "ProposalVote",
  /**
   * Collateral
   */
  CatCreate: "CatCreate",
  CatSupply: "CatSupply",
  CatEdit: "CatEdit",
  CatFold: "CatFold",
  CatMove: "CatMove",
  CatGain: "CatGain",
  CatFill: "CatFill",
  /**
   * Vaults
   */
  VatOpen: "VatOpen",
  VatDeposit: "VatDeposit",
  VatWithdraw: "VatWithdraw",
  VatPayback: "VatPayback",
  VatGenerate: "VatGenerate",
  /**
   * Flips
   */
  FlipKick: "FlipKick",
  FlipBid: "FlipBid",
  FlipDeal: "FlipDeal",
  /**
   * Oracles
   */
  OracleCreate: "OracleCreate",
  OracleEdit: "OracleEdit",
  OraclePoke: "OraclePoke",
  OracleRely: "OracleRely",
  OracleDeny: "OracleDeny",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "_";
      }
      case 1: {
        return "SysWithdraw";
      }
      case 2: {
        return "ActionSysProperty";
      }
      case 11: {
        return "ProposalMake";
      }
      case 12: {
        return "ProposalShout";
      }
      case 13: {
        return "ProposalVote";
      }
      case 21: {
        return "CatCreate";
      }
      case 22: {
        return "CatSupply";
      }
      case 23: {
        return "CatEdit";
      }
      case 24: {
        return "CatFold";
      }
      case 25: {
        return "CatMove";
      }
      case 26: {
        return "CatGain";
      }
      case 27: {
        return "CatFill";
      }
      case 31: {
        return "VatOpen";
      }
      case 32: {
        return "VatDeposit";
      }
      case 33: {
        return "VatWithdraw";
      }
      case 34: {
        return "VatPayback";
      }
      case 35: {
        return "VatGenerate";
      }
      case 41: {
        return "FlipKick";
      }
      case 42: {
        return "FlipBid";
      }
      case 43: {
        return "FlipDeal";
      }
      case 51: {
        return "OracleCreate";
      }
      case 52: {
        return "OracleEdit";
      }
      case 53: {
        return "OraclePoke";
      }
      case 54: {
        return "OracleRely";
      }
      case 55: {
        return "OracleDeny";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "_": {
        return 0;
      }
      case "SysWithdraw": {
        return 1;
      }
      case "ActionSysProperty": {
        return 2;
      }
      case "ProposalMake": {
        return 11;
      }
      case "ProposalShout": {
        return 12;
      }
      case "ProposalVote": {
        return 13;
      }
      case "CatCreate": {
        return 21;
      }
      case "CatSupply": {
        return 22;
      }
      case "CatEdit": {
        return 23;
      }
      case "CatFold": {
        return 24;
      }
      case "CatMove": {
        return 25;
      }
      case "CatGain": {
        return 26;
      }
      case "CatFill": {
        return 27;
      }
      case "VatOpen": {
        return 31;
      }
      case "VatDeposit": {
        return 32;
      }
      case "VatWithdraw": {
        return 33;
      }
      case "VatPayback": {
        return 34;
      }
      case "VatGenerate": {
        return 35;
      }
      case "FlipKick": {
        return 41;
      }
      case "FlipBid": {
        return 42;
      }
      case "FlipDeal": {
        return 43;
      }
      case "OracleCreate": {
        return 51;
      }
      case "OracleEdit": {
        return 52;
      }
      case "OraclePoke": {
        return 53;
      }
      case "OracleRely": {
        return 54;
      }
      case "OracleDeny": {
        return 55;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Pagination = {
  /**
   * Serializes Pagination to protobuf.
   */
  encode: function (msg: Partial<Pagination>): Uint8Array {
    return Pagination._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Pagination from protobuf.
   */
  decode: function (bytes: ByteSource): Pagination {
    return Pagination._readMessage(
      Pagination.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Pagination with all fields set to their default value.
   */
  initialize: function (): Pagination {
    return {
      nextCursor: "",
      hasNext: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Pagination>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.nextCursor) {
      writer.writeString(1, msg.nextCursor);
    }
    if (msg.hasNext) {
      writer.writeBool(2, msg.hasNext);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pagination, reader: BinaryReader): Pagination {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nextCursor = reader.readString();
          break;
        }
        case 2: {
          msg.hasNext = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Asset = {
  /**
   * Serializes Asset to protobuf.
   */
  encode: function (msg: Partial<Asset>): Uint8Array {
    return Asset._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Asset from protobuf.
   */
  decode: function (bytes: ByteSource): Asset {
    return Asset._readMessage(Asset.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (): Asset {
    return {
      id: "",
      name: "",
      symbol: "",
      logo: "",
      chainId: "",
      chain: Asset.initialize(),
      price: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Asset>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.symbol) {
      writer.writeString(3, msg.symbol);
    }
    if (msg.logo) {
      writer.writeString(4, msg.logo);
    }
    if (msg.chainId) {
      writer.writeString(5, msg.chainId);
    }
    if (msg.chain) {
      writer.writeMessage(6, msg.chain, Asset._writeMessage);
    }
    if (msg.price) {
      writer.writeString(7, msg.price);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, reader: BinaryReader): Asset {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.symbol = reader.readString();
          break;
        }
        case 4: {
          msg.logo = reader.readString();
          break;
        }
        case 5: {
          msg.chainId = reader.readString();
          break;
        }
        case 6: {
          reader.readMessage(msg.chain, Asset._readMessage);
          break;
        }
        case 7: {
          msg.price = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Collateral = {
  /**
   * Serializes Collateral to protobuf.
   */
  encode: function (msg: Partial<Collateral>): Uint8Array {
    return Collateral._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Collateral from protobuf.
   */
  decode: function (bytes: ByteSource): Collateral {
    return Collateral._readMessage(
      Collateral.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Collateral with all fields set to their default value.
   */
  initialize: function (): Collateral {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      name: "",
      gem: "",
      dai: "",
      ink: "",
      art: "",
      rate: "",
      rho: Timestamp.initialize(),
      debt: "",
      line: "",
      dust: "",
      price: "",
      mat: "",
      duty: "",
      chop: "",
      dunk: "",
      beg: "",
      ttl: 0,
      tau: 0,
      live: false,
      numberOfVaults: 0n,
      box: "",
      litter: "",
      supply: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Collateral>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.gem) {
      writer.writeString(4, msg.gem);
    }
    if (msg.dai) {
      writer.writeString(5, msg.dai);
    }
    if (msg.ink) {
      writer.writeString(6, msg.ink);
    }
    if (msg.art) {
      writer.writeString(7, msg.art);
    }
    if (msg.rate) {
      writer.writeString(8, msg.rate);
    }
    if (msg.rho) {
      writer.writeMessage(9, msg.rho, Timestamp._writeMessage);
    }
    if (msg.debt) {
      writer.writeString(10, msg.debt);
    }
    if (msg.line) {
      writer.writeString(11, msg.line);
    }
    if (msg.dust) {
      writer.writeString(12, msg.dust);
    }
    if (msg.price) {
      writer.writeString(13, msg.price);
    }
    if (msg.mat) {
      writer.writeString(14, msg.mat);
    }
    if (msg.duty) {
      writer.writeString(15, msg.duty);
    }
    if (msg.chop) {
      writer.writeString(16, msg.chop);
    }
    if (msg.dunk) {
      writer.writeString(17, msg.dunk);
    }
    if (msg.beg) {
      writer.writeString(18, msg.beg);
    }
    if (msg.ttl) {
      writer.writeInt32(19, msg.ttl);
    }
    if (msg.tau) {
      writer.writeInt32(20, msg.tau);
    }
    if (msg.live) {
      writer.writeBool(21, msg.live);
    }
    if (msg.numberOfVaults) {
      writer.writeInt64String(22, msg.numberOfVaults.toString() as any);
    }
    if (msg.box) {
      writer.writeString(23, msg.box);
    }
    if (msg.litter) {
      writer.writeString(24, msg.litter);
    }
    if (msg.supply) {
      writer.writeString(25, msg.supply);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Collateral, reader: BinaryReader): Collateral {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.gem = reader.readString();
          break;
        }
        case 5: {
          msg.dai = reader.readString();
          break;
        }
        case 6: {
          msg.ink = reader.readString();
          break;
        }
        case 7: {
          msg.art = reader.readString();
          break;
        }
        case 8: {
          msg.rate = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.rho, Timestamp._readMessage);
          break;
        }
        case 10: {
          msg.debt = reader.readString();
          break;
        }
        case 11: {
          msg.line = reader.readString();
          break;
        }
        case 12: {
          msg.dust = reader.readString();
          break;
        }
        case 13: {
          msg.price = reader.readString();
          break;
        }
        case 14: {
          msg.mat = reader.readString();
          break;
        }
        case 15: {
          msg.duty = reader.readString();
          break;
        }
        case 16: {
          msg.chop = reader.readString();
          break;
        }
        case 17: {
          msg.dunk = reader.readString();
          break;
        }
        case 18: {
          msg.beg = reader.readString();
          break;
        }
        case 19: {
          msg.ttl = reader.readInt32();
          break;
        }
        case 20: {
          msg.tau = reader.readInt32();
          break;
        }
        case 21: {
          msg.live = reader.readBool();
          break;
        }
        case 22: {
          msg.numberOfVaults = BigInt(reader.readInt64String());
          break;
        }
        case 23: {
          msg.box = reader.readString();
          break;
        }
        case 24: {
          msg.litter = reader.readString();
          break;
        }
        case 25: {
          msg.supply = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Vault = {
  /**
   * Serializes Vault to protobuf.
   */
  encode: function (msg: Partial<Vault>): Uint8Array {
    return Vault._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Vault from protobuf.
   */
  decode: function (bytes: ByteSource): Vault {
    return Vault._readMessage(Vault.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Vault with all fields set to their default value.
   */
  initialize: function (): Vault {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      collateralId: "",
      ink: "",
      art: "",
      identityId: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Vault>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.collateralId) {
      writer.writeString(3, msg.collateralId);
    }
    if (msg.ink) {
      writer.writeString(4, msg.ink);
    }
    if (msg.art) {
      writer.writeString(5, msg.art);
    }
    if (msg.identityId) {
      writer.writeInt64String(6, msg.identityId.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Vault, reader: BinaryReader): Vault {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.collateralId = reader.readString();
          break;
        }
        case 4: {
          msg.ink = reader.readString();
          break;
        }
        case 5: {
          msg.art = reader.readString();
          break;
        }
        case 6: {
          msg.identityId = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Event: {
    /**
     * Serializes Vault.Event to protobuf.
     */
    encode: function (msg: Partial<Vault.Event>): Uint8Array {
      return Vault.Event._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Vault.Event from protobuf.
     */
    decode: function (bytes: ByteSource): Vault.Event {
      return Vault.Event._readMessage(
        Vault.Event.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Vault.Event with all fields set to their default value.
     */
    initialize: function (): Vault.Event {
      return {
        vaultId: "",
        createdAt: Timestamp.initialize(),
        action: Action._fromInt(0),
        dink: "",
        dart: "",
        debt: "",
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Vault.Event>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.vaultId) {
        writer.writeString(1, msg.vaultId);
      }
      if (msg.createdAt) {
        writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
      }
      if (msg.action && Action._toInt(msg.action)) {
        writer.writeEnum(3, Action._toInt(msg.action));
      }
      if (msg.dink) {
        writer.writeString(4, msg.dink);
      }
      if (msg.dart) {
        writer.writeString(5, msg.dart);
      }
      if (msg.debt) {
        writer.writeString(6, msg.debt);
      }
      if (msg.id) {
        writer.writeString(7, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Vault.Event,
      reader: BinaryReader
    ): Vault.Event {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.vaultId = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(msg.createdAt, Timestamp._readMessage);
            break;
          }
          case 3: {
            msg.action = Action._fromInt(reader.readEnum());
            break;
          }
          case 4: {
            msg.dink = reader.readString();
            break;
          }
          case 5: {
            msg.dart = reader.readString();
            break;
          }
          case 6: {
            msg.debt = reader.readString();
            break;
          }
          case 7: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Flip = {
  /**
   * Serializes Flip to protobuf.
   */
  encode: function (msg: Partial<Flip>): Uint8Array {
    return Flip._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Flip from protobuf.
   */
  decode: function (bytes: ByteSource): Flip {
    return Flip._readMessage(Flip.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Flip with all fields set to their default value.
   */
  initialize: function (): Flip {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      tic: Timestamp.initialize(),
      end: Timestamp.initialize(),
      bid: "",
      lot: "",
      tab: "",
      art: "",
      collateralId: "",
      vaultId: "",
      guy: "",
      action: Action._fromInt(0),
      tags: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Flip>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.tic) {
      writer.writeMessage(3, msg.tic, Timestamp._writeMessage);
    }
    if (msg.end) {
      writer.writeMessage(4, msg.end, Timestamp._writeMessage);
    }
    if (msg.bid) {
      writer.writeString(5, msg.bid);
    }
    if (msg.lot) {
      writer.writeString(6, msg.lot);
    }
    if (msg.tab) {
      writer.writeString(7, msg.tab);
    }
    if (msg.art) {
      writer.writeString(8, msg.art);
    }
    if (msg.collateralId) {
      writer.writeString(9, msg.collateralId);
    }
    if (msg.vaultId) {
      writer.writeString(10, msg.vaultId);
    }
    if (msg.guy) {
      writer.writeString(11, msg.guy);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(12, Action._toInt(msg.action));
    }
    if (msg.tags?.length) {
      writer.writePackedEnum(13, msg.tags.map(Flip.Tag._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Flip, reader: BinaryReader): Flip {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.tic, Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.end, Timestamp._readMessage);
          break;
        }
        case 5: {
          msg.bid = reader.readString();
          break;
        }
        case 6: {
          msg.lot = reader.readString();
          break;
        }
        case 7: {
          msg.tab = reader.readString();
          break;
        }
        case 8: {
          msg.art = reader.readString();
          break;
        }
        case 9: {
          msg.collateralId = reader.readString();
          break;
        }
        case 10: {
          msg.vaultId = reader.readString();
          break;
        }
        case 11: {
          msg.guy = reader.readString();
          break;
        }
        case 12: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.tags.push(...reader.readPackedEnum().map(Flip.Tag._fromInt));
          } else {
            msg.tags.push(Flip.Tag._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Tag: {
    MyVault: "MyVault",
    Participated: "Participated",
    Leading: "Leading",
    /**
     * @private
     */
    _fromInt: function (i: number): Flip.Tag {
      switch (i) {
        case 0: {
          return "MyVault";
        }
        case 1: {
          return "Participated";
        }
        case 2: {
          return "Leading";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Flip.Tag;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Flip.Tag): number {
      switch (i) {
        case "MyVault": {
          return 0;
        }
        case "Participated": {
          return 1;
        }
        case "Leading": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Event: {
    /**
     * Serializes Flip.Event to protobuf.
     */
    encode: function (msg: Partial<Flip.Event>): Uint8Array {
      return Flip.Event._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Flip.Event from protobuf.
     */
    decode: function (bytes: ByteSource): Flip.Event {
      return Flip.Event._readMessage(
        Flip.Event.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Flip.Event with all fields set to their default value.
     */
    initialize: function (): Flip.Event {
      return {
        flipId: "",
        createdAt: Timestamp.initialize(),
        action: Action._fromInt(0),
        bid: "",
        lot: "",
        isMe: false,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Flip.Event>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.flipId) {
        writer.writeString(1, msg.flipId);
      }
      if (msg.createdAt) {
        writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
      }
      if (msg.action && Action._toInt(msg.action)) {
        writer.writeEnum(3, Action._toInt(msg.action));
      }
      if (msg.bid) {
        writer.writeString(4, msg.bid);
      }
      if (msg.lot) {
        writer.writeString(5, msg.lot);
      }
      if (msg.isMe) {
        writer.writeBool(6, msg.isMe);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Flip.Event, reader: BinaryReader): Flip.Event {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.flipId = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(msg.createdAt, Timestamp._readMessage);
            break;
          }
          case 3: {
            msg.action = Action._fromInt(reader.readEnum());
            break;
          }
          case 4: {
            msg.bid = reader.readString();
            break;
          }
          case 5: {
            msg.lot = reader.readString();
            break;
          }
          case 6: {
            msg.isMe = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Proposal = {
  /**
   * Serializes Proposal to protobuf.
   */
  encode: function (msg: Partial<Proposal>): Uint8Array {
    return Proposal._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Proposal from protobuf.
   */
  decode: function (bytes: ByteSource): Proposal {
    return Proposal._readMessage(
      Proposal.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (): Proposal {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      passedAt: Timestamp.initialize(),
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      data: "",
      votes: [],
      items: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Proposal>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.passedAt) {
      writer.writeMessage(3, msg.passedAt, Timestamp._writeMessage);
    }
    if (msg.creator) {
      writer.writeString(4, msg.creator);
    }
    if (msg.assetId) {
      writer.writeString(5, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(6, msg.amount);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(7, Action._toInt(msg.action));
    }
    if (msg.data) {
      writer.writeString(8, msg.data);
    }
    if (msg.votes?.length) {
      writer.writeRepeatedString(9, msg.votes);
    }
    if (msg.items?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.items as any,
        Proposal.Item._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Proposal, reader: BinaryReader): Proposal {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.passedAt, Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.creator = reader.readString();
          break;
        }
        case 5: {
          msg.assetId = reader.readString();
          break;
        }
        case 6: {
          msg.amount = reader.readString();
          break;
        }
        case 7: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          msg.data = reader.readString();
          break;
        }
        case 9: {
          msg.votes.push(reader.readString());
          break;
        }
        case 10: {
          const m = Proposal.Item.initialize();
          reader.readMessage(m, Proposal.Item._readMessage);
          msg.items.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Item: {
    /**
     * Serializes Proposal.Item to protobuf.
     */
    encode: function (msg: Partial<Proposal.Item>): Uint8Array {
      return Proposal.Item._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.Item from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.Item {
      return Proposal.Item._readMessage(
        Proposal.Item.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Proposal.Item with all fields set to their default value.
     */
    initialize: function (): Proposal.Item {
      return {
        key: "",
        value: "",
        hint: "",
        action: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Proposal.Item>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      if (msg.hint) {
        writer.writeString(3, msg.hint);
      }
      if (msg.action) {
        writer.writeString(4, msg.action);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.Item,
      reader: BinaryReader
    ): Proposal.Item {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          case 3: {
            msg.hint = reader.readString();
            break;
          }
          case 4: {
            msg.action = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Oracle = {
  /**
   * Serializes Oracle to protobuf.
   */
  encode: function (msg: Partial<Oracle>): Uint8Array {
    return Oracle._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Oracle from protobuf.
   */
  decode: function (bytes: ByteSource): Oracle {
    return Oracle._readMessage(Oracle.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Oracle with all fields set to their default value.
   */
  initialize: function (): Oracle {
    return {
      assetId: "",
      hop: 0,
      current: "",
      next: "",
      peekAt: Timestamp.initialize(),
      threshold: 0,
      governors: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Oracle>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.hop) {
      writer.writeInt32(2, msg.hop);
    }
    if (msg.current) {
      writer.writeString(3, msg.current);
    }
    if (msg.next) {
      writer.writeString(4, msg.next);
    }
    if (msg.peekAt) {
      writer.writeMessage(5, msg.peekAt, Timestamp._writeMessage);
    }
    if (msg.threshold) {
      writer.writeInt32(6, msg.threshold);
    }
    if (msg.governors?.length) {
      writer.writeRepeatedString(7, msg.governors);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Oracle, reader: BinaryReader): Oracle {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.hop = reader.readInt32();
          break;
        }
        case 3: {
          msg.current = reader.readString();
          break;
        }
        case 4: {
          msg.next = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.peekAt, Timestamp._readMessage);
          break;
        }
        case 6: {
          msg.threshold = reader.readInt32();
          break;
        }
        case 7: {
          msg.governors.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: Partial<Transaction>): Uint8Array {
    return Transaction._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (): Transaction {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      status: Transaction.Status._fromInt(0),
      msg: "",
      parameters: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Transaction>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(5, Action._toInt(msg.action));
    }
    if (msg.status && Transaction.Status._toInt(msg.status)) {
      writer.writeEnum(6, Transaction.Status._toInt(msg.status));
    }
    if (msg.msg) {
      writer.writeString(7, msg.msg);
    }
    if (msg.parameters) {
      writer.writeString(8, msg.parameters);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, reader: BinaryReader): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.status = Transaction.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.msg = reader.readString();
          break;
        }
        case 8: {
          msg.parameters = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Abort: "Abort",
    OK: "OK",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Abort";
        }
        case 2: {
          return "OK";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Abort": {
          return 1;
        }
        case "OK": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Stat = {
  /**
   * Serializes Stat to protobuf.
   */
  encode: function (msg: Partial<Stat>): Uint8Array {
    return Stat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Stat from protobuf.
   */
  decode: function (bytes: ByteSource): Stat {
    return Stat._readMessage(Stat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Stat with all fields set to their default value.
   */
  initialize: function (): Stat {
    return {
      collateralId: "",
      date: Timestamp.initialize(),
      timestamp: 0n,
      gem: "",
      dai: "",
      ink: "",
      debt: "",
      gemPrice: "",
      daiPrice: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Stat>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.collateralId) {
      writer.writeString(1, msg.collateralId);
    }
    if (msg.date) {
      writer.writeMessage(2, msg.date, Timestamp._writeMessage);
    }
    if (msg.timestamp) {
      writer.writeInt64String(3, msg.timestamp.toString() as any);
    }
    if (msg.gem) {
      writer.writeString(4, msg.gem);
    }
    if (msg.dai) {
      writer.writeString(5, msg.dai);
    }
    if (msg.ink) {
      writer.writeString(6, msg.ink);
    }
    if (msg.debt) {
      writer.writeString(7, msg.debt);
    }
    if (msg.gemPrice) {
      writer.writeString(8, msg.gemPrice);
    }
    if (msg.daiPrice) {
      writer.writeString(9, msg.daiPrice);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Stat, reader: BinaryReader): Stat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.collateralId = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.date, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.timestamp = BigInt(reader.readInt64String());
          break;
        }
        case 4: {
          msg.gem = reader.readString();
          break;
        }
        case 5: {
          msg.dai = reader.readString();
          break;
        }
        case 6: {
          msg.ink = reader.readString();
          break;
        }
        case 7: {
          msg.debt = reader.readString();
          break;
        }
        case 8: {
          msg.gemPrice = reader.readString();
          break;
        }
        case 9: {
          msg.daiPrice = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const AggregatedStat = {
  /**
   * Serializes AggregatedStat to protobuf.
   */
  encode: function (msg: Partial<AggregatedStat>): Uint8Array {
    return AggregatedStat._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes AggregatedStat from protobuf.
   */
  decode: function (bytes: ByteSource): AggregatedStat {
    return AggregatedStat._readMessage(
      AggregatedStat.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes AggregatedStat with all fields set to their default value.
   */
  initialize: function (): AggregatedStat {
    return {
      date: Timestamp.initialize(),
      timestamp: 0n,
      gemValue: "",
      daiValue: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<AggregatedStat>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.date) {
      writer.writeMessage(1, msg.date, Timestamp._writeMessage);
    }
    if (msg.timestamp) {
      writer.writeInt64String(2, msg.timestamp.toString() as any);
    }
    if (msg.gemValue) {
      writer.writeString(3, msg.gemValue);
    }
    if (msg.daiValue) {
      writer.writeString(5, msg.daiValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AggregatedStat,
    reader: BinaryReader
  ): AggregatedStat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.date, Timestamp._readMessage);
          break;
        }
        case 2: {
          msg.timestamp = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.gemValue = reader.readString();
          break;
        }
        case 5: {
          msg.daiValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Audit = {
  /**
   * Serializes Audit to protobuf.
   */
  encode: function (msg: Partial<Audit>): Uint8Array {
    return Audit._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Audit from protobuf.
   */
  decode: function (bytes: ByteSource): Audit {
    return Audit._readMessage(Audit.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (): Audit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Audit>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.userId) {
      writer.writeString(5, msg.userId);
    }
    if (msg.status && Audit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Audit.Status._toInt(msg.status));
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.reviewedBy) {
      writer.writeString(8, msg.reviewedBy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, reader: BinaryReader): Audit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.userId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Audit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.reviewedBy = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Rejected: "Rejected",
    Approved: "Approved",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Rejected";
        }
        case 2: {
          return "Approved";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Rejected": {
          return 1;
        }
        case "Approved": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg?: Partial<Req>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes?: ByteSource): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Req>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Req, _reader: BinaryReader): Req {
    return _msg;
  },

  FindAsset: {
    /**
     * Serializes Req.FindAsset to protobuf.
     */
    encode: function (msg: Partial<Req.FindAsset>): Uint8Array {
      return Req.FindAsset._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindAsset from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindAsset {
      return Req.FindAsset._readMessage(
        Req.FindAsset.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindAsset with all fields set to their default value.
     */
    initialize: function (): Req.FindAsset {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindAsset>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindAsset,
      reader: BinaryReader
    ): Req.FindAsset {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAssets: {
    /**
     * Serializes Req.ListAssets to protobuf.
     */
    encode: function (_msg?: Partial<Req.ListAssets>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListAssets from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListAssets {
      return {};
    },

    /**
     * Initializes Req.ListAssets with all fields set to their default value.
     */
    initialize: function (): Req.ListAssets {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListAssets>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListAssets,
      _reader: BinaryReader
    ): Req.ListAssets {
      return _msg;
    },
  },

  FindOracle: {
    /**
     * Serializes Req.FindOracle to protobuf.
     */
    encode: function (msg: Partial<Req.FindOracle>): Uint8Array {
      return Req.FindOracle._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindOracle from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindOracle {
      return Req.FindOracle._readMessage(
        Req.FindOracle.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindOracle with all fields set to their default value.
     */
    initialize: function (): Req.FindOracle {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindOracle>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindOracle,
      reader: BinaryReader
    ): Req.FindOracle {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Req.ListOracles to protobuf.
     */
    encode: function (_msg?: Partial<Req.ListOracles>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListOracles from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListOracles {
      return {};
    },

    /**
     * Initializes Req.ListOracles with all fields set to their default value.
     */
    initialize: function (): Req.ListOracles {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListOracles>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListOracles,
      _reader: BinaryReader
    ): Req.ListOracles {
      return _msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Req.ListCollaterals to protobuf.
     */
    encode: function (_msg?: Partial<Req.ListCollaterals>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListCollaterals from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListCollaterals {
      return {};
    },

    /**
     * Initializes Req.ListCollaterals with all fields set to their default value.
     */
    initialize: function (): Req.ListCollaterals {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListCollaterals>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListCollaterals,
      _reader: BinaryReader
    ): Req.ListCollaterals {
      return _msg;
    },
  },

  FindCollateral: {
    /**
     * Serializes Req.FindCollateral to protobuf.
     */
    encode: function (msg: Partial<Req.FindCollateral>): Uint8Array {
      return Req.FindCollateral._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindCollateral from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindCollateral {
      return Req.FindCollateral._readMessage(
        Req.FindCollateral.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindCollateral with all fields set to their default value.
     */
    initialize: function (): Req.FindCollateral {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindCollateral>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindCollateral,
      reader: BinaryReader
    ): Req.FindCollateral {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindVault: {
    /**
     * Serializes Req.FindVault to protobuf.
     */
    encode: function (msg: Partial<Req.FindVault>): Uint8Array {
      return Req.FindVault._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindVault from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindVault {
      return Req.FindVault._readMessage(
        Req.FindVault.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindVault with all fields set to their default value.
     */
    initialize: function (): Req.FindVault {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindVault>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindVault,
      reader: BinaryReader
    ): Req.FindVault {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Req.ListVaults to protobuf.
     */
    encode: function (msg: Partial<Req.ListVaults>): Uint8Array {
      return Req.ListVaults._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListVaults {
      return Req.ListVaults._readMessage(
        Req.ListVaults.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListVaults with all fields set to their default value.
     */
    initialize: function (): Req.ListVaults {
      return {
        collateralId: "",
        userId: "",
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListVaults>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.collateralId) {
        writer.writeString(1, msg.collateralId);
      }
      if (msg.userId) {
        writer.writeString(2, msg.userId);
      }
      if (msg.cursor) {
        writer.writeString(3, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(4, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaults,
      reader: BinaryReader
    ): Req.ListVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.collateralId = reader.readString();
            break;
          }
          case 2: {
            msg.userId = reader.readString();
            break;
          }
          case 3: {
            msg.cursor = reader.readString();
            break;
          }
          case 4: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Req.ListMyVaults to protobuf.
     */
    encode: function (msg: Partial<Req.ListMyVaults>): Uint8Array {
      return Req.ListMyVaults._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListMyVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListMyVaults {
      return Req.ListMyVaults._readMessage(
        Req.ListMyVaults.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListMyVaults with all fields set to their default value.
     */
    initialize: function (): Req.ListMyVaults {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListMyVaults>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListMyVaults,
      reader: BinaryReader
    ): Req.ListMyVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Req.ListVaultEvents to protobuf.
     */
    encode: function (msg: Partial<Req.ListVaultEvents>): Uint8Array {
      return Req.ListVaultEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListVaultEvents {
      return Req.ListVaultEvents._readMessage(
        Req.ListVaultEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (): Req.ListVaultEvents {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListVaultEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaultEvents,
      reader: BinaryReader
    ): Req.ListVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Req.QueryVaultEvents to protobuf.
     */
    encode: function (msg: Partial<Req.QueryVaultEvents>): Uint8Array {
      return Req.QueryVaultEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.QueryVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.QueryVaultEvents {
      return Req.QueryVaultEvents._readMessage(
        Req.QueryVaultEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (): Req.QueryVaultEvents {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.QueryVaultEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryVaultEvents,
      reader: BinaryReader
    ): Req.QueryVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindFlip: {
    /**
     * Serializes Req.FindFlip to protobuf.
     */
    encode: function (msg: Partial<Req.FindFlip>): Uint8Array {
      return Req.FindFlip._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindFlip from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindFlip {
      return Req.FindFlip._readMessage(
        Req.FindFlip.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindFlip with all fields set to their default value.
     */
    initialize: function (): Req.FindFlip {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindFlip>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindFlip,
      reader: BinaryReader
    ): Req.FindFlip {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Req.ListFlips to protobuf.
     */
    encode: function (msg: Partial<Req.ListFlips>): Uint8Array {
      return Req.ListFlips._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListFlips {
      return Req.ListFlips._readMessage(
        Req.ListFlips.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListFlips with all fields set to their default value.
     */
    initialize: function (): Req.ListFlips {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListFlips>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlips,
      reader: BinaryReader
    ): Req.ListFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Req.QueryFlips to protobuf.
     */
    encode: function (msg: Partial<Req.QueryFlips>): Uint8Array {
      return Req.QueryFlips._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.QueryFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Req.QueryFlips {
      return Req.QueryFlips._readMessage(
        Req.QueryFlips.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.QueryFlips with all fields set to their default value.
     */
    initialize: function (): Req.QueryFlips {
      return {
        offset: 0n,
        limit: 0n,
        phase: "",
        myVaults: "",
        myBids: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.QueryFlips>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.offset) {
        writer.writeInt64String(1, msg.offset.toString() as any);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      if (msg.phase) {
        writer.writeString(3, msg.phase);
      }
      if (msg.myVaults) {
        writer.writeString(4, msg.myVaults);
      }
      if (msg.myBids) {
        writer.writeString(5, msg.myBids);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryFlips,
      reader: BinaryReader
    ): Req.QueryFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.offset = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          case 3: {
            msg.phase = reader.readString();
            break;
          }
          case 4: {
            msg.myVaults = reader.readString();
            break;
          }
          case 5: {
            msg.myBids = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Req.ListFlipEvents to protobuf.
     */
    encode: function (msg: Partial<Req.ListFlipEvents>): Uint8Array {
      return Req.ListFlipEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListFlipEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListFlipEvents {
      return Req.ListFlipEvents._readMessage(
        Req.ListFlipEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (): Req.ListFlipEvents {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListFlipEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlipEvents,
      reader: BinaryReader
    ): Req.ListFlipEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindTransaction: {
    /**
     * Serializes Req.FindTransaction to protobuf.
     */
    encode: function (msg: Partial<Req.FindTransaction>): Uint8Array {
      return Req.FindTransaction._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindTransaction from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindTransaction {
      return Req.FindTransaction._readMessage(
        Req.FindTransaction.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindTransaction with all fields set to their default value.
     */
    initialize: function (): Req.FindTransaction {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindTransaction>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindTransaction,
      reader: BinaryReader
    ): Req.FindTransaction {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Req.ListTransactions to protobuf.
     */
    encode: function (msg: Partial<Req.ListTransactions>): Uint8Array {
      return Req.ListTransactions._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListTransactions from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListTransactions {
      return Req.ListTransactions._readMessage(
        Req.ListTransactions.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListTransactions with all fields set to their default value.
     */
    initialize: function (): Req.ListTransactions {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListTransactions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListTransactions,
      reader: BinaryReader
    ): Req.ListTransactions {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Req.ListProposals to protobuf.
     */
    encode: function (msg: Partial<Req.ListProposals>): Uint8Array {
      return Req.ListProposals._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListProposals from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListProposals {
      return Req.ListProposals._readMessage(
        Req.ListProposals.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListProposals with all fields set to their default value.
     */
    initialize: function (): Req.ListProposals {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListProposals>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListProposals,
      reader: BinaryReader
    ): Req.ListProposals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindProposal: {
    /**
     * Serializes Req.FindProposal to protobuf.
     */
    encode: function (msg: Partial<Req.FindProposal>): Uint8Array {
      return Req.FindProposal._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindProposal from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindProposal {
      return Req.FindProposal._readMessage(
        Req.FindProposal.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.FindProposal with all fields set to their default value.
     */
    initialize: function (): Req.FindProposal {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindProposal>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindProposal,
      reader: BinaryReader
    ): Req.FindProposal {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Req.ListStats to protobuf.
     */
    encode: function (msg: Partial<Req.ListStats>): Uint8Array {
      return Req.ListStats._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListStats from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListStats {
      return Req.ListStats._readMessage(
        Req.ListStats.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListStats with all fields set to their default value.
     */
    initialize: function (): Req.ListStats {
      return {
        id: "",
        from: 0n,
        to: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListStats>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.from) {
        writer.writeInt64String(2, msg.from.toString() as any);
      }
      if (msg.to) {
        writer.writeInt64String(3, msg.to.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListStats,
      reader: BinaryReader
    ): Req.ListStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            msg.from = BigInt(reader.readInt64String());
            break;
          }
          case 3: {
            msg.to = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Req.ListAggregatedStats to protobuf.
     */
    encode: function (msg: Partial<Req.ListAggregatedStats>): Uint8Array {
      return Req.ListAggregatedStats._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListAggregatedStats from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListAggregatedStats {
      return Req.ListAggregatedStats._readMessage(
        Req.ListAggregatedStats.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (): Req.ListAggregatedStats {
      return {
        from: 0n,
        to: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListAggregatedStats>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.from) {
        writer.writeInt64String(1, msg.from.toString() as any);
      }
      if (msg.to) {
        writer.writeInt64String(2, msg.to.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAggregatedStats,
      reader: BinaryReader
    ): Req.ListAggregatedStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.from = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.to = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Req.GetInfo to protobuf.
     */
    encode: function (_msg?: Partial<Req.GetInfo>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.GetInfo from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.GetInfo {
      return {};
    },

    /**
     * Initializes Req.GetInfo with all fields set to their default value.
     */
    initialize: function (): Req.GetInfo {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.GetInfo>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.GetInfo,
      _reader: BinaryReader
    ): Req.GetInfo {
      return _msg;
    },
  },

  ListAudit: {
    /**
     * Serializes Req.ListAudit to protobuf.
     */
    encode: function (msg: Partial<Req.ListAudit>): Uint8Array {
      return Req.ListAudit._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListAudit from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListAudit {
      return Req.ListAudit._readMessage(
        Req.ListAudit.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.ListAudit with all fields set to their default value.
     */
    initialize: function (): Req.ListAudit {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListAudit>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAudit,
      reader: BinaryReader
    ): Req.ListAudit {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Resp = {
  /**
   * Serializes Resp to protobuf.
   */
  encode: function (_msg?: Partial<Resp>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Resp from protobuf.
   */
  decode: function (_bytes?: ByteSource): Resp {
    return {};
  },

  /**
   * Initializes Resp with all fields set to their default value.
   */
  initialize: function (): Resp {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Resp>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Resp, _reader: BinaryReader): Resp {
    return _msg;
  },

  ListAssets: {
    /**
     * Serializes Resp.ListAssets to protobuf.
     */
    encode: function (msg: Partial<Resp.ListAssets>): Uint8Array {
      return Resp.ListAssets._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAssets from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAssets {
      return Resp.ListAssets._readMessage(
        Resp.ListAssets.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListAssets with all fields set to their default value.
     */
    initialize: function (): Resp.ListAssets {
      return {
        assets: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAssets>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.assets?.length) {
        writer.writeRepeatedMessage(1, msg.assets as any, Asset._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAssets,
      reader: BinaryReader
    ): Resp.ListAssets {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Asset.initialize();
            reader.readMessage(m, Asset._readMessage);
            msg.assets.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Resp.ListOracles to protobuf.
     */
    encode: function (msg: Partial<Resp.ListOracles>): Uint8Array {
      return Resp.ListOracles._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListOracles from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListOracles {
      return Resp.ListOracles._readMessage(
        Resp.ListOracles.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListOracles with all fields set to their default value.
     */
    initialize: function (): Resp.ListOracles {
      return {
        oracles: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListOracles>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oracles?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.oracles as any,
          Oracle._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListOracles,
      reader: BinaryReader
    ): Resp.ListOracles {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Oracle.initialize();
            reader.readMessage(m, Oracle._readMessage);
            msg.oracles.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Resp.ListCollaterals to protobuf.
     */
    encode: function (msg: Partial<Resp.ListCollaterals>): Uint8Array {
      return Resp.ListCollaterals._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListCollaterals from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListCollaterals {
      return Resp.ListCollaterals._readMessage(
        Resp.ListCollaterals.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListCollaterals with all fields set to their default value.
     */
    initialize: function (): Resp.ListCollaterals {
      return {
        collaterals: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListCollaterals>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.collaterals?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.collaterals as any,
          Collateral._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListCollaterals,
      reader: BinaryReader
    ): Resp.ListCollaterals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Collateral.initialize();
            reader.readMessage(m, Collateral._readMessage);
            msg.collaterals.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Resp.ListVaults to protobuf.
     */
    encode: function (msg: Partial<Resp.ListVaults>): Uint8Array {
      return Resp.ListVaults._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListVaults {
      return Resp.ListVaults._readMessage(
        Resp.ListVaults.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListVaults with all fields set to their default value.
     */
    initialize: function (): Resp.ListVaults {
      return {
        vaults: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListVaults>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.vaults?.length) {
        writer.writeRepeatedMessage(1, msg.vaults as any, Vault._writeMessage);
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaults,
      reader: BinaryReader
    ): Resp.ListVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.initialize();
            reader.readMessage(m, Vault._readMessage);
            msg.vaults.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Resp.ListMyVaults to protobuf.
     */
    encode: function (msg: Partial<Resp.ListMyVaults>): Uint8Array {
      return Resp.ListMyVaults._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListMyVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListMyVaults {
      return Resp.ListMyVaults._readMessage(
        Resp.ListMyVaults.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListMyVaults with all fields set to their default value.
     */
    initialize: function (): Resp.ListMyVaults {
      return {
        vaults: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListMyVaults>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.vaults?.length) {
        writer.writeRepeatedMessage(1, msg.vaults as any, Vault._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListMyVaults,
      reader: BinaryReader
    ): Resp.ListMyVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.initialize();
            reader.readMessage(m, Vault._readMessage);
            msg.vaults.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Resp.ListVaultEvents to protobuf.
     */
    encode: function (msg: Partial<Resp.ListVaultEvents>): Uint8Array {
      return Resp.ListVaultEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListVaultEvents {
      return Resp.ListVaultEvents._readMessage(
        Resp.ListVaultEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (): Resp.ListVaultEvents {
      return {
        events: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListVaultEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Vault.Event._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaultEvents,
      reader: BinaryReader
    ): Resp.ListVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.Event.initialize();
            reader.readMessage(m, Vault.Event._readMessage);
            msg.events.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Resp.QueryVaultEvents to protobuf.
     */
    encode: function (msg: Partial<Resp.QueryVaultEvents>): Uint8Array {
      return Resp.QueryVaultEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.QueryVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.QueryVaultEvents {
      return Resp.QueryVaultEvents._readMessage(
        Resp.QueryVaultEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (): Resp.QueryVaultEvents {
      return {
        events: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.QueryVaultEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Vault.Event._writeMessage
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryVaultEvents,
      reader: BinaryReader
    ): Resp.QueryVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.Event.initialize();
            reader.readMessage(m, Vault.Event._readMessage);
            msg.events.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Resp.ListFlips to protobuf.
     */
    encode: function (msg: Partial<Resp.ListFlips>): Uint8Array {
      return Resp.ListFlips._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListFlips {
      return Resp.ListFlips._readMessage(
        Resp.ListFlips.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListFlips with all fields set to their default value.
     */
    initialize: function (): Resp.ListFlips {
      return {
        flips: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListFlips>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.flips?.length) {
        writer.writeRepeatedMessage(1, msg.flips as any, Flip._writeMessage);
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlips,
      reader: BinaryReader
    ): Resp.ListFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.initialize();
            reader.readMessage(m, Flip._readMessage);
            msg.flips.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Resp.QueryFlips to protobuf.
     */
    encode: function (msg: Partial<Resp.QueryFlips>): Uint8Array {
      return Resp.QueryFlips._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.QueryFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.QueryFlips {
      return Resp.QueryFlips._readMessage(
        Resp.QueryFlips.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.QueryFlips with all fields set to their default value.
     */
    initialize: function (): Resp.QueryFlips {
      return {
        flips: [],
        total: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.QueryFlips>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.flips?.length) {
        writer.writeRepeatedMessage(1, msg.flips as any, Flip._writeMessage);
      }
      if (msg.total) {
        writer.writeInt32(2, msg.total);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryFlips,
      reader: BinaryReader
    ): Resp.QueryFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.initialize();
            reader.readMessage(m, Flip._readMessage);
            msg.flips.push(m);
            break;
          }
          case 2: {
            msg.total = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Resp.ListFlipEvents to protobuf.
     */
    encode: function (msg: Partial<Resp.ListFlipEvents>): Uint8Array {
      return Resp.ListFlipEvents._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListFlipEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListFlipEvents {
      return Resp.ListFlipEvents._readMessage(
        Resp.ListFlipEvents.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (): Resp.ListFlipEvents {
      return {
        events: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListFlipEvents>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Flip.Event._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlipEvents,
      reader: BinaryReader
    ): Resp.ListFlipEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.Event.initialize();
            reader.readMessage(m, Flip.Event._readMessage);
            msg.events.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Resp.ListTransactions to protobuf.
     */
    encode: function (msg: Partial<Resp.ListTransactions>): Uint8Array {
      return Resp.ListTransactions._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListTransactions from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListTransactions {
      return Resp.ListTransactions._readMessage(
        Resp.ListTransactions.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListTransactions with all fields set to their default value.
     */
    initialize: function (): Resp.ListTransactions {
      return {
        transactions: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListTransactions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.transactions?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.transactions as any,
          Transaction._writeMessage
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListTransactions,
      reader: BinaryReader
    ): Resp.ListTransactions {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Transaction.initialize();
            reader.readMessage(m, Transaction._readMessage);
            msg.transactions.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Resp.ListProposals to protobuf.
     */
    encode: function (msg: Partial<Resp.ListProposals>): Uint8Array {
      return Resp.ListProposals._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListProposals from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListProposals {
      return Resp.ListProposals._readMessage(
        Resp.ListProposals.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListProposals with all fields set to their default value.
     */
    initialize: function (): Resp.ListProposals {
      return {
        proposals: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListProposals>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.proposals?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.proposals as any,
          Proposal._writeMessage
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListProposals,
      reader: BinaryReader
    ): Resp.ListProposals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Proposal.initialize();
            reader.readMessage(m, Proposal._readMessage);
            msg.proposals.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Resp.ListStats to protobuf.
     */
    encode: function (msg: Partial<Resp.ListStats>): Uint8Array {
      return Resp.ListStats._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListStats from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListStats {
      return Resp.ListStats._readMessage(
        Resp.ListStats.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListStats with all fields set to their default value.
     */
    initialize: function (): Resp.ListStats {
      return {
        stats: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListStats>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.stats?.length) {
        writer.writeRepeatedMessage(1, msg.stats as any, Stat._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListStats,
      reader: BinaryReader
    ): Resp.ListStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Stat.initialize();
            reader.readMessage(m, Stat._readMessage);
            msg.stats.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Resp.ListAggregatedStats to protobuf.
     */
    encode: function (msg: Partial<Resp.ListAggregatedStats>): Uint8Array {
      return Resp.ListAggregatedStats._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAggregatedStats from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAggregatedStats {
      return Resp.ListAggregatedStats._readMessage(
        Resp.ListAggregatedStats.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (): Resp.ListAggregatedStats {
      return {
        stats: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAggregatedStats>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.stats?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.stats as any,
          AggregatedStat._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAggregatedStats,
      reader: BinaryReader
    ): Resp.ListAggregatedStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = AggregatedStat.initialize();
            reader.readMessage(m, AggregatedStat._readMessage);
            msg.stats.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Resp.GetInfo to protobuf.
     */
    encode: function (msg: Partial<Resp.GetInfo>): Uint8Array {
      return Resp.GetInfo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.GetInfo from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.GetInfo {
      return Resp.GetInfo._readMessage(
        Resp.GetInfo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.GetInfo with all fields set to their default value.
     */
    initialize: function (): Resp.GetInfo {
      return {
        oauthClientId: "",
        members: [],
        threshold: 0,
        publicKey: "",
        mode: 0,
        composedMode: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.GetInfo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oauthClientId) {
        writer.writeString(1, msg.oauthClientId);
      }
      if (msg.members?.length) {
        writer.writeRepeatedString(2, msg.members);
      }
      if (msg.threshold) {
        writer.writeInt32(3, msg.threshold);
      }
      if (msg.publicKey) {
        writer.writeString(4, msg.publicKey);
      }
      if (msg.mode) {
        writer.writeInt32(5, msg.mode);
      }
      if (msg.composedMode) {
        writer.writeInt32(6, msg.composedMode);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.GetInfo,
      reader: BinaryReader
    ): Resp.GetInfo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.oauthClientId = reader.readString();
            break;
          }
          case 2: {
            msg.members.push(reader.readString());
            break;
          }
          case 3: {
            msg.threshold = reader.readInt32();
            break;
          }
          case 4: {
            msg.publicKey = reader.readString();
            break;
          }
          case 5: {
            msg.mode = reader.readInt32();
            break;
          }
          case 6: {
            msg.composedMode = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAudit: {
    /**
     * Serializes Resp.ListAudit to protobuf.
     */
    encode: function (msg: Partial<Resp.ListAudit>): Uint8Array {
      return Resp.ListAudit._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAudit from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAudit {
      return Resp.ListAudit._readMessage(
        Resp.ListAudit.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Resp.ListAudit with all fields set to their default value.
     */
    initialize: function (): Resp.ListAudit {
      return {
        audits: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAudit>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.audits?.length) {
        writer.writeRepeatedMessage(1, msg.audits as any, Audit._writeMessage);
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAudit,
      reader: BinaryReader
    ): Resp.ListAudit {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Audit.initialize();
            reader.readMessage(m, Audit._readMessage);
            msg.audits.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  _: "_",
  /**
   * sys
   */
  SysWithdraw: "SysWithdraw",
  ActionSysProperty: "ActionSysProperty",
  /**
   * proposal
   */
  ProposalMake: "ProposalMake",
  ProposalShout: "ProposalShout",
  ProposalVote: "ProposalVote",
  /**
   * Collateral
   */
  CatCreate: "CatCreate",
  CatSupply: "CatSupply",
  CatEdit: "CatEdit",
  CatFold: "CatFold",
  CatMove: "CatMove",
  CatGain: "CatGain",
  CatFill: "CatFill",
  /**
   * Vaults
   */
  VatOpen: "VatOpen",
  VatDeposit: "VatDeposit",
  VatWithdraw: "VatWithdraw",
  VatPayback: "VatPayback",
  VatGenerate: "VatGenerate",
  /**
   * Flips
   */
  FlipKick: "FlipKick",
  FlipBid: "FlipBid",
  FlipDeal: "FlipDeal",
  /**
   * Oracles
   */
  OracleCreate: "OracleCreate",
  OracleEdit: "OracleEdit",
  OraclePoke: "OraclePoke",
  OracleRely: "OracleRely",
  OracleDeny: "OracleDeny",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "_";
      }
      case 1: {
        return "SysWithdraw";
      }
      case 2: {
        return "ActionSysProperty";
      }
      case 11: {
        return "ProposalMake";
      }
      case 12: {
        return "ProposalShout";
      }
      case 13: {
        return "ProposalVote";
      }
      case 21: {
        return "CatCreate";
      }
      case 22: {
        return "CatSupply";
      }
      case 23: {
        return "CatEdit";
      }
      case 24: {
        return "CatFold";
      }
      case 25: {
        return "CatMove";
      }
      case 26: {
        return "CatGain";
      }
      case 27: {
        return "CatFill";
      }
      case 31: {
        return "VatOpen";
      }
      case 32: {
        return "VatDeposit";
      }
      case 33: {
        return "VatWithdraw";
      }
      case 34: {
        return "VatPayback";
      }
      case 35: {
        return "VatGenerate";
      }
      case 41: {
        return "FlipKick";
      }
      case 42: {
        return "FlipBid";
      }
      case 43: {
        return "FlipDeal";
      }
      case 51: {
        return "OracleCreate";
      }
      case 52: {
        return "OracleEdit";
      }
      case 53: {
        return "OraclePoke";
      }
      case 54: {
        return "OracleRely";
      }
      case 55: {
        return "OracleDeny";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "_": {
        return 0;
      }
      case "SysWithdraw": {
        return 1;
      }
      case "ActionSysProperty": {
        return 2;
      }
      case "ProposalMake": {
        return 11;
      }
      case "ProposalShout": {
        return 12;
      }
      case "ProposalVote": {
        return 13;
      }
      case "CatCreate": {
        return 21;
      }
      case "CatSupply": {
        return 22;
      }
      case "CatEdit": {
        return 23;
      }
      case "CatFold": {
        return 24;
      }
      case "CatMove": {
        return 25;
      }
      case "CatGain": {
        return 26;
      }
      case "CatFill": {
        return 27;
      }
      case "VatOpen": {
        return 31;
      }
      case "VatDeposit": {
        return 32;
      }
      case "VatWithdraw": {
        return 33;
      }
      case "VatPayback": {
        return 34;
      }
      case "VatGenerate": {
        return 35;
      }
      case "FlipKick": {
        return 41;
      }
      case "FlipBid": {
        return 42;
      }
      case "FlipDeal": {
        return 43;
      }
      case "OracleCreate": {
        return 51;
      }
      case "OracleEdit": {
        return 52;
      }
      case "OraclePoke": {
        return 53;
      }
      case "OracleRely": {
        return 54;
      }
      case "OracleDeny": {
        return 55;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PaginationJSON = {
  /**
   * Serializes Pagination to JSON.
   */
  encode: function (msg: Partial<Pagination>): string {
    return JSON.stringify(PaginationJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pagination from JSON.
   */
  decode: function (json: string): Pagination {
    return PaginationJSON._readMessage(
      PaginationJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Pagination with all fields set to their default value.
   */
  initialize: function (): Pagination {
    return {
      nextCursor: "",
      hasNext: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Pagination>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nextCursor) {
      json.nextCursor = msg.nextCursor;
    }
    if (msg.hasNext) {
      json.hasNext = msg.hasNext;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pagination, json: any): Pagination {
    const _nextCursor = json.nextCursor ?? json.next_cursor;
    if (_nextCursor) {
      msg.nextCursor = _nextCursor;
    }
    const _hasNext = json.hasNext ?? json.has_next;
    if (_hasNext) {
      msg.hasNext = _hasNext;
    }
    return msg;
  },
};

export const AssetJSON = {
  /**
   * Serializes Asset to JSON.
   */
  encode: function (msg: Partial<Asset>): string {
    return JSON.stringify(AssetJSON._writeMessage(msg));
  },

  /**
   * Deserializes Asset from JSON.
   */
  decode: function (json: string): Asset {
    return AssetJSON._readMessage(AssetJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (): Asset {
    return {
      id: "",
      name: "",
      symbol: "",
      logo: "",
      chainId: "",
      chain: Asset.initialize(),
      price: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Asset>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.symbol) {
      json.symbol = msg.symbol;
    }
    if (msg.logo) {
      json.logo = msg.logo;
    }
    if (msg.chainId) {
      json.chainId = msg.chainId;
    }
    if (msg.chain) {
      const chain = AssetJSON._writeMessage(msg.chain);
      if (Object.keys(chain).length > 0) {
        json.chain = chain;
      }
    }
    if (msg.price) {
      json.price = msg.price;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, json: any): Asset {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _symbol = json.symbol;
    if (_symbol) {
      msg.symbol = _symbol;
    }
    const _logo = json.logo;
    if (_logo) {
      msg.logo = _logo;
    }
    const _chainId = json.chainId ?? json.chain_id;
    if (_chainId) {
      msg.chainId = _chainId;
    }
    const _chain = json.chain;
    if (_chain) {
      const m = Asset.initialize();
      AssetJSON._readMessage(m, _chain);
      msg.chain = m;
    }
    const _price = json.price;
    if (_price) {
      msg.price = _price;
    }
    return msg;
  },
};

export const CollateralJSON = {
  /**
   * Serializes Collateral to JSON.
   */
  encode: function (msg: Partial<Collateral>): string {
    return JSON.stringify(CollateralJSON._writeMessage(msg));
  },

  /**
   * Deserializes Collateral from JSON.
   */
  decode: function (json: string): Collateral {
    return CollateralJSON._readMessage(
      CollateralJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Collateral with all fields set to their default value.
   */
  initialize: function (): Collateral {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      name: "",
      gem: "",
      dai: "",
      ink: "",
      art: "",
      rate: "",
      rho: Timestamp.initialize(),
      debt: "",
      line: "",
      dust: "",
      price: "",
      mat: "",
      duty: "",
      chop: "",
      dunk: "",
      beg: "",
      ttl: 0,
      tau: 0,
      live: false,
      numberOfVaults: 0n,
      box: "",
      litter: "",
      supply: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Collateral>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.gem) {
      json.gem = msg.gem;
    }
    if (msg.dai) {
      json.dai = msg.dai;
    }
    if (msg.ink) {
      json.ink = msg.ink;
    }
    if (msg.art) {
      json.art = msg.art;
    }
    if (msg.rate) {
      json.rate = msg.rate;
    }
    if (msg.rho) {
      const rho = TimestampJSON._writeMessage(msg.rho);
      if (Object.keys(rho).length > 0) {
        json.rho = rho;
      }
    }
    if (msg.debt) {
      json.debt = msg.debt;
    }
    if (msg.line) {
      json.line = msg.line;
    }
    if (msg.dust) {
      json.dust = msg.dust;
    }
    if (msg.price) {
      json.price = msg.price;
    }
    if (msg.mat) {
      json.mat = msg.mat;
    }
    if (msg.duty) {
      json.duty = msg.duty;
    }
    if (msg.chop) {
      json.chop = msg.chop;
    }
    if (msg.dunk) {
      json.dunk = msg.dunk;
    }
    if (msg.beg) {
      json.beg = msg.beg;
    }
    if (msg.ttl) {
      json.ttl = msg.ttl;
    }
    if (msg.tau) {
      json.tau = msg.tau;
    }
    if (msg.live) {
      json.live = msg.live;
    }
    if (msg.numberOfVaults) {
      json.numberOfVaults = msg.numberOfVaults.toString();
    }
    if (msg.box) {
      json.box = msg.box;
    }
    if (msg.litter) {
      json.litter = msg.litter;
    }
    if (msg.supply) {
      json.supply = msg.supply;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Collateral, json: any): Collateral {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _gem = json.gem;
    if (_gem) {
      msg.gem = _gem;
    }
    const _dai = json.dai;
    if (_dai) {
      msg.dai = _dai;
    }
    const _ink = json.ink;
    if (_ink) {
      msg.ink = _ink;
    }
    const _art = json.art;
    if (_art) {
      msg.art = _art;
    }
    const _rate = json.rate;
    if (_rate) {
      msg.rate = _rate;
    }
    const _rho = json.rho;
    if (_rho) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _rho);
      msg.rho = m;
    }
    const _debt = json.debt;
    if (_debt) {
      msg.debt = _debt;
    }
    const _line = json.line;
    if (_line) {
      msg.line = _line;
    }
    const _dust = json.dust;
    if (_dust) {
      msg.dust = _dust;
    }
    const _price = json.price;
    if (_price) {
      msg.price = _price;
    }
    const _mat = json.mat;
    if (_mat) {
      msg.mat = _mat;
    }
    const _duty = json.duty;
    if (_duty) {
      msg.duty = _duty;
    }
    const _chop = json.chop;
    if (_chop) {
      msg.chop = _chop;
    }
    const _dunk = json.dunk;
    if (_dunk) {
      msg.dunk = _dunk;
    }
    const _beg = json.beg;
    if (_beg) {
      msg.beg = _beg;
    }
    const _ttl = json.ttl;
    if (_ttl) {
      msg.ttl = _ttl;
    }
    const _tau = json.tau;
    if (_tau) {
      msg.tau = _tau;
    }
    const _live = json.live;
    if (_live) {
      msg.live = _live;
    }
    const _numberOfVaults = json.numberOfVaults ?? json.number_of_vaults;
    if (_numberOfVaults) {
      msg.numberOfVaults = BigInt(_numberOfVaults);
    }
    const _box = json.box;
    if (_box) {
      msg.box = _box;
    }
    const _litter = json.litter;
    if (_litter) {
      msg.litter = _litter;
    }
    const _supply = json.supply;
    if (_supply) {
      msg.supply = _supply;
    }
    return msg;
  },
};

export const VaultJSON = {
  /**
   * Serializes Vault to JSON.
   */
  encode: function (msg: Partial<Vault>): string {
    return JSON.stringify(VaultJSON._writeMessage(msg));
  },

  /**
   * Deserializes Vault from JSON.
   */
  decode: function (json: string): Vault {
    return VaultJSON._readMessage(VaultJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Vault with all fields set to their default value.
   */
  initialize: function (): Vault {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      collateralId: "",
      ink: "",
      art: "",
      identityId: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Vault>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.collateralId) {
      json.collateralId = msg.collateralId;
    }
    if (msg.ink) {
      json.ink = msg.ink;
    }
    if (msg.art) {
      json.art = msg.art;
    }
    if (msg.identityId) {
      json.identityId = msg.identityId.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Vault, json: any): Vault {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _collateralId = json.collateralId ?? json.collateral_id;
    if (_collateralId) {
      msg.collateralId = _collateralId;
    }
    const _ink = json.ink;
    if (_ink) {
      msg.ink = _ink;
    }
    const _art = json.art;
    if (_art) {
      msg.art = _art;
    }
    const _identityId = json.identityId ?? json.identity_id;
    if (_identityId) {
      msg.identityId = BigInt(_identityId);
    }
    return msg;
  },

  Event: {
    /**
     * Serializes Vault.Event to JSON.
     */
    encode: function (msg: Partial<Vault.Event>): string {
      return JSON.stringify(VaultJSON.Event._writeMessage(msg));
    },

    /**
     * Deserializes Vault.Event from JSON.
     */
    decode: function (json: string): Vault.Event {
      return VaultJSON.Event._readMessage(
        VaultJSON.Event.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Vault.Event with all fields set to their default value.
     */
    initialize: function (): Vault.Event {
      return {
        vaultId: "",
        createdAt: Timestamp.initialize(),
        action: Action._fromInt(0),
        dink: "",
        dart: "",
        debt: "",
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Vault.Event>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaultId) {
        json.vaultId = msg.vaultId;
      }
      if (msg.createdAt) {
        const createdAt = TimestampJSON._writeMessage(msg.createdAt);
        if (Object.keys(createdAt).length > 0) {
          json.createdAt = createdAt;
        }
      }
      if (msg.action && ActionJSON._toInt(msg.action)) {
        json.action = msg.action;
      }
      if (msg.dink) {
        json.dink = msg.dink;
      }
      if (msg.dart) {
        json.dart = msg.dart;
      }
      if (msg.debt) {
        json.debt = msg.debt;
      }
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Vault.Event, json: any): Vault.Event {
      const _vaultId = json.vaultId ?? json.vault_id;
      if (_vaultId) {
        msg.vaultId = _vaultId;
      }
      const _createdAt = json.createdAt ?? json.created_at;
      if (_createdAt) {
        const m = Timestamp.initialize();
        TimestampJSON._readMessage(m, _createdAt);
        msg.createdAt = m;
      }
      const _action = json.action;
      if (_action) {
        msg.action = _action;
      }
      const _dink = json.dink;
      if (_dink) {
        msg.dink = _dink;
      }
      const _dart = json.dart;
      if (_dart) {
        msg.dart = _dart;
      }
      const _debt = json.debt;
      if (_debt) {
        msg.debt = _debt;
      }
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },
};

export const FlipJSON = {
  /**
   * Serializes Flip to JSON.
   */
  encode: function (msg: Partial<Flip>): string {
    return JSON.stringify(FlipJSON._writeMessage(msg));
  },

  /**
   * Deserializes Flip from JSON.
   */
  decode: function (json: string): Flip {
    return FlipJSON._readMessage(FlipJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Flip with all fields set to their default value.
   */
  initialize: function (): Flip {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      tic: Timestamp.initialize(),
      end: Timestamp.initialize(),
      bid: "",
      lot: "",
      tab: "",
      art: "",
      collateralId: "",
      vaultId: "",
      guy: "",
      action: Action._fromInt(0),
      tags: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Flip>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.tic) {
      const tic = TimestampJSON._writeMessage(msg.tic);
      if (Object.keys(tic).length > 0) {
        json.tic = tic;
      }
    }
    if (msg.end) {
      const end = TimestampJSON._writeMessage(msg.end);
      if (Object.keys(end).length > 0) {
        json.end = end;
      }
    }
    if (msg.bid) {
      json.bid = msg.bid;
    }
    if (msg.lot) {
      json.lot = msg.lot;
    }
    if (msg.tab) {
      json.tab = msg.tab;
    }
    if (msg.art) {
      json.art = msg.art;
    }
    if (msg.collateralId) {
      json.collateralId = msg.collateralId;
    }
    if (msg.vaultId) {
      json.vaultId = msg.vaultId;
    }
    if (msg.guy) {
      json.guy = msg.guy;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json.action = msg.action;
    }
    if (msg.tags?.length) {
      json.tags = msg.tags;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Flip, json: any): Flip {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _tic = json.tic;
    if (_tic) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _tic);
      msg.tic = m;
    }
    const _end = json.end;
    if (_end) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _end);
      msg.end = m;
    }
    const _bid = json.bid;
    if (_bid) {
      msg.bid = _bid;
    }
    const _lot = json.lot;
    if (_lot) {
      msg.lot = _lot;
    }
    const _tab = json.tab;
    if (_tab) {
      msg.tab = _tab;
    }
    const _art = json.art;
    if (_art) {
      msg.art = _art;
    }
    const _collateralId = json.collateralId ?? json.collateral_id;
    if (_collateralId) {
      msg.collateralId = _collateralId;
    }
    const _vaultId = json.vaultId ?? json.vault_id;
    if (_vaultId) {
      msg.vaultId = _vaultId;
    }
    const _guy = json.guy;
    if (_guy) {
      msg.guy = _guy;
    }
    const _action = json.action;
    if (_action) {
      msg.action = _action;
    }
    const _tags = json.tags;
    if (_tags) {
      msg.tags = _tags;
    }
    return msg;
  },

  Tag: {
    MyVault: "MyVault",
    Participated: "Participated",
    Leading: "Leading",
    /**
     * @private
     */
    _fromInt: function (i: number): Flip.Tag {
      switch (i) {
        case 0: {
          return "MyVault";
        }
        case 1: {
          return "Participated";
        }
        case 2: {
          return "Leading";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Flip.Tag;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Flip.Tag): number {
      switch (i) {
        case "MyVault": {
          return 0;
        }
        case "Participated": {
          return 1;
        }
        case "Leading": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Event: {
    /**
     * Serializes Flip.Event to JSON.
     */
    encode: function (msg: Partial<Flip.Event>): string {
      return JSON.stringify(FlipJSON.Event._writeMessage(msg));
    },

    /**
     * Deserializes Flip.Event from JSON.
     */
    decode: function (json: string): Flip.Event {
      return FlipJSON.Event._readMessage(
        FlipJSON.Event.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Flip.Event with all fields set to their default value.
     */
    initialize: function (): Flip.Event {
      return {
        flipId: "",
        createdAt: Timestamp.initialize(),
        action: Action._fromInt(0),
        bid: "",
        lot: "",
        isMe: false,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Flip.Event>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flipId) {
        json.flipId = msg.flipId;
      }
      if (msg.createdAt) {
        const createdAt = TimestampJSON._writeMessage(msg.createdAt);
        if (Object.keys(createdAt).length > 0) {
          json.createdAt = createdAt;
        }
      }
      if (msg.action && ActionJSON._toInt(msg.action)) {
        json.action = msg.action;
      }
      if (msg.bid) {
        json.bid = msg.bid;
      }
      if (msg.lot) {
        json.lot = msg.lot;
      }
      if (msg.isMe) {
        json.isMe = msg.isMe;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Flip.Event, json: any): Flip.Event {
      const _flipId = json.flipId ?? json.flip_id;
      if (_flipId) {
        msg.flipId = _flipId;
      }
      const _createdAt = json.createdAt ?? json.created_at;
      if (_createdAt) {
        const m = Timestamp.initialize();
        TimestampJSON._readMessage(m, _createdAt);
        msg.createdAt = m;
      }
      const _action = json.action;
      if (_action) {
        msg.action = _action;
      }
      const _bid = json.bid;
      if (_bid) {
        msg.bid = _bid;
      }
      const _lot = json.lot;
      if (_lot) {
        msg.lot = _lot;
      }
      const _isMe = json.isMe ?? json.is_me;
      if (_isMe) {
        msg.isMe = _isMe;
      }
      return msg;
    },
  },
};

export const ProposalJSON = {
  /**
   * Serializes Proposal to JSON.
   */
  encode: function (msg: Partial<Proposal>): string {
    return JSON.stringify(ProposalJSON._writeMessage(msg));
  },

  /**
   * Deserializes Proposal from JSON.
   */
  decode: function (json: string): Proposal {
    return ProposalJSON._readMessage(
      ProposalJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (): Proposal {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      passedAt: Timestamp.initialize(),
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      data: "",
      votes: [],
      items: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Proposal>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.passedAt) {
      const passedAt = TimestampJSON._writeMessage(msg.passedAt);
      if (Object.keys(passedAt).length > 0) {
        json.passedAt = passedAt;
      }
    }
    if (msg.creator) {
      json.creator = msg.creator;
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json.action = msg.action;
    }
    if (msg.data) {
      json.data = msg.data;
    }
    if (msg.votes?.length) {
      json.votes = msg.votes;
    }
    if (msg.items?.length) {
      json.items = msg.items.map(ProposalJSON.Item._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Proposal, json: any): Proposal {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _passedAt = json.passedAt ?? json.passed_at;
    if (_passedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _passedAt);
      msg.passedAt = m;
    }
    const _creator = json.creator;
    if (_creator) {
      msg.creator = _creator;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _action = json.action;
    if (_action) {
      msg.action = _action;
    }
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    const _votes = json.votes;
    if (_votes) {
      msg.votes = _votes;
    }
    const _items = json.items;
    if (_items) {
      for (const item of _items) {
        const m = Proposal.Item.initialize();
        ProposalJSON.Item._readMessage(m, item);
        msg.items.push(m);
      }
    }
    return msg;
  },

  Item: {
    /**
     * Serializes Proposal.Item to JSON.
     */
    encode: function (msg: Partial<Proposal.Item>): string {
      return JSON.stringify(ProposalJSON.Item._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.Item from JSON.
     */
    decode: function (json: string): Proposal.Item {
      return ProposalJSON.Item._readMessage(
        ProposalJSON.Item.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Proposal.Item with all fields set to their default value.
     */
    initialize: function (): Proposal.Item {
      return {
        key: "",
        value: "",
        hint: "",
        action: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Proposal.Item>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      if (msg.hint) {
        json.hint = msg.hint;
      }
      if (msg.action) {
        json.action = msg.action;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Proposal.Item, json: any): Proposal.Item {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      const _hint = json.hint;
      if (_hint) {
        msg.hint = _hint;
      }
      const _action = json.action;
      if (_action) {
        msg.action = _action;
      }
      return msg;
    },
  },
};

export const OracleJSON = {
  /**
   * Serializes Oracle to JSON.
   */
  encode: function (msg: Partial<Oracle>): string {
    return JSON.stringify(OracleJSON._writeMessage(msg));
  },

  /**
   * Deserializes Oracle from JSON.
   */
  decode: function (json: string): Oracle {
    return OracleJSON._readMessage(OracleJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Oracle with all fields set to their default value.
   */
  initialize: function (): Oracle {
    return {
      assetId: "",
      hop: 0,
      current: "",
      next: "",
      peekAt: Timestamp.initialize(),
      threshold: 0,
      governors: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Oracle>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.hop) {
      json.hop = msg.hop;
    }
    if (msg.current) {
      json.current = msg.current;
    }
    if (msg.next) {
      json.next = msg.next;
    }
    if (msg.peekAt) {
      const peekAt = TimestampJSON._writeMessage(msg.peekAt);
      if (Object.keys(peekAt).length > 0) {
        json.peekAt = peekAt;
      }
    }
    if (msg.threshold) {
      json.threshold = msg.threshold;
    }
    if (msg.governors?.length) {
      json.governors = msg.governors;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Oracle, json: any): Oracle {
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _hop = json.hop;
    if (_hop) {
      msg.hop = _hop;
    }
    const _current = json.current;
    if (_current) {
      msg.current = _current;
    }
    const _next = json.next;
    if (_next) {
      msg.next = _next;
    }
    const _peekAt = json.peekAt ?? json.peek_at;
    if (_peekAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _peekAt);
      msg.peekAt = m;
    }
    const _threshold = json.threshold;
    if (_threshold) {
      msg.threshold = _threshold;
    }
    const _governors = json.governors;
    if (_governors) {
      msg.governors = _governors;
    }
    return msg;
  },
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: Partial<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (): Transaction {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      status: Transaction.Status._fromInt(0),
      msg: "",
      parameters: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Transaction>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json.action = msg.action;
    }
    if (msg.status && TransactionJSON.Status._toInt(msg.status)) {
      json.status = msg.status;
    }
    if (msg.msg) {
      json.msg = msg.msg;
    }
    if (msg.parameters) {
      json.parameters = msg.parameters;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _action = json.action;
    if (_action) {
      msg.action = _action;
    }
    const _status = json.status;
    if (_status) {
      msg.status = _status;
    }
    const _msg = json.msg;
    if (_msg) {
      msg.msg = _msg;
    }
    const _parameters = json.parameters;
    if (_parameters) {
      msg.parameters = _parameters;
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Abort: "Abort",
    OK: "OK",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Abort";
        }
        case 2: {
          return "OK";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Abort": {
          return 1;
        }
        case "OK": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const StatJSON = {
  /**
   * Serializes Stat to JSON.
   */
  encode: function (msg: Partial<Stat>): string {
    return JSON.stringify(StatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Stat from JSON.
   */
  decode: function (json: string): Stat {
    return StatJSON._readMessage(StatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Stat with all fields set to their default value.
   */
  initialize: function (): Stat {
    return {
      collateralId: "",
      date: Timestamp.initialize(),
      timestamp: 0n,
      gem: "",
      dai: "",
      ink: "",
      debt: "",
      gemPrice: "",
      daiPrice: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Stat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.collateralId) {
      json.collateralId = msg.collateralId;
    }
    if (msg.date) {
      const date = TimestampJSON._writeMessage(msg.date);
      if (Object.keys(date).length > 0) {
        json.date = date;
      }
    }
    if (msg.timestamp) {
      json.timestamp = msg.timestamp.toString();
    }
    if (msg.gem) {
      json.gem = msg.gem;
    }
    if (msg.dai) {
      json.dai = msg.dai;
    }
    if (msg.ink) {
      json.ink = msg.ink;
    }
    if (msg.debt) {
      json.debt = msg.debt;
    }
    if (msg.gemPrice) {
      json.gemPrice = msg.gemPrice;
    }
    if (msg.daiPrice) {
      json.daiPrice = msg.daiPrice;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Stat, json: any): Stat {
    const _collateralId = json.collateralId ?? json.collateral_id;
    if (_collateralId) {
      msg.collateralId = _collateralId;
    }
    const _date = json.date;
    if (_date) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _date);
      msg.date = m;
    }
    const _timestamp = json.timestamp;
    if (_timestamp) {
      msg.timestamp = BigInt(_timestamp);
    }
    const _gem = json.gem;
    if (_gem) {
      msg.gem = _gem;
    }
    const _dai = json.dai;
    if (_dai) {
      msg.dai = _dai;
    }
    const _ink = json.ink;
    if (_ink) {
      msg.ink = _ink;
    }
    const _debt = json.debt;
    if (_debt) {
      msg.debt = _debt;
    }
    const _gemPrice = json.gemPrice ?? json.gem_price;
    if (_gemPrice) {
      msg.gemPrice = _gemPrice;
    }
    const _daiPrice = json.daiPrice ?? json.dai_price;
    if (_daiPrice) {
      msg.daiPrice = _daiPrice;
    }
    return msg;
  },
};

export const AggregatedStatJSON = {
  /**
   * Serializes AggregatedStat to JSON.
   */
  encode: function (msg: Partial<AggregatedStat>): string {
    return JSON.stringify(AggregatedStatJSON._writeMessage(msg));
  },

  /**
   * Deserializes AggregatedStat from JSON.
   */
  decode: function (json: string): AggregatedStat {
    return AggregatedStatJSON._readMessage(
      AggregatedStatJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes AggregatedStat with all fields set to their default value.
   */
  initialize: function (): AggregatedStat {
    return {
      date: Timestamp.initialize(),
      timestamp: 0n,
      gemValue: "",
      daiValue: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<AggregatedStat>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.date) {
      const date = TimestampJSON._writeMessage(msg.date);
      if (Object.keys(date).length > 0) {
        json.date = date;
      }
    }
    if (msg.timestamp) {
      json.timestamp = msg.timestamp.toString();
    }
    if (msg.gemValue) {
      json.gemValue = msg.gemValue;
    }
    if (msg.daiValue) {
      json.daiValue = msg.daiValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: AggregatedStat, json: any): AggregatedStat {
    const _date = json.date;
    if (_date) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _date);
      msg.date = m;
    }
    const _timestamp = json.timestamp;
    if (_timestamp) {
      msg.timestamp = BigInt(_timestamp);
    }
    const _gemValue = json.gemValue ?? json.gem_value;
    if (_gemValue) {
      msg.gemValue = _gemValue;
    }
    const _daiValue = json.daiValue ?? json.dai_value;
    if (_daiValue) {
      msg.daiValue = _daiValue;
    }
    return msg;
  },
};

export const AuditJSON = {
  /**
   * Serializes Audit to JSON.
   */
  encode: function (msg: Partial<Audit>): string {
    return JSON.stringify(AuditJSON._writeMessage(msg));
  },

  /**
   * Deserializes Audit from JSON.
   */
  decode: function (json: string): Audit {
    return AuditJSON._readMessage(AuditJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (): Audit {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Audit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.status && AuditJSON.Status._toInt(msg.status)) {
      json.status = msg.status;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    if (msg.reviewedBy) {
      json.reviewedBy = msg.reviewedBy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, json: any): Audit {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _status = json.status;
    if (_status) {
      msg.status = _status;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    const _reviewedBy = json.reviewedBy ?? json.reviewed_by;
    if (_reviewedBy) {
      msg.reviewedBy = _reviewedBy;
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Rejected: "Rejected",
    Approved: "Approved",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Rejected";
        }
        case 2: {
          return "Approved";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Rejected": {
          return 1;
        }
        case "Approved": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg?: Partial<Req>): string {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json?: string): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<Req>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Req, _json: any): Req {
    return msg;
  },

  FindAsset: {
    /**
     * Serializes Req.FindAsset to JSON.
     */
    encode: function (msg: Partial<Req.FindAsset>): string {
      return JSON.stringify(ReqJSON.FindAsset._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindAsset from JSON.
     */
    decode: function (json: string): Req.FindAsset {
      return ReqJSON.FindAsset._readMessage(
        ReqJSON.FindAsset.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindAsset with all fields set to their default value.
     */
    initialize: function (): Req.FindAsset {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindAsset>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindAsset, json: any): Req.FindAsset {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListAssets: {
    /**
     * Serializes Req.ListAssets to JSON.
     */
    encode: function (_msg?: Partial<Req.ListAssets>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListAssets from JSON.
     */
    decode: function (_json?: string): Req.ListAssets {
      return {};
    },

    /**
     * Initializes Req.ListAssets with all fields set to their default value.
     */
    initialize: function (): Req.ListAssets {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListAssets>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListAssets, _json: any): Req.ListAssets {
      return msg;
    },
  },

  FindOracle: {
    /**
     * Serializes Req.FindOracle to JSON.
     */
    encode: function (msg: Partial<Req.FindOracle>): string {
      return JSON.stringify(ReqJSON.FindOracle._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindOracle from JSON.
     */
    decode: function (json: string): Req.FindOracle {
      return ReqJSON.FindOracle._readMessage(
        ReqJSON.FindOracle.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindOracle with all fields set to their default value.
     */
    initialize: function (): Req.FindOracle {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindOracle>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindOracle, json: any): Req.FindOracle {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Req.ListOracles to JSON.
     */
    encode: function (_msg?: Partial<Req.ListOracles>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListOracles from JSON.
     */
    decode: function (_json?: string): Req.ListOracles {
      return {};
    },

    /**
     * Initializes Req.ListOracles with all fields set to their default value.
     */
    initialize: function (): Req.ListOracles {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListOracles>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListOracles, _json: any): Req.ListOracles {
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Req.ListCollaterals to JSON.
     */
    encode: function (_msg?: Partial<Req.ListCollaterals>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListCollaterals from JSON.
     */
    decode: function (_json?: string): Req.ListCollaterals {
      return {};
    },

    /**
     * Initializes Req.ListCollaterals with all fields set to their default value.
     */
    initialize: function (): Req.ListCollaterals {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.ListCollaterals>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListCollaterals,
      _json: any
    ): Req.ListCollaterals {
      return msg;
    },
  },

  FindCollateral: {
    /**
     * Serializes Req.FindCollateral to JSON.
     */
    encode: function (msg: Partial<Req.FindCollateral>): string {
      return JSON.stringify(ReqJSON.FindCollateral._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindCollateral from JSON.
     */
    decode: function (json: string): Req.FindCollateral {
      return ReqJSON.FindCollateral._readMessage(
        ReqJSON.FindCollateral.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindCollateral with all fields set to their default value.
     */
    initialize: function (): Req.FindCollateral {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindCollateral>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindCollateral,
      json: any
    ): Req.FindCollateral {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  FindVault: {
    /**
     * Serializes Req.FindVault to JSON.
     */
    encode: function (msg: Partial<Req.FindVault>): string {
      return JSON.stringify(ReqJSON.FindVault._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindVault from JSON.
     */
    decode: function (json: string): Req.FindVault {
      return ReqJSON.FindVault._readMessage(
        ReqJSON.FindVault.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindVault with all fields set to their default value.
     */
    initialize: function (): Req.FindVault {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindVault>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindVault, json: any): Req.FindVault {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Req.ListVaults to JSON.
     */
    encode: function (msg: Partial<Req.ListVaults>): string {
      return JSON.stringify(ReqJSON.ListVaults._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListVaults from JSON.
     */
    decode: function (json: string): Req.ListVaults {
      return ReqJSON.ListVaults._readMessage(
        ReqJSON.ListVaults.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListVaults with all fields set to their default value.
     */
    initialize: function (): Req.ListVaults {
      return {
        collateralId: "",
        userId: "",
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListVaults>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.collateralId) {
        json.collateralId = msg.collateralId;
      }
      if (msg.userId) {
        json.userId = msg.userId;
      }
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListVaults, json: any): Req.ListVaults {
      const _collateralId = json.collateralId ?? json.collateral_id;
      if (_collateralId) {
        msg.collateralId = _collateralId;
      }
      const _userId = json.userId ?? json.user_id;
      if (_userId) {
        msg.userId = _userId;
      }
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Req.ListMyVaults to JSON.
     */
    encode: function (msg: Partial<Req.ListMyVaults>): string {
      return JSON.stringify(ReqJSON.ListMyVaults._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListMyVaults from JSON.
     */
    decode: function (json: string): Req.ListMyVaults {
      return ReqJSON.ListMyVaults._readMessage(
        ReqJSON.ListMyVaults.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListMyVaults with all fields set to their default value.
     */
    initialize: function (): Req.ListMyVaults {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListMyVaults>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListMyVaults,
      json: any
    ): Req.ListMyVaults {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Req.ListVaultEvents to JSON.
     */
    encode: function (msg: Partial<Req.ListVaultEvents>): string {
      return JSON.stringify(ReqJSON.ListVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListVaultEvents from JSON.
     */
    decode: function (json: string): Req.ListVaultEvents {
      return ReqJSON.ListVaultEvents._readMessage(
        ReqJSON.ListVaultEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (): Req.ListVaultEvents {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListVaultEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaultEvents,
      json: any
    ): Req.ListVaultEvents {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Req.QueryVaultEvents to JSON.
     */
    encode: function (msg: Partial<Req.QueryVaultEvents>): string {
      return JSON.stringify(ReqJSON.QueryVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.QueryVaultEvents from JSON.
     */
    decode: function (json: string): Req.QueryVaultEvents {
      return ReqJSON.QueryVaultEvents._readMessage(
        ReqJSON.QueryVaultEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (): Req.QueryVaultEvents {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.QueryVaultEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryVaultEvents,
      json: any
    ): Req.QueryVaultEvents {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  FindFlip: {
    /**
     * Serializes Req.FindFlip to JSON.
     */
    encode: function (msg: Partial<Req.FindFlip>): string {
      return JSON.stringify(ReqJSON.FindFlip._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindFlip from JSON.
     */
    decode: function (json: string): Req.FindFlip {
      return ReqJSON.FindFlip._readMessage(
        ReqJSON.FindFlip.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindFlip with all fields set to their default value.
     */
    initialize: function (): Req.FindFlip {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindFlip>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindFlip, json: any): Req.FindFlip {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Req.ListFlips to JSON.
     */
    encode: function (msg: Partial<Req.ListFlips>): string {
      return JSON.stringify(ReqJSON.ListFlips._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListFlips from JSON.
     */
    decode: function (json: string): Req.ListFlips {
      return ReqJSON.ListFlips._readMessage(
        ReqJSON.ListFlips.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListFlips with all fields set to their default value.
     */
    initialize: function (): Req.ListFlips {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListFlips>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListFlips, json: any): Req.ListFlips {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Req.QueryFlips to JSON.
     */
    encode: function (msg: Partial<Req.QueryFlips>): string {
      return JSON.stringify(ReqJSON.QueryFlips._writeMessage(msg));
    },

    /**
     * Deserializes Req.QueryFlips from JSON.
     */
    decode: function (json: string): Req.QueryFlips {
      return ReqJSON.QueryFlips._readMessage(
        ReqJSON.QueryFlips.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.QueryFlips with all fields set to their default value.
     */
    initialize: function (): Req.QueryFlips {
      return {
        offset: 0n,
        limit: 0n,
        phase: "",
        myVaults: "",
        myBids: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.QueryFlips>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.offset) {
        json.offset = msg.offset.toString();
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      if (msg.phase) {
        json.phase = msg.phase;
      }
      if (msg.myVaults) {
        json.myVaults = msg.myVaults;
      }
      if (msg.myBids) {
        json.myBids = msg.myBids;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.QueryFlips, json: any): Req.QueryFlips {
      const _offset = json.offset;
      if (_offset) {
        msg.offset = BigInt(_offset);
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      const _phase = json.phase;
      if (_phase) {
        msg.phase = _phase;
      }
      const _myVaults = json.myVaults ?? json.my_vaults;
      if (_myVaults) {
        msg.myVaults = _myVaults;
      }
      const _myBids = json.myBids ?? json.my_bids;
      if (_myBids) {
        msg.myBids = _myBids;
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Req.ListFlipEvents to JSON.
     */
    encode: function (msg: Partial<Req.ListFlipEvents>): string {
      return JSON.stringify(ReqJSON.ListFlipEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListFlipEvents from JSON.
     */
    decode: function (json: string): Req.ListFlipEvents {
      return ReqJSON.ListFlipEvents._readMessage(
        ReqJSON.ListFlipEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (): Req.ListFlipEvents {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListFlipEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlipEvents,
      json: any
    ): Req.ListFlipEvents {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  FindTransaction: {
    /**
     * Serializes Req.FindTransaction to JSON.
     */
    encode: function (msg: Partial<Req.FindTransaction>): string {
      return JSON.stringify(ReqJSON.FindTransaction._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindTransaction from JSON.
     */
    decode: function (json: string): Req.FindTransaction {
      return ReqJSON.FindTransaction._readMessage(
        ReqJSON.FindTransaction.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindTransaction with all fields set to their default value.
     */
    initialize: function (): Req.FindTransaction {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindTransaction>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindTransaction,
      json: any
    ): Req.FindTransaction {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Req.ListTransactions to JSON.
     */
    encode: function (msg: Partial<Req.ListTransactions>): string {
      return JSON.stringify(ReqJSON.ListTransactions._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListTransactions from JSON.
     */
    decode: function (json: string): Req.ListTransactions {
      return ReqJSON.ListTransactions._readMessage(
        ReqJSON.ListTransactions.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListTransactions with all fields set to their default value.
     */
    initialize: function (): Req.ListTransactions {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListTransactions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListTransactions,
      json: any
    ): Req.ListTransactions {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Req.ListProposals to JSON.
     */
    encode: function (msg: Partial<Req.ListProposals>): string {
      return JSON.stringify(ReqJSON.ListProposals._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListProposals from JSON.
     */
    decode: function (json: string): Req.ListProposals {
      return ReqJSON.ListProposals._readMessage(
        ReqJSON.ListProposals.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListProposals with all fields set to their default value.
     */
    initialize: function (): Req.ListProposals {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListProposals>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListProposals,
      json: any
    ): Req.ListProposals {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },

  FindProposal: {
    /**
     * Serializes Req.FindProposal to JSON.
     */
    encode: function (msg: Partial<Req.FindProposal>): string {
      return JSON.stringify(ReqJSON.FindProposal._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindProposal from JSON.
     */
    decode: function (json: string): Req.FindProposal {
      return ReqJSON.FindProposal._readMessage(
        ReqJSON.FindProposal.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.FindProposal with all fields set to their default value.
     */
    initialize: function (): Req.FindProposal {
      return {
        id: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.FindProposal>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindProposal,
      json: any
    ): Req.FindProposal {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Req.ListStats to JSON.
     */
    encode: function (msg: Partial<Req.ListStats>): string {
      return JSON.stringify(ReqJSON.ListStats._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListStats from JSON.
     */
    decode: function (json: string): Req.ListStats {
      return ReqJSON.ListStats._readMessage(
        ReqJSON.ListStats.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListStats with all fields set to their default value.
     */
    initialize: function (): Req.ListStats {
      return {
        id: "",
        from: 0n,
        to: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListStats>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json.id = msg.id;
      }
      if (msg.from) {
        json.from = msg.from.toString();
      }
      if (msg.to) {
        json.to = msg.to.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListStats, json: any): Req.ListStats {
      const _id = json.id;
      if (_id) {
        msg.id = _id;
      }
      const _from = json.from;
      if (_from) {
        msg.from = BigInt(_from);
      }
      const _to = json.to;
      if (_to) {
        msg.to = BigInt(_to);
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Req.ListAggregatedStats to JSON.
     */
    encode: function (msg: Partial<Req.ListAggregatedStats>): string {
      return JSON.stringify(ReqJSON.ListAggregatedStats._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListAggregatedStats from JSON.
     */
    decode: function (json: string): Req.ListAggregatedStats {
      return ReqJSON.ListAggregatedStats._readMessage(
        ReqJSON.ListAggregatedStats.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (): Req.ListAggregatedStats {
      return {
        from: 0n,
        to: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListAggregatedStats>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.from) {
        json.from = msg.from.toString();
      }
      if (msg.to) {
        json.to = msg.to.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAggregatedStats,
      json: any
    ): Req.ListAggregatedStats {
      const _from = json.from;
      if (_from) {
        msg.from = BigInt(_from);
      }
      const _to = json.to;
      if (_to) {
        msg.to = BigInt(_to);
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Req.GetInfo to JSON.
     */
    encode: function (_msg?: Partial<Req.GetInfo>): string {
      return "{}";
    },

    /**
     * Deserializes Req.GetInfo from JSON.
     */
    decode: function (_json?: string): Req.GetInfo {
      return {};
    },

    /**
     * Initializes Req.GetInfo with all fields set to their default value.
     */
    initialize: function (): Req.GetInfo {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<Req.GetInfo>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.GetInfo, _json: any): Req.GetInfo {
      return msg;
    },
  },

  ListAudit: {
    /**
     * Serializes Req.ListAudit to JSON.
     */
    encode: function (msg: Partial<Req.ListAudit>): string {
      return JSON.stringify(ReqJSON.ListAudit._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListAudit from JSON.
     */
    decode: function (json: string): Req.ListAudit {
      return ReqJSON.ListAudit._readMessage(
        ReqJSON.ListAudit.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.ListAudit with all fields set to their default value.
     */
    initialize: function (): Req.ListAudit {
      return {
        cursor: "",
        limit: 0n,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.ListAudit>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json.cursor = msg.cursor;
      }
      if (msg.limit) {
        json.limit = msg.limit.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListAudit, json: any): Req.ListAudit {
      const _cursor = json.cursor;
      if (_cursor) {
        msg.cursor = _cursor;
      }
      const _limit = json.limit;
      if (_limit) {
        msg.limit = BigInt(_limit);
      }
      return msg;
    },
  },
};

export const RespJSON = {
  /**
   * Serializes Resp to JSON.
   */
  encode: function (_msg?: Partial<Resp>): string {
    return "{}";
  },

  /**
   * Deserializes Resp from JSON.
   */
  decode: function (_json?: string): Resp {
    return {};
  },

  /**
   * Initializes Resp with all fields set to their default value.
   */
  initialize: function (): Resp {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<Resp>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Resp, _json: any): Resp {
    return msg;
  },

  ListAssets: {
    /**
     * Serializes Resp.ListAssets to JSON.
     */
    encode: function (msg: Partial<Resp.ListAssets>): string {
      return JSON.stringify(RespJSON.ListAssets._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAssets from JSON.
     */
    decode: function (json: string): Resp.ListAssets {
      return RespJSON.ListAssets._readMessage(
        RespJSON.ListAssets.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListAssets with all fields set to their default value.
     */
    initialize: function (): Resp.ListAssets {
      return {
        assets: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAssets>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.assets?.length) {
        json.assets = msg.assets.map(AssetJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListAssets, json: any): Resp.ListAssets {
      const _assets = json.assets;
      if (_assets) {
        for (const item of _assets) {
          const m = Asset.initialize();
          AssetJSON._readMessage(m, item);
          msg.assets.push(m);
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Resp.ListOracles to JSON.
     */
    encode: function (msg: Partial<Resp.ListOracles>): string {
      return JSON.stringify(RespJSON.ListOracles._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListOracles from JSON.
     */
    decode: function (json: string): Resp.ListOracles {
      return RespJSON.ListOracles._readMessage(
        RespJSON.ListOracles.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListOracles with all fields set to their default value.
     */
    initialize: function (): Resp.ListOracles {
      return {
        oracles: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListOracles>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oracles?.length) {
        json.oracles = msg.oracles.map(OracleJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListOracles,
      json: any
    ): Resp.ListOracles {
      const _oracles = json.oracles;
      if (_oracles) {
        for (const item of _oracles) {
          const m = Oracle.initialize();
          OracleJSON._readMessage(m, item);
          msg.oracles.push(m);
        }
      }
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Resp.ListCollaterals to JSON.
     */
    encode: function (msg: Partial<Resp.ListCollaterals>): string {
      return JSON.stringify(RespJSON.ListCollaterals._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListCollaterals from JSON.
     */
    decode: function (json: string): Resp.ListCollaterals {
      return RespJSON.ListCollaterals._readMessage(
        RespJSON.ListCollaterals.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListCollaterals with all fields set to their default value.
     */
    initialize: function (): Resp.ListCollaterals {
      return {
        collaterals: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListCollaterals>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.collaterals?.length) {
        json.collaterals = msg.collaterals.map(CollateralJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListCollaterals,
      json: any
    ): Resp.ListCollaterals {
      const _collaterals = json.collaterals;
      if (_collaterals) {
        for (const item of _collaterals) {
          const m = Collateral.initialize();
          CollateralJSON._readMessage(m, item);
          msg.collaterals.push(m);
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Resp.ListVaults to JSON.
     */
    encode: function (msg: Partial<Resp.ListVaults>): string {
      return JSON.stringify(RespJSON.ListVaults._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListVaults from JSON.
     */
    decode: function (json: string): Resp.ListVaults {
      return RespJSON.ListVaults._readMessage(
        RespJSON.ListVaults.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListVaults with all fields set to their default value.
     */
    initialize: function (): Resp.ListVaults {
      return {
        vaults: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListVaults>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaults?.length) {
        json.vaults = msg.vaults.map(VaultJSON._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListVaults, json: any): Resp.ListVaults {
      const _vaults = json.vaults;
      if (_vaults) {
        for (const item of _vaults) {
          const m = Vault.initialize();
          VaultJSON._readMessage(m, item);
          msg.vaults.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Resp.ListMyVaults to JSON.
     */
    encode: function (msg: Partial<Resp.ListMyVaults>): string {
      return JSON.stringify(RespJSON.ListMyVaults._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListMyVaults from JSON.
     */
    decode: function (json: string): Resp.ListMyVaults {
      return RespJSON.ListMyVaults._readMessage(
        RespJSON.ListMyVaults.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListMyVaults with all fields set to their default value.
     */
    initialize: function (): Resp.ListMyVaults {
      return {
        vaults: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListMyVaults>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaults?.length) {
        json.vaults = msg.vaults.map(VaultJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListMyVaults,
      json: any
    ): Resp.ListMyVaults {
      const _vaults = json.vaults;
      if (_vaults) {
        for (const item of _vaults) {
          const m = Vault.initialize();
          VaultJSON._readMessage(m, item);
          msg.vaults.push(m);
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Resp.ListVaultEvents to JSON.
     */
    encode: function (msg: Partial<Resp.ListVaultEvents>): string {
      return JSON.stringify(RespJSON.ListVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListVaultEvents from JSON.
     */
    decode: function (json: string): Resp.ListVaultEvents {
      return RespJSON.ListVaultEvents._readMessage(
        RespJSON.ListVaultEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (): Resp.ListVaultEvents {
      return {
        events: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListVaultEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json.events = msg.events.map(VaultJSON.Event._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaultEvents,
      json: any
    ): Resp.ListVaultEvents {
      const _events = json.events;
      if (_events) {
        for (const item of _events) {
          const m = Vault.Event.initialize();
          VaultJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Resp.QueryVaultEvents to JSON.
     */
    encode: function (msg: Partial<Resp.QueryVaultEvents>): string {
      return JSON.stringify(RespJSON.QueryVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.QueryVaultEvents from JSON.
     */
    decode: function (json: string): Resp.QueryVaultEvents {
      return RespJSON.QueryVaultEvents._readMessage(
        RespJSON.QueryVaultEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (): Resp.QueryVaultEvents {
      return {
        events: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.QueryVaultEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json.events = msg.events.map(VaultJSON.Event._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryVaultEvents,
      json: any
    ): Resp.QueryVaultEvents {
      const _events = json.events;
      if (_events) {
        for (const item of _events) {
          const m = Vault.Event.initialize();
          VaultJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Resp.ListFlips to JSON.
     */
    encode: function (msg: Partial<Resp.ListFlips>): string {
      return JSON.stringify(RespJSON.ListFlips._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListFlips from JSON.
     */
    decode: function (json: string): Resp.ListFlips {
      return RespJSON.ListFlips._readMessage(
        RespJSON.ListFlips.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListFlips with all fields set to their default value.
     */
    initialize: function (): Resp.ListFlips {
      return {
        flips: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListFlips>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flips?.length) {
        json.flips = msg.flips.map(FlipJSON._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListFlips, json: any): Resp.ListFlips {
      const _flips = json.flips;
      if (_flips) {
        for (const item of _flips) {
          const m = Flip.initialize();
          FlipJSON._readMessage(m, item);
          msg.flips.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Resp.QueryFlips to JSON.
     */
    encode: function (msg: Partial<Resp.QueryFlips>): string {
      return JSON.stringify(RespJSON.QueryFlips._writeMessage(msg));
    },

    /**
     * Deserializes Resp.QueryFlips from JSON.
     */
    decode: function (json: string): Resp.QueryFlips {
      return RespJSON.QueryFlips._readMessage(
        RespJSON.QueryFlips.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.QueryFlips with all fields set to their default value.
     */
    initialize: function (): Resp.QueryFlips {
      return {
        flips: [],
        total: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.QueryFlips>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flips?.length) {
        json.flips = msg.flips.map(FlipJSON._writeMessage);
      }
      if (msg.total) {
        json.total = msg.total;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.QueryFlips, json: any): Resp.QueryFlips {
      const _flips = json.flips;
      if (_flips) {
        for (const item of _flips) {
          const m = Flip.initialize();
          FlipJSON._readMessage(m, item);
          msg.flips.push(m);
        }
      }
      const _total = json.total;
      if (_total) {
        msg.total = _total;
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Resp.ListFlipEvents to JSON.
     */
    encode: function (msg: Partial<Resp.ListFlipEvents>): string {
      return JSON.stringify(RespJSON.ListFlipEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListFlipEvents from JSON.
     */
    decode: function (json: string): Resp.ListFlipEvents {
      return RespJSON.ListFlipEvents._readMessage(
        RespJSON.ListFlipEvents.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (): Resp.ListFlipEvents {
      return {
        events: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListFlipEvents>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json.events = msg.events.map(FlipJSON.Event._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlipEvents,
      json: any
    ): Resp.ListFlipEvents {
      const _events = json.events;
      if (_events) {
        for (const item of _events) {
          const m = Flip.Event.initialize();
          FlipJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Resp.ListTransactions to JSON.
     */
    encode: function (msg: Partial<Resp.ListTransactions>): string {
      return JSON.stringify(RespJSON.ListTransactions._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListTransactions from JSON.
     */
    decode: function (json: string): Resp.ListTransactions {
      return RespJSON.ListTransactions._readMessage(
        RespJSON.ListTransactions.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListTransactions with all fields set to their default value.
     */
    initialize: function (): Resp.ListTransactions {
      return {
        transactions: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListTransactions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.transactions?.length) {
        json.transactions = msg.transactions.map(TransactionJSON._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListTransactions,
      json: any
    ): Resp.ListTransactions {
      const _transactions = json.transactions;
      if (_transactions) {
        for (const item of _transactions) {
          const m = Transaction.initialize();
          TransactionJSON._readMessage(m, item);
          msg.transactions.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Resp.ListProposals to JSON.
     */
    encode: function (msg: Partial<Resp.ListProposals>): string {
      return JSON.stringify(RespJSON.ListProposals._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListProposals from JSON.
     */
    decode: function (json: string): Resp.ListProposals {
      return RespJSON.ListProposals._readMessage(
        RespJSON.ListProposals.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListProposals with all fields set to their default value.
     */
    initialize: function (): Resp.ListProposals {
      return {
        proposals: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListProposals>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.proposals?.length) {
        json.proposals = msg.proposals.map(ProposalJSON._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListProposals,
      json: any
    ): Resp.ListProposals {
      const _proposals = json.proposals;
      if (_proposals) {
        for (const item of _proposals) {
          const m = Proposal.initialize();
          ProposalJSON._readMessage(m, item);
          msg.proposals.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Resp.ListStats to JSON.
     */
    encode: function (msg: Partial<Resp.ListStats>): string {
      return JSON.stringify(RespJSON.ListStats._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListStats from JSON.
     */
    decode: function (json: string): Resp.ListStats {
      return RespJSON.ListStats._readMessage(
        RespJSON.ListStats.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListStats with all fields set to their default value.
     */
    initialize: function (): Resp.ListStats {
      return {
        stats: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListStats>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.stats?.length) {
        json.stats = msg.stats.map(StatJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListStats, json: any): Resp.ListStats {
      const _stats = json.stats;
      if (_stats) {
        for (const item of _stats) {
          const m = Stat.initialize();
          StatJSON._readMessage(m, item);
          msg.stats.push(m);
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Resp.ListAggregatedStats to JSON.
     */
    encode: function (msg: Partial<Resp.ListAggregatedStats>): string {
      return JSON.stringify(RespJSON.ListAggregatedStats._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAggregatedStats from JSON.
     */
    decode: function (json: string): Resp.ListAggregatedStats {
      return RespJSON.ListAggregatedStats._readMessage(
        RespJSON.ListAggregatedStats.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (): Resp.ListAggregatedStats {
      return {
        stats: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAggregatedStats>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.stats?.length) {
        json.stats = msg.stats.map(AggregatedStatJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAggregatedStats,
      json: any
    ): Resp.ListAggregatedStats {
      const _stats = json.stats;
      if (_stats) {
        for (const item of _stats) {
          const m = AggregatedStat.initialize();
          AggregatedStatJSON._readMessage(m, item);
          msg.stats.push(m);
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Resp.GetInfo to JSON.
     */
    encode: function (msg: Partial<Resp.GetInfo>): string {
      return JSON.stringify(RespJSON.GetInfo._writeMessage(msg));
    },

    /**
     * Deserializes Resp.GetInfo from JSON.
     */
    decode: function (json: string): Resp.GetInfo {
      return RespJSON.GetInfo._readMessage(
        RespJSON.GetInfo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.GetInfo with all fields set to their default value.
     */
    initialize: function (): Resp.GetInfo {
      return {
        oauthClientId: "",
        members: [],
        threshold: 0,
        publicKey: "",
        mode: 0,
        composedMode: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.GetInfo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oauthClientId) {
        json.oauthClientId = msg.oauthClientId;
      }
      if (msg.members?.length) {
        json.members = msg.members;
      }
      if (msg.threshold) {
        json.threshold = msg.threshold;
      }
      if (msg.publicKey) {
        json.publicKey = msg.publicKey;
      }
      if (msg.mode) {
        json.mode = msg.mode;
      }
      if (msg.composedMode) {
        json.composedMode = msg.composedMode;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.GetInfo, json: any): Resp.GetInfo {
      const _oauthClientId = json.oauthClientId ?? json.oauth_client_id;
      if (_oauthClientId) {
        msg.oauthClientId = _oauthClientId;
      }
      const _members = json.members;
      if (_members) {
        msg.members = _members;
      }
      const _threshold = json.threshold;
      if (_threshold) {
        msg.threshold = _threshold;
      }
      const _publicKey = json.publicKey ?? json.public_key;
      if (_publicKey) {
        msg.publicKey = _publicKey;
      }
      const _mode = json.mode;
      if (_mode) {
        msg.mode = _mode;
      }
      const _composedMode = json.composedMode ?? json.composed_mode;
      if (_composedMode) {
        msg.composedMode = _composedMode;
      }
      return msg;
    },
  },

  ListAudit: {
    /**
     * Serializes Resp.ListAudit to JSON.
     */
    encode: function (msg: Partial<Resp.ListAudit>): string {
      return JSON.stringify(RespJSON.ListAudit._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAudit from JSON.
     */
    decode: function (json: string): Resp.ListAudit {
      return RespJSON.ListAudit._readMessage(
        RespJSON.ListAudit.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Resp.ListAudit with all fields set to their default value.
     */
    initialize: function (): Resp.ListAudit {
      return {
        audits: [],
        pagination: Pagination.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Resp.ListAudit>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.audits?.length) {
        json.audits = msg.audits.map(AuditJSON._writeMessage);
      }
      if (msg.pagination) {
        const pagination = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(pagination).length > 0) {
          json.pagination = pagination;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListAudit, json: any): Resp.ListAudit {
      const _audits = json.audits;
      if (_audits) {
        for (const item of _audits) {
          const m = Audit.initialize();
          AuditJSON._readMessage(m, item);
          msg.audits.push(m);
        }
      }
      const _pagination = json.pagination;
      if (_pagination) {
        const m = Pagination.initialize();
        PaginationJSON._readMessage(m, _pagination);
        msg.pagination = m;
      }
      return msg;
    },
  },
};
