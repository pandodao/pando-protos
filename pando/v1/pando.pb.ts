// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: pando/v1/pando.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "_"
  | "SysWithdraw"
  | "ActionSysProperty"
  | "ProposalMake"
  | "ProposalShout"
  | "ProposalVote"
  | "CatCreate"
  | "CatSupply"
  | "CatEdit"
  | "CatFold"
  | "CatMove"
  | "CatGain"
  | "CatFill"
  | "VatOpen"
  | "VatDeposit"
  | "VatWithdraw"
  | "VatPayback"
  | "VatGenerate"
  | "FlipKick"
  | "FlipBid"
  | "FlipDeal"
  | "OracleCreate"
  | "OracleEdit"
  | "OraclePoke"
  | "OracleRely"
  | "OracleDeny";

export interface Pagination {
  nextCursor: string;
  hasNext: boolean;
}

export interface Asset {
  /**
   * mixin asset id
   */
  id: string;
  name: string;
  symbol: string;
  logo: string;
  chainId: string;
  chain: Asset | null | undefined;
  price: string;
}

export interface Collateral {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  name: string;
  gem: string;
  dai: string;
  ink: string;
  art: string;
  rate: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  rho: protoscript.Timestamp;
  debt: string;
  line: string;
  dust: string;
  price: string;
  mat: string;
  duty: string;
  chop: string;
  dunk: string;
  beg: string;
  ttl: number;
  tau: number;
  live: boolean;
  numberOfVaults: bigint;
  box: string;
  litter: string;
  supply: string;
}

export interface Vault {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  collateralId: string;
  ink: string;
  art: string;
  identityId: bigint;
}

export declare namespace Vault {
  export interface Event {
    vaultId: string;
    /**
     * @inject_tag: swaggertype:"string" format:"date"
     */
    createdAt: protoscript.Timestamp;
    action: Action;
    dink: string;
    dart: string;
    debt: string;
    id: string;
  }
}

export interface Flip {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  tic: protoscript.Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  end: protoscript.Timestamp;
  bid: string;
  lot: string;
  tab: string;
  art: string;
  collateralId: string;
  vaultId: string;
  guy: string;
  action: Action;
  tags: Flip.Tag[];
}

export declare namespace Flip {
  export type Tag = "MyVault" | "Participated" | "Leading";

  export interface Event {
    flipId: string;
    /**
     * @inject_tag: swaggertype:"string" format:"date"
     */
    createdAt: protoscript.Timestamp;
    action: Action;
    bid: string;
    lot: string;
    isMe: boolean;
  }
}

export interface Proposal {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  passedAt: protoscript.Timestamp;
  creator: string;
  assetId: string;
  amount: string;
  action: Action;
  data: string;
  votes: string[];
  items: Proposal.Item[];
}

export declare namespace Proposal {
  export interface Item {
    key: string;
    value: string;
    hint: string;
    action: string;
  }
}

export interface Oracle {
  assetId: string;
  hop: number;
  current: string;
  next: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   * last update of current price
   */
  peekAt: protoscript.Timestamp;
  threshold: number;
  governors: string[];
}

export interface Transaction {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  assetId: string;
  amount: string;
  action: Action;
  status: Transaction.Status;
  msg: string;
  parameters: string;
}

export declare namespace Transaction {
  export type Status = "Pending" | "Abort" | "OK";
}

export interface Stat {
  collateralId: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  date: protoscript.Timestamp;
  timestamp: bigint;
  gem: string;
  dai: string;
  ink: string;
  debt: string;
  gemPrice: string;
  daiPrice: string;
}

export interface AggregatedStat {
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  date: protoscript.Timestamp;
  timestamp: bigint;
  gemValue: string;
  daiValue: string;
}

export interface Audit {
  id: string;
  /**
   * @inject_tag: swaggertype:"string" format:"date"
   */
  createdAt: protoscript.Timestamp;
  assetId: string;
  amount: string;
  userId: string;
  status: Audit.Status;
  memo: string;
  reviewedBy: string;
}

export declare namespace Audit {
  export type Status = "Pending" | "Rejected" | "Approved";
}

export interface Req {}

export declare namespace Req {
  export interface FindAsset {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListAssets {}

  export interface FindOracle {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListOracles {}

  /**
   * List All Collaterals
   */
  export interface ListCollaterals {}

  /**
   * Find Collateral By TraceID
   */
  export interface FindCollateral {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface FindVault {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  /**
   * List All Vaults
   */
  export interface ListVaults {
    collateralId: string;
    userId: string;
    cursor: string;
    limit: bigint;
  }

  export interface ListMyVaults {
    cursor: string;
    limit: bigint;
  }

  export interface ListVaultEvents {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface QueryVaultEvents {
    cursor: string;
    limit: bigint;
  }

  export interface FindFlip {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListFlips {
    cursor: string;
    limit: bigint;
  }

  export interface QueryFlips {
    offset: bigint;
    limit: bigint;
    phase: string;
    myVaults: string;
    myBids: string;
  }

  export interface ListFlipEvents {
    id: string;
  }

  /**
   * Find Tx By FollowID
   */
  export interface FindTransaction {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListTransactions {
    cursor: string;
    limit: bigint;
  }

  export interface ListProposals {
    cursor: string;
    limit: bigint;
  }

  export interface FindProposal {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListStats {
    /**
     * collateral id
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
    from: bigint;
    to: bigint;
  }

  export interface ListAggregatedStats {
    from: bigint;
    to: bigint;
  }

  export interface GetInfo {}

  export interface FindAudit {
    /**
     * @inject_tag: valid:"uuid,required"
     */
    id: string;
  }

  export interface ListAudits {
    offset: protoscript.Timestamp;
    limit: bigint;
  }
}

export interface Resp {}

export declare namespace Resp {
  export interface ListAssets {
    assets: Asset[];
  }

  export interface ListOracles {
    oracles: Oracle[];
  }

  export interface ListCollaterals {
    collaterals: Collateral[];
  }

  export interface ListVaults {
    vaults: Vault[];
    pagination: Pagination;
  }

  export interface ListMyVaults {
    vaults: Vault[];
  }

  export interface ListVaultEvents {
    events: Vault.Event[];
  }

  export interface QueryVaultEvents {
    events: Vault.Event[];
    pagination: Pagination;
  }

  export interface ListFlips {
    flips: Flip[];
    pagination: Pagination;
  }

  export interface QueryFlips {
    flips: Flip[];
    total: number;
  }

  export interface ListFlipEvents {
    events: Flip.Event[];
  }

  export interface ListTransactions {
    transactions: Transaction[];
    pagination: Pagination;
  }

  export interface ListProposals {
    proposals: Proposal[];
    pagination: Pagination;
  }

  export interface ListStats {
    stats: Stat[];
  }

  export interface ListAggregatedStats {
    stats: AggregatedStat[];
  }

  export interface GetInfo {
    oauthClientId: string;
    members: string[];
    threshold: number;
    publicKey: string;
    mode: number;
    composeMode: number;
  }

  export interface ListAudits {
    audits: Audit[];
  }
}

//========================================//
//         Pando Protobuf Client          //
//========================================//

/**
 * assets
 */
export async function FindAsset(
  findAsset: Req.FindAsset,
  config?: ClientConfiguration,
): Promise<Asset> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindAsset",
    Req.FindAsset.encode(findAsset),
    config,
  );
  return Asset.decode(response);
}

export async function ListAssets(
  listAssets: Req.ListAssets,
  config?: ClientConfiguration,
): Promise<Resp.ListAssets> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAssets",
    Req.ListAssets.encode(listAssets),
    config,
  );
  return Resp.ListAssets.decode(response);
}

/**
 * oracles
 */
export async function FindOracle(
  findOracle: Req.FindOracle,
  config?: ClientConfiguration,
): Promise<Oracle> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindOracle",
    Req.FindOracle.encode(findOracle),
    config,
  );
  return Oracle.decode(response);
}

export async function ListOracles(
  listOracles: Req.ListOracles,
  config?: ClientConfiguration,
): Promise<Resp.ListOracles> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListOracles",
    Req.ListOracles.encode(listOracles),
    config,
  );
  return Resp.ListOracles.decode(response);
}

/**
 * collaterals
 */
export async function ListCollaterals(
  listCollaterals: Req.ListCollaterals,
  config?: ClientConfiguration,
): Promise<Resp.ListCollaterals> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListCollaterals",
    Req.ListCollaterals.encode(listCollaterals),
    config,
  );
  return Resp.ListCollaterals.decode(response);
}

export async function FindCollateral(
  findCollateral: Req.FindCollateral,
  config?: ClientConfiguration,
): Promise<Collateral> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindCollateral",
    Req.FindCollateral.encode(findCollateral),
    config,
  );
  return Collateral.decode(response);
}

/**
 * vaults
 */
export async function FindVault(
  findVault: Req.FindVault,
  config?: ClientConfiguration,
): Promise<Vault> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindVault",
    Req.FindVault.encode(findVault),
    config,
  );
  return Vault.decode(response);
}

export async function ListVaults(
  listVaults: Req.ListVaults,
  config?: ClientConfiguration,
): Promise<Resp.ListVaults> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListVaults",
    Req.ListVaults.encode(listVaults),
    config,
  );
  return Resp.ListVaults.decode(response);
}

export async function ListMyVaults(
  listMyVaults: Req.ListMyVaults,
  config?: ClientConfiguration,
): Promise<Resp.ListMyVaults> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListMyVaults",
    Req.ListMyVaults.encode(listMyVaults),
    config,
  );
  return Resp.ListMyVaults.decode(response);
}

export async function ListVaultEvents(
  listVaultEvents: Req.ListVaultEvents,
  config?: ClientConfiguration,
): Promise<Resp.ListVaultEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListVaultEvents",
    Req.ListVaultEvents.encode(listVaultEvents),
    config,
  );
  return Resp.ListVaultEvents.decode(response);
}

export async function QueryVaultEvents(
  queryVaultEvents: Req.QueryVaultEvents,
  config?: ClientConfiguration,
): Promise<Resp.QueryVaultEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/QueryVaultEvents",
    Req.QueryVaultEvents.encode(queryVaultEvents),
    config,
  );
  return Resp.QueryVaultEvents.decode(response);
}

/**
 * flips
 */
export async function FindFlip(
  findFlip: Req.FindFlip,
  config?: ClientConfiguration,
): Promise<Flip> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindFlip",
    Req.FindFlip.encode(findFlip),
    config,
  );
  return Flip.decode(response);
}

export async function ListFlips(
  listFlips: Req.ListFlips,
  config?: ClientConfiguration,
): Promise<Resp.ListFlips> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListFlips",
    Req.ListFlips.encode(listFlips),
    config,
  );
  return Resp.ListFlips.decode(response);
}

export async function ListFlipEvents(
  listFlipEvents: Req.ListFlipEvents,
  config?: ClientConfiguration,
): Promise<Resp.ListFlipEvents> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListFlipEvents",
    Req.ListFlipEvents.encode(listFlipEvents),
    config,
  );
  return Resp.ListFlipEvents.decode(response);
}

export async function QueryFlips(
  queryFlips: Req.QueryFlips,
  config?: ClientConfiguration,
): Promise<Resp.QueryFlips> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/QueryFlips",
    Req.QueryFlips.encode(queryFlips),
    config,
  );
  return Resp.QueryFlips.decode(response);
}

/**
 * tx
 */
export async function FindTransaction(
  findTransaction: Req.FindTransaction,
  config?: ClientConfiguration,
): Promise<Transaction> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindTransaction",
    Req.FindTransaction.encode(findTransaction),
    config,
  );
  return Transaction.decode(response);
}

export async function ListTransactions(
  listTransactions: Req.ListTransactions,
  config?: ClientConfiguration,
): Promise<Resp.ListTransactions> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListTransactions",
    Req.ListTransactions.encode(listTransactions),
    config,
  );
  return Resp.ListTransactions.decode(response);
}

/**
 * proposals
 */
export async function FindProposal(
  findProposal: Req.FindProposal,
  config?: ClientConfiguration,
): Promise<Proposal> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindProposal",
    Req.FindProposal.encode(findProposal),
    config,
  );
  return Proposal.decode(response);
}

export async function ListProposals(
  listProposals: Req.ListProposals,
  config?: ClientConfiguration,
): Promise<Resp.ListProposals> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListProposals",
    Req.ListProposals.encode(listProposals),
    config,
  );
  return Resp.ListProposals.decode(response);
}

/**
 * stats
 */
export async function ListStats(
  listStats: Req.ListStats,
  config?: ClientConfiguration,
): Promise<Resp.ListStats> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListStats",
    Req.ListStats.encode(listStats),
    config,
  );
  return Resp.ListStats.decode(response);
}

export async function ListAggregatedStats(
  listAggregatedStats: Req.ListAggregatedStats,
  config?: ClientConfiguration,
): Promise<Resp.ListAggregatedStats> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAggregatedStats",
    Req.ListAggregatedStats.encode(listAggregatedStats),
    config,
  );
  return Resp.ListAggregatedStats.decode(response);
}

/**
 * info
 */
export async function GetInfo(
  getInfo: Req.GetInfo,
  config?: ClientConfiguration,
): Promise<Resp.GetInfo> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/GetInfo",
    Req.GetInfo.encode(getInfo),
    config,
  );
  return Resp.GetInfo.decode(response);
}

/**
 * audit
 */
export async function FindAudit(
  findAudit: Req.FindAudit,
  config?: ClientConfiguration,
): Promise<Audit> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/FindAudit",
    Req.FindAudit.encode(findAudit),
    config,
  );
  return Audit.decode(response);
}

export async function ListAudits(
  listAudits: Req.ListAudits,
  config?: ClientConfiguration,
): Promise<Resp.ListAudits> {
  const response = await PBrequest(
    "/fox.pando.service.Pando/ListAudits",
    Req.ListAudits.encode(listAudits),
    config,
  );
  return Resp.ListAudits.decode(response);
}

//========================================//
//           Pando JSON Client            //
//========================================//

/**
 * assets
 */
export async function FindAssetJSON(
  findAsset: Req.FindAsset,
  config?: ClientConfiguration,
): Promise<Asset> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindAsset",
    ReqJSON.FindAsset.encode(findAsset),
    config,
  );
  return AssetJSON.decode(response);
}

export async function ListAssetsJSON(
  listAssets: Req.ListAssets,
  config?: ClientConfiguration,
): Promise<Resp.ListAssets> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAssets",
    ReqJSON.ListAssets.encode(listAssets),
    config,
  );
  return RespJSON.ListAssets.decode(response);
}

/**
 * oracles
 */
export async function FindOracleJSON(
  findOracle: Req.FindOracle,
  config?: ClientConfiguration,
): Promise<Oracle> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindOracle",
    ReqJSON.FindOracle.encode(findOracle),
    config,
  );
  return OracleJSON.decode(response);
}

export async function ListOraclesJSON(
  listOracles: Req.ListOracles,
  config?: ClientConfiguration,
): Promise<Resp.ListOracles> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListOracles",
    ReqJSON.ListOracles.encode(listOracles),
    config,
  );
  return RespJSON.ListOracles.decode(response);
}

/**
 * collaterals
 */
export async function ListCollateralsJSON(
  listCollaterals: Req.ListCollaterals,
  config?: ClientConfiguration,
): Promise<Resp.ListCollaterals> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListCollaterals",
    ReqJSON.ListCollaterals.encode(listCollaterals),
    config,
  );
  return RespJSON.ListCollaterals.decode(response);
}

export async function FindCollateralJSON(
  findCollateral: Req.FindCollateral,
  config?: ClientConfiguration,
): Promise<Collateral> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindCollateral",
    ReqJSON.FindCollateral.encode(findCollateral),
    config,
  );
  return CollateralJSON.decode(response);
}

/**
 * vaults
 */
export async function FindVaultJSON(
  findVault: Req.FindVault,
  config?: ClientConfiguration,
): Promise<Vault> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindVault",
    ReqJSON.FindVault.encode(findVault),
    config,
  );
  return VaultJSON.decode(response);
}

export async function ListVaultsJSON(
  listVaults: Req.ListVaults,
  config?: ClientConfiguration,
): Promise<Resp.ListVaults> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListVaults",
    ReqJSON.ListVaults.encode(listVaults),
    config,
  );
  return RespJSON.ListVaults.decode(response);
}

export async function ListMyVaultsJSON(
  listMyVaults: Req.ListMyVaults,
  config?: ClientConfiguration,
): Promise<Resp.ListMyVaults> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListMyVaults",
    ReqJSON.ListMyVaults.encode(listMyVaults),
    config,
  );
  return RespJSON.ListMyVaults.decode(response);
}

export async function ListVaultEventsJSON(
  listVaultEvents: Req.ListVaultEvents,
  config?: ClientConfiguration,
): Promise<Resp.ListVaultEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListVaultEvents",
    ReqJSON.ListVaultEvents.encode(listVaultEvents),
    config,
  );
  return RespJSON.ListVaultEvents.decode(response);
}

export async function QueryVaultEventsJSON(
  queryVaultEvents: Req.QueryVaultEvents,
  config?: ClientConfiguration,
): Promise<Resp.QueryVaultEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/QueryVaultEvents",
    ReqJSON.QueryVaultEvents.encode(queryVaultEvents),
    config,
  );
  return RespJSON.QueryVaultEvents.decode(response);
}

/**
 * flips
 */
export async function FindFlipJSON(
  findFlip: Req.FindFlip,
  config?: ClientConfiguration,
): Promise<Flip> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindFlip",
    ReqJSON.FindFlip.encode(findFlip),
    config,
  );
  return FlipJSON.decode(response);
}

export async function ListFlipsJSON(
  listFlips: Req.ListFlips,
  config?: ClientConfiguration,
): Promise<Resp.ListFlips> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListFlips",
    ReqJSON.ListFlips.encode(listFlips),
    config,
  );
  return RespJSON.ListFlips.decode(response);
}

export async function ListFlipEventsJSON(
  listFlipEvents: Req.ListFlipEvents,
  config?: ClientConfiguration,
): Promise<Resp.ListFlipEvents> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListFlipEvents",
    ReqJSON.ListFlipEvents.encode(listFlipEvents),
    config,
  );
  return RespJSON.ListFlipEvents.decode(response);
}

export async function QueryFlipsJSON(
  queryFlips: Req.QueryFlips,
  config?: ClientConfiguration,
): Promise<Resp.QueryFlips> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/QueryFlips",
    ReqJSON.QueryFlips.encode(queryFlips),
    config,
  );
  return RespJSON.QueryFlips.decode(response);
}

/**
 * tx
 */
export async function FindTransactionJSON(
  findTransaction: Req.FindTransaction,
  config?: ClientConfiguration,
): Promise<Transaction> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindTransaction",
    ReqJSON.FindTransaction.encode(findTransaction),
    config,
  );
  return TransactionJSON.decode(response);
}

export async function ListTransactionsJSON(
  listTransactions: Req.ListTransactions,
  config?: ClientConfiguration,
): Promise<Resp.ListTransactions> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListTransactions",
    ReqJSON.ListTransactions.encode(listTransactions),
    config,
  );
  return RespJSON.ListTransactions.decode(response);
}

/**
 * proposals
 */
export async function FindProposalJSON(
  findProposal: Req.FindProposal,
  config?: ClientConfiguration,
): Promise<Proposal> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindProposal",
    ReqJSON.FindProposal.encode(findProposal),
    config,
  );
  return ProposalJSON.decode(response);
}

export async function ListProposalsJSON(
  listProposals: Req.ListProposals,
  config?: ClientConfiguration,
): Promise<Resp.ListProposals> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListProposals",
    ReqJSON.ListProposals.encode(listProposals),
    config,
  );
  return RespJSON.ListProposals.decode(response);
}

/**
 * stats
 */
export async function ListStatsJSON(
  listStats: Req.ListStats,
  config?: ClientConfiguration,
): Promise<Resp.ListStats> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListStats",
    ReqJSON.ListStats.encode(listStats),
    config,
  );
  return RespJSON.ListStats.decode(response);
}

export async function ListAggregatedStatsJSON(
  listAggregatedStats: Req.ListAggregatedStats,
  config?: ClientConfiguration,
): Promise<Resp.ListAggregatedStats> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAggregatedStats",
    ReqJSON.ListAggregatedStats.encode(listAggregatedStats),
    config,
  );
  return RespJSON.ListAggregatedStats.decode(response);
}

/**
 * info
 */
export async function GetInfoJSON(
  getInfo: Req.GetInfo,
  config?: ClientConfiguration,
): Promise<Resp.GetInfo> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/GetInfo",
    ReqJSON.GetInfo.encode(getInfo),
    config,
  );
  return RespJSON.GetInfo.decode(response);
}

/**
 * audit
 */
export async function FindAuditJSON(
  findAudit: Req.FindAudit,
  config?: ClientConfiguration,
): Promise<Audit> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/FindAudit",
    ReqJSON.FindAudit.encode(findAudit),
    config,
  );
  return AuditJSON.decode(response);
}

export async function ListAuditsJSON(
  listAudits: Req.ListAudits,
  config?: ClientConfiguration,
): Promise<Resp.ListAudits> {
  const response = await JSONrequest(
    "/fox.pando.service.Pando/ListAudits",
    ReqJSON.ListAudits.encode(listAudits),
    config,
  );
  return RespJSON.ListAudits.decode(response);
}

//========================================//
//                 Pando                  //
//========================================//

export interface Pando<Context = unknown> {
  /**
   * assets
   */
  FindAsset: (
    findAsset: Req.FindAsset,
    context: Context,
  ) => Promise<Asset> | Asset;
  ListAssets: (
    listAssets: Req.ListAssets,
    context: Context,
  ) => Promise<Resp.ListAssets> | Resp.ListAssets;
  /**
   * oracles
   */
  FindOracle: (
    findOracle: Req.FindOracle,
    context: Context,
  ) => Promise<Oracle> | Oracle;
  ListOracles: (
    listOracles: Req.ListOracles,
    context: Context,
  ) => Promise<Resp.ListOracles> | Resp.ListOracles;
  /**
   * collaterals
   */
  ListCollaterals: (
    listCollaterals: Req.ListCollaterals,
    context: Context,
  ) => Promise<Resp.ListCollaterals> | Resp.ListCollaterals;
  FindCollateral: (
    findCollateral: Req.FindCollateral,
    context: Context,
  ) => Promise<Collateral> | Collateral;
  /**
   * vaults
   */
  FindVault: (
    findVault: Req.FindVault,
    context: Context,
  ) => Promise<Vault> | Vault;
  ListVaults: (
    listVaults: Req.ListVaults,
    context: Context,
  ) => Promise<Resp.ListVaults> | Resp.ListVaults;
  ListMyVaults: (
    listMyVaults: Req.ListMyVaults,
    context: Context,
  ) => Promise<Resp.ListMyVaults> | Resp.ListMyVaults;
  ListVaultEvents: (
    listVaultEvents: Req.ListVaultEvents,
    context: Context,
  ) => Promise<Resp.ListVaultEvents> | Resp.ListVaultEvents;
  QueryVaultEvents: (
    queryVaultEvents: Req.QueryVaultEvents,
    context: Context,
  ) => Promise<Resp.QueryVaultEvents> | Resp.QueryVaultEvents;
  /**
   * flips
   */
  FindFlip: (findFlip: Req.FindFlip, context: Context) => Promise<Flip> | Flip;
  ListFlips: (
    listFlips: Req.ListFlips,
    context: Context,
  ) => Promise<Resp.ListFlips> | Resp.ListFlips;
  ListFlipEvents: (
    listFlipEvents: Req.ListFlipEvents,
    context: Context,
  ) => Promise<Resp.ListFlipEvents> | Resp.ListFlipEvents;
  QueryFlips: (
    queryFlips: Req.QueryFlips,
    context: Context,
  ) => Promise<Resp.QueryFlips> | Resp.QueryFlips;
  /**
   * tx
   */
  FindTransaction: (
    findTransaction: Req.FindTransaction,
    context: Context,
  ) => Promise<Transaction> | Transaction;
  ListTransactions: (
    listTransactions: Req.ListTransactions,
    context: Context,
  ) => Promise<Resp.ListTransactions> | Resp.ListTransactions;
  /**
   * proposals
   */
  FindProposal: (
    findProposal: Req.FindProposal,
    context: Context,
  ) => Promise<Proposal> | Proposal;
  ListProposals: (
    listProposals: Req.ListProposals,
    context: Context,
  ) => Promise<Resp.ListProposals> | Resp.ListProposals;
  /**
   * stats
   */
  ListStats: (
    listStats: Req.ListStats,
    context: Context,
  ) => Promise<Resp.ListStats> | Resp.ListStats;
  ListAggregatedStats: (
    listAggregatedStats: Req.ListAggregatedStats,
    context: Context,
  ) => Promise<Resp.ListAggregatedStats> | Resp.ListAggregatedStats;
  /**
   * info
   */
  GetInfo: (
    getInfo: Req.GetInfo,
    context: Context,
  ) => Promise<Resp.GetInfo> | Resp.GetInfo;
  /**
   * audit
   */
  FindAudit: (
    findAudit: Req.FindAudit,
    context: Context,
  ) => Promise<Audit> | Audit;
  ListAudits: (
    listAudits: Req.ListAudits,
    context: Context,
  ) => Promise<Resp.ListAudits> | Resp.ListAudits;
}

export function createPando<Context>(service: Pando<Context>) {
  return {
    name: "fox.pando.service.Pando",
    methods: {
      FindAsset: {
        name: "FindAsset",
        handler: service.FindAsset,
        input: { protobuf: Req.FindAsset, json: ReqJSON.FindAsset },
        output: { protobuf: Asset, json: AssetJSON },
      },
      ListAssets: {
        name: "ListAssets",
        handler: service.ListAssets,
        input: { protobuf: Req.ListAssets, json: ReqJSON.ListAssets },
        output: { protobuf: Resp.ListAssets, json: RespJSON.ListAssets },
      },
      FindOracle: {
        name: "FindOracle",
        handler: service.FindOracle,
        input: { protobuf: Req.FindOracle, json: ReqJSON.FindOracle },
        output: { protobuf: Oracle, json: OracleJSON },
      },
      ListOracles: {
        name: "ListOracles",
        handler: service.ListOracles,
        input: { protobuf: Req.ListOracles, json: ReqJSON.ListOracles },
        output: { protobuf: Resp.ListOracles, json: RespJSON.ListOracles },
      },
      ListCollaterals: {
        name: "ListCollaterals",
        handler: service.ListCollaterals,
        input: { protobuf: Req.ListCollaterals, json: ReqJSON.ListCollaterals },
        output: {
          protobuf: Resp.ListCollaterals,
          json: RespJSON.ListCollaterals,
        },
      },
      FindCollateral: {
        name: "FindCollateral",
        handler: service.FindCollateral,
        input: { protobuf: Req.FindCollateral, json: ReqJSON.FindCollateral },
        output: { protobuf: Collateral, json: CollateralJSON },
      },
      FindVault: {
        name: "FindVault",
        handler: service.FindVault,
        input: { protobuf: Req.FindVault, json: ReqJSON.FindVault },
        output: { protobuf: Vault, json: VaultJSON },
      },
      ListVaults: {
        name: "ListVaults",
        handler: service.ListVaults,
        input: { protobuf: Req.ListVaults, json: ReqJSON.ListVaults },
        output: { protobuf: Resp.ListVaults, json: RespJSON.ListVaults },
      },
      ListMyVaults: {
        name: "ListMyVaults",
        handler: service.ListMyVaults,
        input: { protobuf: Req.ListMyVaults, json: ReqJSON.ListMyVaults },
        output: { protobuf: Resp.ListMyVaults, json: RespJSON.ListMyVaults },
      },
      ListVaultEvents: {
        name: "ListVaultEvents",
        handler: service.ListVaultEvents,
        input: { protobuf: Req.ListVaultEvents, json: ReqJSON.ListVaultEvents },
        output: {
          protobuf: Resp.ListVaultEvents,
          json: RespJSON.ListVaultEvents,
        },
      },
      QueryVaultEvents: {
        name: "QueryVaultEvents",
        handler: service.QueryVaultEvents,
        input: {
          protobuf: Req.QueryVaultEvents,
          json: ReqJSON.QueryVaultEvents,
        },
        output: {
          protobuf: Resp.QueryVaultEvents,
          json: RespJSON.QueryVaultEvents,
        },
      },
      FindFlip: {
        name: "FindFlip",
        handler: service.FindFlip,
        input: { protobuf: Req.FindFlip, json: ReqJSON.FindFlip },
        output: { protobuf: Flip, json: FlipJSON },
      },
      ListFlips: {
        name: "ListFlips",
        handler: service.ListFlips,
        input: { protobuf: Req.ListFlips, json: ReqJSON.ListFlips },
        output: { protobuf: Resp.ListFlips, json: RespJSON.ListFlips },
      },
      ListFlipEvents: {
        name: "ListFlipEvents",
        handler: service.ListFlipEvents,
        input: { protobuf: Req.ListFlipEvents, json: ReqJSON.ListFlipEvents },
        output: {
          protobuf: Resp.ListFlipEvents,
          json: RespJSON.ListFlipEvents,
        },
      },
      QueryFlips: {
        name: "QueryFlips",
        handler: service.QueryFlips,
        input: { protobuf: Req.QueryFlips, json: ReqJSON.QueryFlips },
        output: { protobuf: Resp.QueryFlips, json: RespJSON.QueryFlips },
      },
      FindTransaction: {
        name: "FindTransaction",
        handler: service.FindTransaction,
        input: { protobuf: Req.FindTransaction, json: ReqJSON.FindTransaction },
        output: { protobuf: Transaction, json: TransactionJSON },
      },
      ListTransactions: {
        name: "ListTransactions",
        handler: service.ListTransactions,
        input: {
          protobuf: Req.ListTransactions,
          json: ReqJSON.ListTransactions,
        },
        output: {
          protobuf: Resp.ListTransactions,
          json: RespJSON.ListTransactions,
        },
      },
      FindProposal: {
        name: "FindProposal",
        handler: service.FindProposal,
        input: { protobuf: Req.FindProposal, json: ReqJSON.FindProposal },
        output: { protobuf: Proposal, json: ProposalJSON },
      },
      ListProposals: {
        name: "ListProposals",
        handler: service.ListProposals,
        input: { protobuf: Req.ListProposals, json: ReqJSON.ListProposals },
        output: { protobuf: Resp.ListProposals, json: RespJSON.ListProposals },
      },
      ListStats: {
        name: "ListStats",
        handler: service.ListStats,
        input: { protobuf: Req.ListStats, json: ReqJSON.ListStats },
        output: { protobuf: Resp.ListStats, json: RespJSON.ListStats },
      },
      ListAggregatedStats: {
        name: "ListAggregatedStats",
        handler: service.ListAggregatedStats,
        input: {
          protobuf: Req.ListAggregatedStats,
          json: ReqJSON.ListAggregatedStats,
        },
        output: {
          protobuf: Resp.ListAggregatedStats,
          json: RespJSON.ListAggregatedStats,
        },
      },
      GetInfo: {
        name: "GetInfo",
        handler: service.GetInfo,
        input: { protobuf: Req.GetInfo, json: ReqJSON.GetInfo },
        output: { protobuf: Resp.GetInfo, json: RespJSON.GetInfo },
      },
      FindAudit: {
        name: "FindAudit",
        handler: service.FindAudit,
        input: { protobuf: Req.FindAudit, json: ReqJSON.FindAudit },
        output: { protobuf: Audit, json: AuditJSON },
      },
      ListAudits: {
        name: "ListAudits",
        handler: service.ListAudits,
        input: { protobuf: Req.ListAudits, json: ReqJSON.ListAudits },
        output: { protobuf: Resp.ListAudits, json: RespJSON.ListAudits },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  _: "_",
  /**
   * sys
   */
  SysWithdraw: "SysWithdraw",
  ActionSysProperty: "ActionSysProperty",
  /**
   * proposal
   */
  ProposalMake: "ProposalMake",
  ProposalShout: "ProposalShout",
  ProposalVote: "ProposalVote",
  /**
   * Collateral
   */
  CatCreate: "CatCreate",
  CatSupply: "CatSupply",
  CatEdit: "CatEdit",
  CatFold: "CatFold",
  CatMove: "CatMove",
  CatGain: "CatGain",
  CatFill: "CatFill",
  /**
   * Vaults
   */
  VatOpen: "VatOpen",
  VatDeposit: "VatDeposit",
  VatWithdraw: "VatWithdraw",
  VatPayback: "VatPayback",
  VatGenerate: "VatGenerate",
  /**
   * Flips
   */
  FlipKick: "FlipKick",
  FlipBid: "FlipBid",
  FlipDeal: "FlipDeal",
  /**
   * Oracles
   */
  OracleCreate: "OracleCreate",
  OracleEdit: "OracleEdit",
  OraclePoke: "OraclePoke",
  OracleRely: "OracleRely",
  OracleDeny: "OracleDeny",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "_";
      }
      case 1: {
        return "SysWithdraw";
      }
      case 2: {
        return "ActionSysProperty";
      }
      case 11: {
        return "ProposalMake";
      }
      case 12: {
        return "ProposalShout";
      }
      case 13: {
        return "ProposalVote";
      }
      case 21: {
        return "CatCreate";
      }
      case 22: {
        return "CatSupply";
      }
      case 23: {
        return "CatEdit";
      }
      case 24: {
        return "CatFold";
      }
      case 25: {
        return "CatMove";
      }
      case 26: {
        return "CatGain";
      }
      case 27: {
        return "CatFill";
      }
      case 31: {
        return "VatOpen";
      }
      case 32: {
        return "VatDeposit";
      }
      case 33: {
        return "VatWithdraw";
      }
      case 34: {
        return "VatPayback";
      }
      case 35: {
        return "VatGenerate";
      }
      case 41: {
        return "FlipKick";
      }
      case 42: {
        return "FlipBid";
      }
      case 43: {
        return "FlipDeal";
      }
      case 51: {
        return "OracleCreate";
      }
      case 52: {
        return "OracleEdit";
      }
      case 53: {
        return "OraclePoke";
      }
      case 54: {
        return "OracleRely";
      }
      case 55: {
        return "OracleDeny";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "_": {
        return 0;
      }
      case "SysWithdraw": {
        return 1;
      }
      case "ActionSysProperty": {
        return 2;
      }
      case "ProposalMake": {
        return 11;
      }
      case "ProposalShout": {
        return 12;
      }
      case "ProposalVote": {
        return 13;
      }
      case "CatCreate": {
        return 21;
      }
      case "CatSupply": {
        return 22;
      }
      case "CatEdit": {
        return 23;
      }
      case "CatFold": {
        return 24;
      }
      case "CatMove": {
        return 25;
      }
      case "CatGain": {
        return 26;
      }
      case "CatFill": {
        return 27;
      }
      case "VatOpen": {
        return 31;
      }
      case "VatDeposit": {
        return 32;
      }
      case "VatWithdraw": {
        return 33;
      }
      case "VatPayback": {
        return 34;
      }
      case "VatGenerate": {
        return 35;
      }
      case "FlipKick": {
        return 41;
      }
      case "FlipBid": {
        return 42;
      }
      case "FlipDeal": {
        return 43;
      }
      case "OracleCreate": {
        return 51;
      }
      case "OracleEdit": {
        return 52;
      }
      case "OraclePoke": {
        return 53;
      }
      case "OracleRely": {
        return 54;
      }
      case "OracleDeny": {
        return 55;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Pagination = {
  /**
   * Serializes Pagination to protobuf.
   */
  encode: function (msg: PartialDeep<Pagination>): Uint8Array {
    return Pagination._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Pagination from protobuf.
   */
  decode: function (bytes: ByteSource): Pagination {
    return Pagination._readMessage(
      Pagination.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Pagination with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pagination>): Pagination {
    return {
      nextCursor: "",
      hasNext: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Pagination>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.nextCursor) {
      writer.writeString(1, msg.nextCursor);
    }
    if (msg.hasNext) {
      writer.writeBool(2, msg.hasNext);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Pagination,
    reader: protoscript.BinaryReader,
  ): Pagination {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nextCursor = reader.readString();
          break;
        }
        case 2: {
          msg.hasNext = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Asset = {
  /**
   * Serializes Asset to protobuf.
   */
  encode: function (msg: PartialDeep<Asset>): Uint8Array {
    return Asset._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Asset from protobuf.
   */
  decode: function (bytes: ByteSource): Asset {
    return Asset._readMessage(
      Asset.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      name: "",
      symbol: "",
      logo: "",
      chainId: "",
      chain: undefined,
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Asset>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.symbol) {
      writer.writeString(3, msg.symbol);
    }
    if (msg.logo) {
      writer.writeString(4, msg.logo);
    }
    if (msg.chainId) {
      writer.writeString(5, msg.chainId);
    }
    if (msg.chain) {
      writer.writeMessage(6, msg.chain, Asset._writeMessage);
    }
    if (msg.price) {
      writer.writeString(7, msg.price);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, reader: protoscript.BinaryReader): Asset {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.symbol = reader.readString();
          break;
        }
        case 4: {
          msg.logo = reader.readString();
          break;
        }
        case 5: {
          msg.chainId = reader.readString();
          break;
        }
        case 6: {
          msg.chain = Asset.initialize();
          reader.readMessage(msg.chain, Asset._readMessage);
          break;
        }
        case 7: {
          msg.price = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Collateral = {
  /**
   * Serializes Collateral to protobuf.
   */
  encode: function (msg: PartialDeep<Collateral>): Uint8Array {
    return Collateral._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Collateral from protobuf.
   */
  decode: function (bytes: ByteSource): Collateral {
    return Collateral._readMessage(
      Collateral.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Collateral with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Collateral>): Collateral {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      name: "",
      gem: "",
      dai: "",
      ink: "",
      art: "",
      rate: "",
      rho: protoscript.Timestamp.initialize(),
      debt: "",
      line: "",
      dust: "",
      price: "",
      mat: "",
      duty: "",
      chop: "",
      dunk: "",
      beg: "",
      ttl: 0,
      tau: 0,
      live: false,
      numberOfVaults: 0n,
      box: "",
      litter: "",
      supply: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Collateral>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.gem) {
      writer.writeString(4, msg.gem);
    }
    if (msg.dai) {
      writer.writeString(5, msg.dai);
    }
    if (msg.ink) {
      writer.writeString(6, msg.ink);
    }
    if (msg.art) {
      writer.writeString(7, msg.art);
    }
    if (msg.rate) {
      writer.writeString(8, msg.rate);
    }
    if (msg.rho) {
      writer.writeMessage(9, msg.rho, protoscript.Timestamp._writeMessage);
    }
    if (msg.debt) {
      writer.writeString(10, msg.debt);
    }
    if (msg.line) {
      writer.writeString(11, msg.line);
    }
    if (msg.dust) {
      writer.writeString(12, msg.dust);
    }
    if (msg.price) {
      writer.writeString(13, msg.price);
    }
    if (msg.mat) {
      writer.writeString(14, msg.mat);
    }
    if (msg.duty) {
      writer.writeString(15, msg.duty);
    }
    if (msg.chop) {
      writer.writeString(16, msg.chop);
    }
    if (msg.dunk) {
      writer.writeString(17, msg.dunk);
    }
    if (msg.beg) {
      writer.writeString(18, msg.beg);
    }
    if (msg.ttl) {
      writer.writeInt32(19, msg.ttl);
    }
    if (msg.tau) {
      writer.writeInt32(20, msg.tau);
    }
    if (msg.live) {
      writer.writeBool(21, msg.live);
    }
    if (msg.numberOfVaults) {
      writer.writeInt64String(22, msg.numberOfVaults.toString() as any);
    }
    if (msg.box) {
      writer.writeString(23, msg.box);
    }
    if (msg.litter) {
      writer.writeString(24, msg.litter);
    }
    if (msg.supply) {
      writer.writeString(25, msg.supply);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Collateral,
    reader: protoscript.BinaryReader,
  ): Collateral {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.gem = reader.readString();
          break;
        }
        case 5: {
          msg.dai = reader.readString();
          break;
        }
        case 6: {
          msg.ink = reader.readString();
          break;
        }
        case 7: {
          msg.art = reader.readString();
          break;
        }
        case 8: {
          msg.rate = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.rho, protoscript.Timestamp._readMessage);
          break;
        }
        case 10: {
          msg.debt = reader.readString();
          break;
        }
        case 11: {
          msg.line = reader.readString();
          break;
        }
        case 12: {
          msg.dust = reader.readString();
          break;
        }
        case 13: {
          msg.price = reader.readString();
          break;
        }
        case 14: {
          msg.mat = reader.readString();
          break;
        }
        case 15: {
          msg.duty = reader.readString();
          break;
        }
        case 16: {
          msg.chop = reader.readString();
          break;
        }
        case 17: {
          msg.dunk = reader.readString();
          break;
        }
        case 18: {
          msg.beg = reader.readString();
          break;
        }
        case 19: {
          msg.ttl = reader.readInt32();
          break;
        }
        case 20: {
          msg.tau = reader.readInt32();
          break;
        }
        case 21: {
          msg.live = reader.readBool();
          break;
        }
        case 22: {
          msg.numberOfVaults = BigInt(reader.readInt64String());
          break;
        }
        case 23: {
          msg.box = reader.readString();
          break;
        }
        case 24: {
          msg.litter = reader.readString();
          break;
        }
        case 25: {
          msg.supply = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Vault = {
  /**
   * Serializes Vault to protobuf.
   */
  encode: function (msg: PartialDeep<Vault>): Uint8Array {
    return Vault._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Vault from protobuf.
   */
  decode: function (bytes: ByteSource): Vault {
    return Vault._readMessage(
      Vault.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Vault with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Vault>): Vault {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      collateralId: "",
      ink: "",
      art: "",
      identityId: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Vault>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.collateralId) {
      writer.writeString(3, msg.collateralId);
    }
    if (msg.ink) {
      writer.writeString(4, msg.ink);
    }
    if (msg.art) {
      writer.writeString(5, msg.art);
    }
    if (msg.identityId) {
      writer.writeInt64String(6, msg.identityId.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Vault, reader: protoscript.BinaryReader): Vault {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.collateralId = reader.readString();
          break;
        }
        case 4: {
          msg.ink = reader.readString();
          break;
        }
        case 5: {
          msg.art = reader.readString();
          break;
        }
        case 6: {
          msg.identityId = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Event: {
    /**
     * Serializes Vault.Event to protobuf.
     */
    encode: function (msg: PartialDeep<Vault.Event>): Uint8Array {
      return Vault.Event._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Vault.Event from protobuf.
     */
    decode: function (bytes: ByteSource): Vault.Event {
      return Vault.Event._readMessage(
        Vault.Event.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Vault.Event with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Vault.Event>): Vault.Event {
      return {
        vaultId: "",
        createdAt: protoscript.Timestamp.initialize(),
        action: Action._fromInt(0),
        dink: "",
        dart: "",
        debt: "",
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Vault.Event>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.vaultId) {
        writer.writeString(1, msg.vaultId);
      }
      if (msg.createdAt) {
        writer.writeMessage(
          2,
          msg.createdAt,
          protoscript.Timestamp._writeMessage,
        );
      }
      if (msg.action && Action._toInt(msg.action)) {
        writer.writeEnum(3, Action._toInt(msg.action));
      }
      if (msg.dink) {
        writer.writeString(4, msg.dink);
      }
      if (msg.dart) {
        writer.writeString(5, msg.dart);
      }
      if (msg.debt) {
        writer.writeString(6, msg.debt);
      }
      if (msg.id) {
        writer.writeString(7, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Vault.Event,
      reader: protoscript.BinaryReader,
    ): Vault.Event {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.vaultId = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              msg.createdAt,
              protoscript.Timestamp._readMessage,
            );
            break;
          }
          case 3: {
            msg.action = Action._fromInt(reader.readEnum());
            break;
          }
          case 4: {
            msg.dink = reader.readString();
            break;
          }
          case 5: {
            msg.dart = reader.readString();
            break;
          }
          case 6: {
            msg.debt = reader.readString();
            break;
          }
          case 7: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Flip = {
  /**
   * Serializes Flip to protobuf.
   */
  encode: function (msg: PartialDeep<Flip>): Uint8Array {
    return Flip._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Flip from protobuf.
   */
  decode: function (bytes: ByteSource): Flip {
    return Flip._readMessage(
      Flip.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Flip with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Flip>): Flip {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      tic: protoscript.Timestamp.initialize(),
      end: protoscript.Timestamp.initialize(),
      bid: "",
      lot: "",
      tab: "",
      art: "",
      collateralId: "",
      vaultId: "",
      guy: "",
      action: Action._fromInt(0),
      tags: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Flip>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.tic) {
      writer.writeMessage(3, msg.tic, protoscript.Timestamp._writeMessage);
    }
    if (msg.end) {
      writer.writeMessage(4, msg.end, protoscript.Timestamp._writeMessage);
    }
    if (msg.bid) {
      writer.writeString(5, msg.bid);
    }
    if (msg.lot) {
      writer.writeString(6, msg.lot);
    }
    if (msg.tab) {
      writer.writeString(7, msg.tab);
    }
    if (msg.art) {
      writer.writeString(8, msg.art);
    }
    if (msg.collateralId) {
      writer.writeString(9, msg.collateralId);
    }
    if (msg.vaultId) {
      writer.writeString(10, msg.vaultId);
    }
    if (msg.guy) {
      writer.writeString(11, msg.guy);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(12, Action._toInt(msg.action));
    }
    if (msg.tags?.length) {
      writer.writePackedEnum(13, msg.tags.map(Flip.Tag._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Flip, reader: protoscript.BinaryReader): Flip {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.tic, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.end, protoscript.Timestamp._readMessage);
          break;
        }
        case 5: {
          msg.bid = reader.readString();
          break;
        }
        case 6: {
          msg.lot = reader.readString();
          break;
        }
        case 7: {
          msg.tab = reader.readString();
          break;
        }
        case 8: {
          msg.art = reader.readString();
          break;
        }
        case 9: {
          msg.collateralId = reader.readString();
          break;
        }
        case 10: {
          msg.vaultId = reader.readString();
          break;
        }
        case 11: {
          msg.guy = reader.readString();
          break;
        }
        case 12: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.tags.push(...reader.readPackedEnum().map(Flip.Tag._fromInt));
          } else {
            msg.tags.push(Flip.Tag._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Tag: {
    MyVault: "MyVault",
    Participated: "Participated",
    Leading: "Leading",
    /**
     * @private
     */
    _fromInt: function (i: number): Flip.Tag {
      switch (i) {
        case 0: {
          return "MyVault";
        }
        case 1: {
          return "Participated";
        }
        case 2: {
          return "Leading";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Flip.Tag;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Flip.Tag): number {
      switch (i) {
        case "MyVault": {
          return 0;
        }
        case "Participated": {
          return 1;
        }
        case "Leading": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Event: {
    /**
     * Serializes Flip.Event to protobuf.
     */
    encode: function (msg: PartialDeep<Flip.Event>): Uint8Array {
      return Flip.Event._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Flip.Event from protobuf.
     */
    decode: function (bytes: ByteSource): Flip.Event {
      return Flip.Event._readMessage(
        Flip.Event.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Flip.Event with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Flip.Event>): Flip.Event {
      return {
        flipId: "",
        createdAt: protoscript.Timestamp.initialize(),
        action: Action._fromInt(0),
        bid: "",
        lot: "",
        isMe: false,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Flip.Event>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.flipId) {
        writer.writeString(1, msg.flipId);
      }
      if (msg.createdAt) {
        writer.writeMessage(
          2,
          msg.createdAt,
          protoscript.Timestamp._writeMessage,
        );
      }
      if (msg.action && Action._toInt(msg.action)) {
        writer.writeEnum(3, Action._toInt(msg.action));
      }
      if (msg.bid) {
        writer.writeString(4, msg.bid);
      }
      if (msg.lot) {
        writer.writeString(5, msg.lot);
      }
      if (msg.isMe) {
        writer.writeBool(6, msg.isMe);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Flip.Event,
      reader: protoscript.BinaryReader,
    ): Flip.Event {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.flipId = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              msg.createdAt,
              protoscript.Timestamp._readMessage,
            );
            break;
          }
          case 3: {
            msg.action = Action._fromInt(reader.readEnum());
            break;
          }
          case 4: {
            msg.bid = reader.readString();
            break;
          }
          case 5: {
            msg.lot = reader.readString();
            break;
          }
          case 6: {
            msg.isMe = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Proposal = {
  /**
   * Serializes Proposal to protobuf.
   */
  encode: function (msg: PartialDeep<Proposal>): Uint8Array {
    return Proposal._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Proposal from protobuf.
   */
  decode: function (bytes: ByteSource): Proposal {
    return Proposal._readMessage(
      Proposal.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Proposal>): Proposal {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      passedAt: protoscript.Timestamp.initialize(),
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      data: "",
      votes: [],
      items: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Proposal>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.passedAt) {
      writer.writeMessage(3, msg.passedAt, protoscript.Timestamp._writeMessage);
    }
    if (msg.creator) {
      writer.writeString(4, msg.creator);
    }
    if (msg.assetId) {
      writer.writeString(5, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(6, msg.amount);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(7, Action._toInt(msg.action));
    }
    if (msg.data) {
      writer.writeString(8, msg.data);
    }
    if (msg.votes?.length) {
      writer.writeRepeatedString(9, msg.votes);
    }
    if (msg.items?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.items as any,
        Proposal.Item._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Proposal,
    reader: protoscript.BinaryReader,
  ): Proposal {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.passedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.creator = reader.readString();
          break;
        }
        case 5: {
          msg.assetId = reader.readString();
          break;
        }
        case 6: {
          msg.amount = reader.readString();
          break;
        }
        case 7: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          msg.data = reader.readString();
          break;
        }
        case 9: {
          msg.votes.push(reader.readString());
          break;
        }
        case 10: {
          const m = Proposal.Item.initialize();
          reader.readMessage(m, Proposal.Item._readMessage);
          msg.items.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Item: {
    /**
     * Serializes Proposal.Item to protobuf.
     */
    encode: function (msg: PartialDeep<Proposal.Item>): Uint8Array {
      return Proposal.Item._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Proposal.Item from protobuf.
     */
    decode: function (bytes: ByteSource): Proposal.Item {
      return Proposal.Item._readMessage(
        Proposal.Item.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Proposal.Item with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.Item>): Proposal.Item {
      return {
        key: "",
        value: "",
        hint: "",
        action: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.Item>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      if (msg.hint) {
        writer.writeString(3, msg.hint);
      }
      if (msg.action) {
        writer.writeString(4, msg.action);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Proposal.Item,
      reader: protoscript.BinaryReader,
    ): Proposal.Item {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          case 3: {
            msg.hint = reader.readString();
            break;
          }
          case 4: {
            msg.action = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Oracle = {
  /**
   * Serializes Oracle to protobuf.
   */
  encode: function (msg: PartialDeep<Oracle>): Uint8Array {
    return Oracle._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Oracle from protobuf.
   */
  decode: function (bytes: ByteSource): Oracle {
    return Oracle._readMessage(
      Oracle.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Oracle with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Oracle>): Oracle {
    return {
      assetId: "",
      hop: 0,
      current: "",
      next: "",
      peekAt: protoscript.Timestamp.initialize(),
      threshold: 0,
      governors: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Oracle>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.assetId) {
      writer.writeString(1, msg.assetId);
    }
    if (msg.hop) {
      writer.writeInt32(2, msg.hop);
    }
    if (msg.current) {
      writer.writeString(3, msg.current);
    }
    if (msg.next) {
      writer.writeString(4, msg.next);
    }
    if (msg.peekAt) {
      writer.writeMessage(5, msg.peekAt, protoscript.Timestamp._writeMessage);
    }
    if (msg.threshold) {
      writer.writeInt32(6, msg.threshold);
    }
    if (msg.governors?.length) {
      writer.writeRepeatedString(7, msg.governors);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Oracle,
    reader: protoscript.BinaryReader,
  ): Oracle {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.assetId = reader.readString();
          break;
        }
        case 2: {
          msg.hop = reader.readInt32();
          break;
        }
        case 3: {
          msg.current = reader.readString();
          break;
        }
        case 4: {
          msg.next = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.peekAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 6: {
          msg.threshold = reader.readInt32();
          break;
        }
        case 7: {
          msg.governors.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: PartialDeep<Transaction>): Uint8Array {
    return Transaction._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      status: Transaction.Status._fromInt(0),
      msg: "",
      parameters: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.action && Action._toInt(msg.action)) {
      writer.writeEnum(5, Action._toInt(msg.action));
    }
    if (msg.status && Transaction.Status._toInt(msg.status)) {
      writer.writeEnum(6, Transaction.Status._toInt(msg.status));
    }
    if (msg.msg) {
      writer.writeString(7, msg.msg);
    }
    if (msg.parameters) {
      writer.writeString(8, msg.parameters);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transaction,
    reader: protoscript.BinaryReader,
  ): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.action = Action._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.status = Transaction.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.msg = reader.readString();
          break;
        }
        case 8: {
          msg.parameters = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Abort: "Abort",
    OK: "OK",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Abort";
        }
        case 2: {
          return "OK";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Abort": {
          return 1;
        }
        case "OK": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Stat = {
  /**
   * Serializes Stat to protobuf.
   */
  encode: function (msg: PartialDeep<Stat>): Uint8Array {
    return Stat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Stat from protobuf.
   */
  decode: function (bytes: ByteSource): Stat {
    return Stat._readMessage(
      Stat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Stat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Stat>): Stat {
    return {
      collateralId: "",
      date: protoscript.Timestamp.initialize(),
      timestamp: 0n,
      gem: "",
      dai: "",
      ink: "",
      debt: "",
      gemPrice: "",
      daiPrice: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Stat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.collateralId) {
      writer.writeString(1, msg.collateralId);
    }
    if (msg.date) {
      writer.writeMessage(2, msg.date, protoscript.Timestamp._writeMessage);
    }
    if (msg.timestamp) {
      writer.writeInt64String(3, msg.timestamp.toString() as any);
    }
    if (msg.gem) {
      writer.writeString(4, msg.gem);
    }
    if (msg.dai) {
      writer.writeString(5, msg.dai);
    }
    if (msg.ink) {
      writer.writeString(6, msg.ink);
    }
    if (msg.debt) {
      writer.writeString(7, msg.debt);
    }
    if (msg.gemPrice) {
      writer.writeString(8, msg.gemPrice);
    }
    if (msg.daiPrice) {
      writer.writeString(9, msg.daiPrice);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Stat, reader: protoscript.BinaryReader): Stat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.collateralId = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.date, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.timestamp = BigInt(reader.readInt64String());
          break;
        }
        case 4: {
          msg.gem = reader.readString();
          break;
        }
        case 5: {
          msg.dai = reader.readString();
          break;
        }
        case 6: {
          msg.ink = reader.readString();
          break;
        }
        case 7: {
          msg.debt = reader.readString();
          break;
        }
        case 8: {
          msg.gemPrice = reader.readString();
          break;
        }
        case 9: {
          msg.daiPrice = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const AggregatedStat = {
  /**
   * Serializes AggregatedStat to protobuf.
   */
  encode: function (msg: PartialDeep<AggregatedStat>): Uint8Array {
    return AggregatedStat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes AggregatedStat from protobuf.
   */
  decode: function (bytes: ByteSource): AggregatedStat {
    return AggregatedStat._readMessage(
      AggregatedStat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes AggregatedStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AggregatedStat>): AggregatedStat {
    return {
      date: protoscript.Timestamp.initialize(),
      timestamp: 0n,
      gemValue: "",
      daiValue: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AggregatedStat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.date) {
      writer.writeMessage(1, msg.date, protoscript.Timestamp._writeMessage);
    }
    if (msg.timestamp) {
      writer.writeInt64String(2, msg.timestamp.toString() as any);
    }
    if (msg.gemValue) {
      writer.writeString(3, msg.gemValue);
    }
    if (msg.daiValue) {
      writer.writeString(5, msg.daiValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AggregatedStat,
    reader: protoscript.BinaryReader,
  ): AggregatedStat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.date, protoscript.Timestamp._readMessage);
          break;
        }
        case 2: {
          msg.timestamp = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.gemValue = reader.readString();
          break;
        }
        case 5: {
          msg.daiValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Audit = {
  /**
   * Serializes Audit to protobuf.
   */
  encode: function (msg: PartialDeep<Audit>): Uint8Array {
    return Audit._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Audit from protobuf.
   */
  decode: function (bytes: ByteSource): Audit {
    return Audit._readMessage(
      Audit.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Audit>): Audit {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Audit>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.assetId) {
      writer.writeString(3, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(4, msg.amount);
    }
    if (msg.userId) {
      writer.writeString(5, msg.userId);
    }
    if (msg.status && Audit.Status._toInt(msg.status)) {
      writer.writeEnum(6, Audit.Status._toInt(msg.status));
    }
    if (msg.memo) {
      writer.writeString(7, msg.memo);
    }
    if (msg.reviewedBy) {
      writer.writeString(8, msg.reviewedBy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, reader: protoscript.BinaryReader): Audit {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.assetId = reader.readString();
          break;
        }
        case 4: {
          msg.amount = reader.readString();
          break;
        }
        case 5: {
          msg.userId = reader.readString();
          break;
        }
        case 6: {
          msg.status = Audit.Status._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.memo = reader.readString();
          break;
        }
        case 8: {
          msg.reviewedBy = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Rejected: "Rejected",
    Approved: "Approved",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Rejected";
        }
        case 2: {
          return "Approved";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Rejected": {
          return 1;
        }
        case "Approved": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg?: PartialDeep<Req>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes?: ByteSource): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Req>): Req {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<Req>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Req, _reader: protoscript.BinaryReader): Req {
    return _msg;
  },

  FindAsset: {
    /**
     * Serializes Req.FindAsset to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindAsset>): Uint8Array {
      return Req.FindAsset._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindAsset from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindAsset {
      return Req.FindAsset._readMessage(
        Req.FindAsset.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindAsset with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindAsset>): Req.FindAsset {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindAsset>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindAsset,
      reader: protoscript.BinaryReader,
    ): Req.FindAsset {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAssets: {
    /**
     * Serializes Req.ListAssets to protobuf.
     */
    encode: function (_msg?: PartialDeep<Req.ListAssets>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListAssets from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListAssets {
      return {};
    },

    /**
     * Initializes Req.ListAssets with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListAssets>): Req.ListAssets {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListAssets>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListAssets,
      _reader: protoscript.BinaryReader,
    ): Req.ListAssets {
      return _msg;
    },
  },

  FindOracle: {
    /**
     * Serializes Req.FindOracle to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindOracle>): Uint8Array {
      return Req.FindOracle._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindOracle from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindOracle {
      return Req.FindOracle._readMessage(
        Req.FindOracle.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindOracle with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindOracle>): Req.FindOracle {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindOracle>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindOracle,
      reader: protoscript.BinaryReader,
    ): Req.FindOracle {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Req.ListOracles to protobuf.
     */
    encode: function (_msg?: PartialDeep<Req.ListOracles>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListOracles from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListOracles {
      return {};
    },

    /**
     * Initializes Req.ListOracles with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListOracles>): Req.ListOracles {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListOracles>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListOracles,
      _reader: protoscript.BinaryReader,
    ): Req.ListOracles {
      return _msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Req.ListCollaterals to protobuf.
     */
    encode: function (_msg?: PartialDeep<Req.ListCollaterals>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.ListCollaterals from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.ListCollaterals {
      return {};
    },

    /**
     * Initializes Req.ListCollaterals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListCollaterals>,
    ): Req.ListCollaterals {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListCollaterals>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.ListCollaterals,
      _reader: protoscript.BinaryReader,
    ): Req.ListCollaterals {
      return _msg;
    },
  },

  FindCollateral: {
    /**
     * Serializes Req.FindCollateral to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindCollateral>): Uint8Array {
      return Req.FindCollateral._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindCollateral from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindCollateral {
      return Req.FindCollateral._readMessage(
        Req.FindCollateral.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindCollateral with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.FindCollateral>,
    ): Req.FindCollateral {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindCollateral>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindCollateral,
      reader: protoscript.BinaryReader,
    ): Req.FindCollateral {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindVault: {
    /**
     * Serializes Req.FindVault to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindVault>): Uint8Array {
      return Req.FindVault._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindVault from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindVault {
      return Req.FindVault._readMessage(
        Req.FindVault.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindVault with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindVault>): Req.FindVault {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindVault>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindVault,
      reader: protoscript.BinaryReader,
    ): Req.FindVault {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Req.ListVaults to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListVaults>): Uint8Array {
      return Req.ListVaults._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListVaults {
      return Req.ListVaults._readMessage(
        Req.ListVaults.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListVaults>): Req.ListVaults {
      return {
        collateralId: "",
        userId: "",
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListVaults>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.collateralId) {
        writer.writeString(1, msg.collateralId);
      }
      if (msg.userId) {
        writer.writeString(2, msg.userId);
      }
      if (msg.cursor) {
        writer.writeString(3, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(4, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaults,
      reader: protoscript.BinaryReader,
    ): Req.ListVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.collateralId = reader.readString();
            break;
          }
          case 2: {
            msg.userId = reader.readString();
            break;
          }
          case 3: {
            msg.cursor = reader.readString();
            break;
          }
          case 4: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Req.ListMyVaults to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListMyVaults>): Uint8Array {
      return Req.ListMyVaults._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListMyVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListMyVaults {
      return Req.ListMyVaults._readMessage(
        Req.ListMyVaults.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListMyVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListMyVaults>): Req.ListMyVaults {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListMyVaults>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListMyVaults,
      reader: protoscript.BinaryReader,
    ): Req.ListMyVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Req.ListVaultEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListVaultEvents>): Uint8Array {
      return Req.ListVaultEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListVaultEvents {
      return Req.ListVaultEvents._readMessage(
        Req.ListVaultEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListVaultEvents>,
    ): Req.ListVaultEvents {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListVaultEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaultEvents,
      reader: protoscript.BinaryReader,
    ): Req.ListVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Req.QueryVaultEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Req.QueryVaultEvents>): Uint8Array {
      return Req.QueryVaultEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.QueryVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.QueryVaultEvents {
      return Req.QueryVaultEvents._readMessage(
        Req.QueryVaultEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.QueryVaultEvents>,
    ): Req.QueryVaultEvents {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.QueryVaultEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryVaultEvents,
      reader: protoscript.BinaryReader,
    ): Req.QueryVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindFlip: {
    /**
     * Serializes Req.FindFlip to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindFlip>): Uint8Array {
      return Req.FindFlip._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindFlip from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindFlip {
      return Req.FindFlip._readMessage(
        Req.FindFlip.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindFlip with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindFlip>): Req.FindFlip {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindFlip>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindFlip,
      reader: protoscript.BinaryReader,
    ): Req.FindFlip {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Req.ListFlips to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListFlips>): Uint8Array {
      return Req.ListFlips._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListFlips {
      return Req.ListFlips._readMessage(
        Req.ListFlips.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListFlips>): Req.ListFlips {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListFlips>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlips,
      reader: protoscript.BinaryReader,
    ): Req.ListFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Req.QueryFlips to protobuf.
     */
    encode: function (msg: PartialDeep<Req.QueryFlips>): Uint8Array {
      return Req.QueryFlips._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.QueryFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Req.QueryFlips {
      return Req.QueryFlips._readMessage(
        Req.QueryFlips.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.QueryFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.QueryFlips>): Req.QueryFlips {
      return {
        offset: 0n,
        limit: 0n,
        phase: "",
        myVaults: "",
        myBids: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.QueryFlips>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.offset) {
        writer.writeInt64String(1, msg.offset.toString() as any);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      if (msg.phase) {
        writer.writeString(3, msg.phase);
      }
      if (msg.myVaults) {
        writer.writeString(4, msg.myVaults);
      }
      if (msg.myBids) {
        writer.writeString(5, msg.myBids);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryFlips,
      reader: protoscript.BinaryReader,
    ): Req.QueryFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.offset = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          case 3: {
            msg.phase = reader.readString();
            break;
          }
          case 4: {
            msg.myVaults = reader.readString();
            break;
          }
          case 5: {
            msg.myBids = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Req.ListFlipEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListFlipEvents>): Uint8Array {
      return Req.ListFlipEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListFlipEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListFlipEvents {
      return Req.ListFlipEvents._readMessage(
        Req.ListFlipEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListFlipEvents>,
    ): Req.ListFlipEvents {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListFlipEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlipEvents,
      reader: protoscript.BinaryReader,
    ): Req.ListFlipEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindTransaction: {
    /**
     * Serializes Req.FindTransaction to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindTransaction>): Uint8Array {
      return Req.FindTransaction._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindTransaction from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindTransaction {
      return Req.FindTransaction._readMessage(
        Req.FindTransaction.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindTransaction with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.FindTransaction>,
    ): Req.FindTransaction {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindTransaction>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindTransaction,
      reader: protoscript.BinaryReader,
    ): Req.FindTransaction {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Req.ListTransactions to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListTransactions>): Uint8Array {
      return Req.ListTransactions._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListTransactions from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListTransactions {
      return Req.ListTransactions._readMessage(
        Req.ListTransactions.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListTransactions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListTransactions>,
    ): Req.ListTransactions {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListTransactions>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListTransactions,
      reader: protoscript.BinaryReader,
    ): Req.ListTransactions {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Req.ListProposals to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListProposals>): Uint8Array {
      return Req.ListProposals._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListProposals from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListProposals {
      return Req.ListProposals._readMessage(
        Req.ListProposals.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListProposals with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListProposals>): Req.ListProposals {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListProposals>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.cursor) {
        writer.writeString(1, msg.cursor);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListProposals,
      reader: protoscript.BinaryReader,
    ): Req.ListProposals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.cursor = reader.readString();
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FindProposal: {
    /**
     * Serializes Req.FindProposal to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindProposal>): Uint8Array {
      return Req.FindProposal._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindProposal from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindProposal {
      return Req.FindProposal._readMessage(
        Req.FindProposal.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindProposal with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindProposal>): Req.FindProposal {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindProposal>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindProposal,
      reader: protoscript.BinaryReader,
    ): Req.FindProposal {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Req.ListStats to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListStats>): Uint8Array {
      return Req.ListStats._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListStats from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListStats {
      return Req.ListStats._readMessage(
        Req.ListStats.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListStats with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListStats>): Req.ListStats {
      return {
        id: "",
        from: 0n,
        to: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListStats>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.from) {
        writer.writeInt64String(2, msg.from.toString() as any);
      }
      if (msg.to) {
        writer.writeInt64String(3, msg.to.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListStats,
      reader: protoscript.BinaryReader,
    ): Req.ListStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            msg.from = BigInt(reader.readInt64String());
            break;
          }
          case 3: {
            msg.to = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Req.ListAggregatedStats to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListAggregatedStats>): Uint8Array {
      return Req.ListAggregatedStats._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListAggregatedStats from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListAggregatedStats {
      return Req.ListAggregatedStats._readMessage(
        Req.ListAggregatedStats.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListAggregatedStats>,
    ): Req.ListAggregatedStats {
      return {
        from: 0n,
        to: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListAggregatedStats>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.from) {
        writer.writeInt64String(1, msg.from.toString() as any);
      }
      if (msg.to) {
        writer.writeInt64String(2, msg.to.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAggregatedStats,
      reader: protoscript.BinaryReader,
    ): Req.ListAggregatedStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.from = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.to = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Req.GetInfo to protobuf.
     */
    encode: function (_msg?: PartialDeep<Req.GetInfo>): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes Req.GetInfo from protobuf.
     */
    decode: function (_bytes?: ByteSource): Req.GetInfo {
      return {};
    },

    /**
     * Initializes Req.GetInfo with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.GetInfo>): Req.GetInfo {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.GetInfo>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: Req.GetInfo,
      _reader: protoscript.BinaryReader,
    ): Req.GetInfo {
      return _msg;
    },
  },

  FindAudit: {
    /**
     * Serializes Req.FindAudit to protobuf.
     */
    encode: function (msg: PartialDeep<Req.FindAudit>): Uint8Array {
      return Req.FindAudit._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.FindAudit from protobuf.
     */
    decode: function (bytes: ByteSource): Req.FindAudit {
      return Req.FindAudit._readMessage(
        Req.FindAudit.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.FindAudit with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindAudit>): Req.FindAudit {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindAudit>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindAudit,
      reader: protoscript.BinaryReader,
    ): Req.FindAudit {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAudits: {
    /**
     * Serializes Req.ListAudits to protobuf.
     */
    encode: function (msg: PartialDeep<Req.ListAudits>): Uint8Array {
      return Req.ListAudits._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.ListAudits from protobuf.
     */
    decode: function (bytes: ByteSource): Req.ListAudits {
      return Req.ListAudits._readMessage(
        Req.ListAudits.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.ListAudits with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListAudits>): Req.ListAudits {
      return {
        offset: protoscript.Timestamp.initialize(),
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListAudits>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.offset) {
        writer.writeMessage(1, msg.offset, protoscript.Timestamp._writeMessage);
      }
      if (msg.limit) {
        writer.writeInt64String(2, msg.limit.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAudits,
      reader: protoscript.BinaryReader,
    ): Req.ListAudits {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.offset, protoscript.Timestamp._readMessage);
            break;
          }
          case 2: {
            msg.limit = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Resp = {
  /**
   * Serializes Resp to protobuf.
   */
  encode: function (_msg?: PartialDeep<Resp>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Resp from protobuf.
   */
  decode: function (_bytes?: ByteSource): Resp {
    return {};
  },

  /**
   * Initializes Resp with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Resp>): Resp {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<Resp>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Resp, _reader: protoscript.BinaryReader): Resp {
    return _msg;
  },

  ListAssets: {
    /**
     * Serializes Resp.ListAssets to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListAssets>): Uint8Array {
      return Resp.ListAssets._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAssets from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAssets {
      return Resp.ListAssets._readMessage(
        Resp.ListAssets.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListAssets with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListAssets>): Resp.ListAssets {
      return {
        assets: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAssets>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.assets?.length) {
        writer.writeRepeatedMessage(1, msg.assets as any, Asset._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAssets,
      reader: protoscript.BinaryReader,
    ): Resp.ListAssets {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Asset.initialize();
            reader.readMessage(m, Asset._readMessage);
            msg.assets.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Resp.ListOracles to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListOracles>): Uint8Array {
      return Resp.ListOracles._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListOracles from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListOracles {
      return Resp.ListOracles._readMessage(
        Resp.ListOracles.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListOracles with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListOracles>): Resp.ListOracles {
      return {
        oracles: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListOracles>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.oracles?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.oracles as any,
          Oracle._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListOracles,
      reader: protoscript.BinaryReader,
    ): Resp.ListOracles {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Oracle.initialize();
            reader.readMessage(m, Oracle._readMessage);
            msg.oracles.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Resp.ListCollaterals to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListCollaterals>): Uint8Array {
      return Resp.ListCollaterals._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListCollaterals from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListCollaterals {
      return Resp.ListCollaterals._readMessage(
        Resp.ListCollaterals.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListCollaterals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListCollaterals>,
    ): Resp.ListCollaterals {
      return {
        collaterals: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListCollaterals>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.collaterals?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.collaterals as any,
          Collateral._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListCollaterals,
      reader: protoscript.BinaryReader,
    ): Resp.ListCollaterals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Collateral.initialize();
            reader.readMessage(m, Collateral._readMessage);
            msg.collaterals.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Resp.ListVaults to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListVaults>): Uint8Array {
      return Resp.ListVaults._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListVaults {
      return Resp.ListVaults._readMessage(
        Resp.ListVaults.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListVaults>): Resp.ListVaults {
      return {
        vaults: [],
        pagination: Pagination.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListVaults>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.vaults?.length) {
        writer.writeRepeatedMessage(1, msg.vaults as any, Vault._writeMessage);
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaults,
      reader: protoscript.BinaryReader,
    ): Resp.ListVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.initialize();
            reader.readMessage(m, Vault._readMessage);
            msg.vaults.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Resp.ListMyVaults to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListMyVaults>): Uint8Array {
      return Resp.ListMyVaults._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListMyVaults from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListMyVaults {
      return Resp.ListMyVaults._readMessage(
        Resp.ListMyVaults.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListMyVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListMyVaults>): Resp.ListMyVaults {
      return {
        vaults: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListMyVaults>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.vaults?.length) {
        writer.writeRepeatedMessage(1, msg.vaults as any, Vault._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListMyVaults,
      reader: protoscript.BinaryReader,
    ): Resp.ListMyVaults {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.initialize();
            reader.readMessage(m, Vault._readMessage);
            msg.vaults.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Resp.ListVaultEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListVaultEvents>): Uint8Array {
      return Resp.ListVaultEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListVaultEvents {
      return Resp.ListVaultEvents._readMessage(
        Resp.ListVaultEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListVaultEvents>,
    ): Resp.ListVaultEvents {
      return {
        events: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListVaultEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Vault.Event._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaultEvents,
      reader: protoscript.BinaryReader,
    ): Resp.ListVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.Event.initialize();
            reader.readMessage(m, Vault.Event._readMessage);
            msg.events.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Resp.QueryVaultEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.QueryVaultEvents>): Uint8Array {
      return Resp.QueryVaultEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.QueryVaultEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.QueryVaultEvents {
      return Resp.QueryVaultEvents._readMessage(
        Resp.QueryVaultEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.QueryVaultEvents>,
    ): Resp.QueryVaultEvents {
      return {
        events: [],
        pagination: Pagination.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.QueryVaultEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Vault.Event._writeMessage,
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryVaultEvents,
      reader: protoscript.BinaryReader,
    ): Resp.QueryVaultEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Vault.Event.initialize();
            reader.readMessage(m, Vault.Event._readMessage);
            msg.events.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Resp.ListFlips to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListFlips>): Uint8Array {
      return Resp.ListFlips._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListFlips {
      return Resp.ListFlips._readMessage(
        Resp.ListFlips.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListFlips>): Resp.ListFlips {
      return {
        flips: [],
        pagination: Pagination.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListFlips>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.flips?.length) {
        writer.writeRepeatedMessage(1, msg.flips as any, Flip._writeMessage);
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlips,
      reader: protoscript.BinaryReader,
    ): Resp.ListFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.initialize();
            reader.readMessage(m, Flip._readMessage);
            msg.flips.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Resp.QueryFlips to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.QueryFlips>): Uint8Array {
      return Resp.QueryFlips._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.QueryFlips from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.QueryFlips {
      return Resp.QueryFlips._readMessage(
        Resp.QueryFlips.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.QueryFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.QueryFlips>): Resp.QueryFlips {
      return {
        flips: [],
        total: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.QueryFlips>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.flips?.length) {
        writer.writeRepeatedMessage(1, msg.flips as any, Flip._writeMessage);
      }
      if (msg.total) {
        writer.writeInt32(2, msg.total);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryFlips,
      reader: protoscript.BinaryReader,
    ): Resp.QueryFlips {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.initialize();
            reader.readMessage(m, Flip._readMessage);
            msg.flips.push(m);
            break;
          }
          case 2: {
            msg.total = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Resp.ListFlipEvents to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListFlipEvents>): Uint8Array {
      return Resp.ListFlipEvents._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListFlipEvents from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListFlipEvents {
      return Resp.ListFlipEvents._readMessage(
        Resp.ListFlipEvents.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListFlipEvents>,
    ): Resp.ListFlipEvents {
      return {
        events: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListFlipEvents>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.events?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.events as any,
          Flip.Event._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlipEvents,
      reader: protoscript.BinaryReader,
    ): Resp.ListFlipEvents {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Flip.Event.initialize();
            reader.readMessage(m, Flip.Event._readMessage);
            msg.events.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Resp.ListTransactions to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListTransactions>): Uint8Array {
      return Resp.ListTransactions._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListTransactions from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListTransactions {
      return Resp.ListTransactions._readMessage(
        Resp.ListTransactions.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListTransactions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListTransactions>,
    ): Resp.ListTransactions {
      return {
        transactions: [],
        pagination: Pagination.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListTransactions>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.transactions?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.transactions as any,
          Transaction._writeMessage,
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListTransactions,
      reader: protoscript.BinaryReader,
    ): Resp.ListTransactions {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Transaction.initialize();
            reader.readMessage(m, Transaction._readMessage);
            msg.transactions.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Resp.ListProposals to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListProposals>): Uint8Array {
      return Resp.ListProposals._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListProposals from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListProposals {
      return Resp.ListProposals._readMessage(
        Resp.ListProposals.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListProposals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListProposals>,
    ): Resp.ListProposals {
      return {
        proposals: [],
        pagination: Pagination.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListProposals>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.proposals?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.proposals as any,
          Proposal._writeMessage,
        );
      }
      if (msg.pagination) {
        writer.writeMessage(2, msg.pagination, Pagination._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListProposals,
      reader: protoscript.BinaryReader,
    ): Resp.ListProposals {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Proposal.initialize();
            reader.readMessage(m, Proposal._readMessage);
            msg.proposals.push(m);
            break;
          }
          case 2: {
            reader.readMessage(msg.pagination, Pagination._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Resp.ListStats to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListStats>): Uint8Array {
      return Resp.ListStats._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListStats from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListStats {
      return Resp.ListStats._readMessage(
        Resp.ListStats.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListStats with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListStats>): Resp.ListStats {
      return {
        stats: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListStats>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.stats?.length) {
        writer.writeRepeatedMessage(1, msg.stats as any, Stat._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListStats,
      reader: protoscript.BinaryReader,
    ): Resp.ListStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Stat.initialize();
            reader.readMessage(m, Stat._readMessage);
            msg.stats.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Resp.ListAggregatedStats to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListAggregatedStats>): Uint8Array {
      return Resp.ListAggregatedStats._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAggregatedStats from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAggregatedStats {
      return Resp.ListAggregatedStats._readMessage(
        Resp.ListAggregatedStats.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListAggregatedStats>,
    ): Resp.ListAggregatedStats {
      return {
        stats: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAggregatedStats>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.stats?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.stats as any,
          AggregatedStat._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAggregatedStats,
      reader: protoscript.BinaryReader,
    ): Resp.ListAggregatedStats {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = AggregatedStat.initialize();
            reader.readMessage(m, AggregatedStat._readMessage);
            msg.stats.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Resp.GetInfo to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.GetInfo>): Uint8Array {
      return Resp.GetInfo._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.GetInfo from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.GetInfo {
      return Resp.GetInfo._readMessage(
        Resp.GetInfo.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.GetInfo with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.GetInfo>): Resp.GetInfo {
      return {
        oauthClientId: "",
        members: [],
        threshold: 0,
        publicKey: "",
        mode: 0,
        composeMode: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.GetInfo>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.oauthClientId) {
        writer.writeString(1, msg.oauthClientId);
      }
      if (msg.members?.length) {
        writer.writeRepeatedString(2, msg.members);
      }
      if (msg.threshold) {
        writer.writeInt32(3, msg.threshold);
      }
      if (msg.publicKey) {
        writer.writeString(4, msg.publicKey);
      }
      if (msg.mode) {
        writer.writeInt32(5, msg.mode);
      }
      if (msg.composeMode) {
        writer.writeInt32(6, msg.composeMode);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.GetInfo,
      reader: protoscript.BinaryReader,
    ): Resp.GetInfo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.oauthClientId = reader.readString();
            break;
          }
          case 2: {
            msg.members.push(reader.readString());
            break;
          }
          case 3: {
            msg.threshold = reader.readInt32();
            break;
          }
          case 4: {
            msg.publicKey = reader.readString();
            break;
          }
          case 5: {
            msg.mode = reader.readInt32();
            break;
          }
          case 6: {
            msg.composeMode = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListAudits: {
    /**
     * Serializes Resp.ListAudits to protobuf.
     */
    encode: function (msg: PartialDeep<Resp.ListAudits>): Uint8Array {
      return Resp.ListAudits._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Resp.ListAudits from protobuf.
     */
    decode: function (bytes: ByteSource): Resp.ListAudits {
      return Resp.ListAudits._readMessage(
        Resp.ListAudits.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes Resp.ListAudits with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListAudits>): Resp.ListAudits {
      return {
        audits: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAudits>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.audits?.length) {
        writer.writeRepeatedMessage(1, msg.audits as any, Audit._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAudits,
      reader: protoscript.BinaryReader,
    ): Resp.ListAudits {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Audit.initialize();
            reader.readMessage(m, Audit._readMessage);
            msg.audits.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  _: "_",
  /**
   * sys
   */
  SysWithdraw: "SysWithdraw",
  ActionSysProperty: "ActionSysProperty",
  /**
   * proposal
   */
  ProposalMake: "ProposalMake",
  ProposalShout: "ProposalShout",
  ProposalVote: "ProposalVote",
  /**
   * Collateral
   */
  CatCreate: "CatCreate",
  CatSupply: "CatSupply",
  CatEdit: "CatEdit",
  CatFold: "CatFold",
  CatMove: "CatMove",
  CatGain: "CatGain",
  CatFill: "CatFill",
  /**
   * Vaults
   */
  VatOpen: "VatOpen",
  VatDeposit: "VatDeposit",
  VatWithdraw: "VatWithdraw",
  VatPayback: "VatPayback",
  VatGenerate: "VatGenerate",
  /**
   * Flips
   */
  FlipKick: "FlipKick",
  FlipBid: "FlipBid",
  FlipDeal: "FlipDeal",
  /**
   * Oracles
   */
  OracleCreate: "OracleCreate",
  OracleEdit: "OracleEdit",
  OraclePoke: "OraclePoke",
  OracleRely: "OracleRely",
  OracleDeny: "OracleDeny",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "_";
      }
      case 1: {
        return "SysWithdraw";
      }
      case 2: {
        return "ActionSysProperty";
      }
      case 11: {
        return "ProposalMake";
      }
      case 12: {
        return "ProposalShout";
      }
      case 13: {
        return "ProposalVote";
      }
      case 21: {
        return "CatCreate";
      }
      case 22: {
        return "CatSupply";
      }
      case 23: {
        return "CatEdit";
      }
      case 24: {
        return "CatFold";
      }
      case 25: {
        return "CatMove";
      }
      case 26: {
        return "CatGain";
      }
      case 27: {
        return "CatFill";
      }
      case 31: {
        return "VatOpen";
      }
      case 32: {
        return "VatDeposit";
      }
      case 33: {
        return "VatWithdraw";
      }
      case 34: {
        return "VatPayback";
      }
      case 35: {
        return "VatGenerate";
      }
      case 41: {
        return "FlipKick";
      }
      case 42: {
        return "FlipBid";
      }
      case 43: {
        return "FlipDeal";
      }
      case 51: {
        return "OracleCreate";
      }
      case 52: {
        return "OracleEdit";
      }
      case 53: {
        return "OraclePoke";
      }
      case 54: {
        return "OracleRely";
      }
      case 55: {
        return "OracleDeny";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "_": {
        return 0;
      }
      case "SysWithdraw": {
        return 1;
      }
      case "ActionSysProperty": {
        return 2;
      }
      case "ProposalMake": {
        return 11;
      }
      case "ProposalShout": {
        return 12;
      }
      case "ProposalVote": {
        return 13;
      }
      case "CatCreate": {
        return 21;
      }
      case "CatSupply": {
        return 22;
      }
      case "CatEdit": {
        return 23;
      }
      case "CatFold": {
        return 24;
      }
      case "CatMove": {
        return 25;
      }
      case "CatGain": {
        return 26;
      }
      case "CatFill": {
        return 27;
      }
      case "VatOpen": {
        return 31;
      }
      case "VatDeposit": {
        return 32;
      }
      case "VatWithdraw": {
        return 33;
      }
      case "VatPayback": {
        return 34;
      }
      case "VatGenerate": {
        return 35;
      }
      case "FlipKick": {
        return 41;
      }
      case "FlipBid": {
        return 42;
      }
      case "FlipDeal": {
        return 43;
      }
      case "OracleCreate": {
        return 51;
      }
      case "OracleEdit": {
        return 52;
      }
      case "OraclePoke": {
        return 53;
      }
      case "OracleRely": {
        return 54;
      }
      case "OracleDeny": {
        return 55;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PaginationJSON = {
  /**
   * Serializes Pagination to JSON.
   */
  encode: function (msg: PartialDeep<Pagination>): string {
    return JSON.stringify(PaginationJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pagination from JSON.
   */
  decode: function (json: string): Pagination {
    return PaginationJSON._readMessage(
      PaginationJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Pagination with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Pagination>): Pagination {
    return {
      nextCursor: "",
      hasNext: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Pagination>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nextCursor) {
      json["nextCursor"] = msg.nextCursor;
    }
    if (msg.hasNext) {
      json["hasNext"] = msg.hasNext;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pagination, json: any): Pagination {
    const _nextCursor_ = json["nextCursor"] ?? json["next_cursor"];
    if (_nextCursor_) {
      msg.nextCursor = _nextCursor_;
    }
    const _hasNext_ = json["hasNext"] ?? json["has_next"];
    if (_hasNext_) {
      msg.hasNext = _hasNext_;
    }
    return msg;
  },
};

export const AssetJSON = {
  /**
   * Serializes Asset to JSON.
   */
  encode: function (msg: PartialDeep<Asset>): string {
    return JSON.stringify(AssetJSON._writeMessage(msg));
  },

  /**
   * Deserializes Asset from JSON.
   */
  decode: function (json: string): Asset {
    return AssetJSON._readMessage(AssetJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      name: "",
      symbol: "",
      logo: "",
      chainId: "",
      chain: undefined,
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Asset>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.symbol) {
      json["symbol"] = msg.symbol;
    }
    if (msg.logo) {
      json["logo"] = msg.logo;
    }
    if (msg.chainId) {
      json["chainId"] = msg.chainId;
    }
    if (msg.chain) {
      const _chain_ = AssetJSON._writeMessage(msg.chain);
      if (Object.keys(_chain_).length > 0) {
        json["chain"] = _chain_;
      }
    }
    if (msg.price) {
      json["price"] = msg.price;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, json: any): Asset {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _symbol_ = json["symbol"];
    if (_symbol_) {
      msg.symbol = _symbol_;
    }
    const _logo_ = json["logo"];
    if (_logo_) {
      msg.logo = _logo_;
    }
    const _chainId_ = json["chainId"] ?? json["chain_id"];
    if (_chainId_) {
      msg.chainId = _chainId_;
    }
    const _chain_ = json["chain"];
    if (_chain_) {
      msg.chain = AssetJSON.initialize();
      AssetJSON._readMessage(msg.chain, _chain_);
    }
    const _price_ = json["price"];
    if (_price_) {
      msg.price = _price_;
    }
    return msg;
  },
};

export const CollateralJSON = {
  /**
   * Serializes Collateral to JSON.
   */
  encode: function (msg: PartialDeep<Collateral>): string {
    return JSON.stringify(CollateralJSON._writeMessage(msg));
  },

  /**
   * Deserializes Collateral from JSON.
   */
  decode: function (json: string): Collateral {
    return CollateralJSON._readMessage(
      CollateralJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Collateral with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Collateral>): Collateral {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      name: "",
      gem: "",
      dai: "",
      ink: "",
      art: "",
      rate: "",
      rho: protoscript.TimestampJSON.initialize(),
      debt: "",
      line: "",
      dust: "",
      price: "",
      mat: "",
      duty: "",
      chop: "",
      dunk: "",
      beg: "",
      ttl: 0,
      tau: 0,
      live: false,
      numberOfVaults: 0n,
      box: "",
      litter: "",
      supply: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Collateral>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.gem) {
      json["gem"] = msg.gem;
    }
    if (msg.dai) {
      json["dai"] = msg.dai;
    }
    if (msg.ink) {
      json["ink"] = msg.ink;
    }
    if (msg.art) {
      json["art"] = msg.art;
    }
    if (msg.rate) {
      json["rate"] = msg.rate;
    }
    if (msg.rho && msg.rho.seconds && msg.rho.nanos) {
      json["rho"] = protoscript.serializeTimestamp(msg.rho);
    }
    if (msg.debt) {
      json["debt"] = msg.debt;
    }
    if (msg.line) {
      json["line"] = msg.line;
    }
    if (msg.dust) {
      json["dust"] = msg.dust;
    }
    if (msg.price) {
      json["price"] = msg.price;
    }
    if (msg.mat) {
      json["mat"] = msg.mat;
    }
    if (msg.duty) {
      json["duty"] = msg.duty;
    }
    if (msg.chop) {
      json["chop"] = msg.chop;
    }
    if (msg.dunk) {
      json["dunk"] = msg.dunk;
    }
    if (msg.beg) {
      json["beg"] = msg.beg;
    }
    if (msg.ttl) {
      json["ttl"] = msg.ttl;
    }
    if (msg.tau) {
      json["tau"] = msg.tau;
    }
    if (msg.live) {
      json["live"] = msg.live;
    }
    if (msg.numberOfVaults) {
      json["numberOfVaults"] = String(msg.numberOfVaults);
    }
    if (msg.box) {
      json["box"] = msg.box;
    }
    if (msg.litter) {
      json["litter"] = msg.litter;
    }
    if (msg.supply) {
      json["supply"] = msg.supply;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Collateral, json: any): Collateral {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _gem_ = json["gem"];
    if (_gem_) {
      msg.gem = _gem_;
    }
    const _dai_ = json["dai"];
    if (_dai_) {
      msg.dai = _dai_;
    }
    const _ink_ = json["ink"];
    if (_ink_) {
      msg.ink = _ink_;
    }
    const _art_ = json["art"];
    if (_art_) {
      msg.art = _art_;
    }
    const _rate_ = json["rate"];
    if (_rate_) {
      msg.rate = _rate_;
    }
    const _rho_ = json["rho"];
    if (_rho_) {
      msg.rho = protoscript.parseTimestamp(_rho_);
    }
    const _debt_ = json["debt"];
    if (_debt_) {
      msg.debt = _debt_;
    }
    const _line_ = json["line"];
    if (_line_) {
      msg.line = _line_;
    }
    const _dust_ = json["dust"];
    if (_dust_) {
      msg.dust = _dust_;
    }
    const _price_ = json["price"];
    if (_price_) {
      msg.price = _price_;
    }
    const _mat_ = json["mat"];
    if (_mat_) {
      msg.mat = _mat_;
    }
    const _duty_ = json["duty"];
    if (_duty_) {
      msg.duty = _duty_;
    }
    const _chop_ = json["chop"];
    if (_chop_) {
      msg.chop = _chop_;
    }
    const _dunk_ = json["dunk"];
    if (_dunk_) {
      msg.dunk = _dunk_;
    }
    const _beg_ = json["beg"];
    if (_beg_) {
      msg.beg = _beg_;
    }
    const _ttl_ = json["ttl"];
    if (_ttl_) {
      msg.ttl = protoscript.parseNumber(_ttl_);
    }
    const _tau_ = json["tau"];
    if (_tau_) {
      msg.tau = protoscript.parseNumber(_tau_);
    }
    const _live_ = json["live"];
    if (_live_) {
      msg.live = _live_;
    }
    const _numberOfVaults_ = json["numberOfVaults"] ?? json["number_of_vaults"];
    if (_numberOfVaults_) {
      msg.numberOfVaults = BigInt(_numberOfVaults_);
    }
    const _box_ = json["box"];
    if (_box_) {
      msg.box = _box_;
    }
    const _litter_ = json["litter"];
    if (_litter_) {
      msg.litter = _litter_;
    }
    const _supply_ = json["supply"];
    if (_supply_) {
      msg.supply = _supply_;
    }
    return msg;
  },
};

export const VaultJSON = {
  /**
   * Serializes Vault to JSON.
   */
  encode: function (msg: PartialDeep<Vault>): string {
    return JSON.stringify(VaultJSON._writeMessage(msg));
  },

  /**
   * Deserializes Vault from JSON.
   */
  decode: function (json: string): Vault {
    return VaultJSON._readMessage(VaultJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Vault with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Vault>): Vault {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      collateralId: "",
      ink: "",
      art: "",
      identityId: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Vault>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.collateralId) {
      json["collateralId"] = msg.collateralId;
    }
    if (msg.ink) {
      json["ink"] = msg.ink;
    }
    if (msg.art) {
      json["art"] = msg.art;
    }
    if (msg.identityId) {
      json["identityId"] = String(msg.identityId);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Vault, json: any): Vault {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _collateralId_ = json["collateralId"] ?? json["collateral_id"];
    if (_collateralId_) {
      msg.collateralId = _collateralId_;
    }
    const _ink_ = json["ink"];
    if (_ink_) {
      msg.ink = _ink_;
    }
    const _art_ = json["art"];
    if (_art_) {
      msg.art = _art_;
    }
    const _identityId_ = json["identityId"] ?? json["identity_id"];
    if (_identityId_) {
      msg.identityId = BigInt(_identityId_);
    }
    return msg;
  },

  Event: {
    /**
     * Serializes Vault.Event to JSON.
     */
    encode: function (msg: PartialDeep<Vault.Event>): string {
      return JSON.stringify(VaultJSON.Event._writeMessage(msg));
    },

    /**
     * Deserializes Vault.Event from JSON.
     */
    decode: function (json: string): Vault.Event {
      return VaultJSON.Event._readMessage(
        VaultJSON.Event.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Vault.Event with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Vault.Event>): Vault.Event {
      return {
        vaultId: "",
        createdAt: protoscript.TimestampJSON.initialize(),
        action: Action._fromInt(0),
        dink: "",
        dart: "",
        debt: "",
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Vault.Event>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaultId) {
        json["vaultId"] = msg.vaultId;
      }
      if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
        json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
      }
      if (msg.action && ActionJSON._toInt(msg.action)) {
        json["action"] = msg.action;
      }
      if (msg.dink) {
        json["dink"] = msg.dink;
      }
      if (msg.dart) {
        json["dart"] = msg.dart;
      }
      if (msg.debt) {
        json["debt"] = msg.debt;
      }
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Vault.Event, json: any): Vault.Event {
      const _vaultId_ = json["vaultId"] ?? json["vault_id"];
      if (_vaultId_) {
        msg.vaultId = _vaultId_;
      }
      const _createdAt_ = json["createdAt"] ?? json["created_at"];
      if (_createdAt_) {
        msg.createdAt = protoscript.parseTimestamp(_createdAt_);
      }
      const _action_ = json["action"];
      if (_action_) {
        msg.action = Action._fromInt(_action_);
      }
      const _dink_ = json["dink"];
      if (_dink_) {
        msg.dink = _dink_;
      }
      const _dart_ = json["dart"];
      if (_dart_) {
        msg.dart = _dart_;
      }
      const _debt_ = json["debt"];
      if (_debt_) {
        msg.debt = _debt_;
      }
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },
};

export const FlipJSON = {
  /**
   * Serializes Flip to JSON.
   */
  encode: function (msg: PartialDeep<Flip>): string {
    return JSON.stringify(FlipJSON._writeMessage(msg));
  },

  /**
   * Deserializes Flip from JSON.
   */
  decode: function (json: string): Flip {
    return FlipJSON._readMessage(FlipJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Flip with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Flip>): Flip {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      tic: protoscript.TimestampJSON.initialize(),
      end: protoscript.TimestampJSON.initialize(),
      bid: "",
      lot: "",
      tab: "",
      art: "",
      collateralId: "",
      vaultId: "",
      guy: "",
      action: Action._fromInt(0),
      tags: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Flip>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.tic && msg.tic.seconds && msg.tic.nanos) {
      json["tic"] = protoscript.serializeTimestamp(msg.tic);
    }
    if (msg.end && msg.end.seconds && msg.end.nanos) {
      json["end"] = protoscript.serializeTimestamp(msg.end);
    }
    if (msg.bid) {
      json["bid"] = msg.bid;
    }
    if (msg.lot) {
      json["lot"] = msg.lot;
    }
    if (msg.tab) {
      json["tab"] = msg.tab;
    }
    if (msg.art) {
      json["art"] = msg.art;
    }
    if (msg.collateralId) {
      json["collateralId"] = msg.collateralId;
    }
    if (msg.vaultId) {
      json["vaultId"] = msg.vaultId;
    }
    if (msg.guy) {
      json["guy"] = msg.guy;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.tags?.length) {
      json["tags"] = msg.tags;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Flip, json: any): Flip {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _tic_ = json["tic"];
    if (_tic_) {
      msg.tic = protoscript.parseTimestamp(_tic_);
    }
    const _end_ = json["end"];
    if (_end_) {
      msg.end = protoscript.parseTimestamp(_end_);
    }
    const _bid_ = json["bid"];
    if (_bid_) {
      msg.bid = _bid_;
    }
    const _lot_ = json["lot"];
    if (_lot_) {
      msg.lot = _lot_;
    }
    const _tab_ = json["tab"];
    if (_tab_) {
      msg.tab = _tab_;
    }
    const _art_ = json["art"];
    if (_art_) {
      msg.art = _art_;
    }
    const _collateralId_ = json["collateralId"] ?? json["collateral_id"];
    if (_collateralId_) {
      msg.collateralId = _collateralId_;
    }
    const _vaultId_ = json["vaultId"] ?? json["vault_id"];
    if (_vaultId_) {
      msg.vaultId = _vaultId_;
    }
    const _guy_ = json["guy"];
    if (_guy_) {
      msg.guy = _guy_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _tags_ = json["tags"];
    if (_tags_) {
      msg.tags = _tags_.map(Flip.Tag._fromInt);
    }
    return msg;
  },

  Tag: {
    MyVault: "MyVault",
    Participated: "Participated",
    Leading: "Leading",
    /**
     * @private
     */
    _fromInt: function (i: number): Flip.Tag {
      switch (i) {
        case 0: {
          return "MyVault";
        }
        case 1: {
          return "Participated";
        }
        case 2: {
          return "Leading";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Flip.Tag;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Flip.Tag): number {
      switch (i) {
        case "MyVault": {
          return 0;
        }
        case "Participated": {
          return 1;
        }
        case "Leading": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Event: {
    /**
     * Serializes Flip.Event to JSON.
     */
    encode: function (msg: PartialDeep<Flip.Event>): string {
      return JSON.stringify(FlipJSON.Event._writeMessage(msg));
    },

    /**
     * Deserializes Flip.Event from JSON.
     */
    decode: function (json: string): Flip.Event {
      return FlipJSON.Event._readMessage(
        FlipJSON.Event.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Flip.Event with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Flip.Event>): Flip.Event {
      return {
        flipId: "",
        createdAt: protoscript.TimestampJSON.initialize(),
        action: Action._fromInt(0),
        bid: "",
        lot: "",
        isMe: false,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Flip.Event>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flipId) {
        json["flipId"] = msg.flipId;
      }
      if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
        json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
      }
      if (msg.action && ActionJSON._toInt(msg.action)) {
        json["action"] = msg.action;
      }
      if (msg.bid) {
        json["bid"] = msg.bid;
      }
      if (msg.lot) {
        json["lot"] = msg.lot;
      }
      if (msg.isMe) {
        json["isMe"] = msg.isMe;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Flip.Event, json: any): Flip.Event {
      const _flipId_ = json["flipId"] ?? json["flip_id"];
      if (_flipId_) {
        msg.flipId = _flipId_;
      }
      const _createdAt_ = json["createdAt"] ?? json["created_at"];
      if (_createdAt_) {
        msg.createdAt = protoscript.parseTimestamp(_createdAt_);
      }
      const _action_ = json["action"];
      if (_action_) {
        msg.action = Action._fromInt(_action_);
      }
      const _bid_ = json["bid"];
      if (_bid_) {
        msg.bid = _bid_;
      }
      const _lot_ = json["lot"];
      if (_lot_) {
        msg.lot = _lot_;
      }
      const _isMe_ = json["isMe"] ?? json["is_me"];
      if (_isMe_) {
        msg.isMe = _isMe_;
      }
      return msg;
    },
  },
};

export const ProposalJSON = {
  /**
   * Serializes Proposal to JSON.
   */
  encode: function (msg: PartialDeep<Proposal>): string {
    return JSON.stringify(ProposalJSON._writeMessage(msg));
  },

  /**
   * Deserializes Proposal from JSON.
   */
  decode: function (json: string): Proposal {
    return ProposalJSON._readMessage(
      ProposalJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Proposal with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Proposal>): Proposal {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      passedAt: protoscript.TimestampJSON.initialize(),
      creator: "",
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      data: "",
      votes: [],
      items: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Proposal>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.passedAt && msg.passedAt.seconds && msg.passedAt.nanos) {
      json["passedAt"] = protoscript.serializeTimestamp(msg.passedAt);
    }
    if (msg.creator) {
      json["creator"] = msg.creator;
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.data) {
      json["data"] = msg.data;
    }
    if (msg.votes?.length) {
      json["votes"] = msg.votes;
    }
    if (msg.items?.length) {
      json["items"] = msg.items.map(ProposalJSON.Item._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Proposal, json: any): Proposal {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _passedAt_ = json["passedAt"] ?? json["passed_at"];
    if (_passedAt_) {
      msg.passedAt = protoscript.parseTimestamp(_passedAt_);
    }
    const _creator_ = json["creator"];
    if (_creator_) {
      msg.creator = _creator_;
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    const _votes_ = json["votes"];
    if (_votes_) {
      msg.votes = _votes_;
    }
    const _items_ = json["items"];
    if (_items_) {
      for (const item of _items_) {
        const m = ProposalJSON.Item.initialize();
        ProposalJSON.Item._readMessage(m, item);
        msg.items.push(m);
      }
    }
    return msg;
  },

  Item: {
    /**
     * Serializes Proposal.Item to JSON.
     */
    encode: function (msg: PartialDeep<Proposal.Item>): string {
      return JSON.stringify(ProposalJSON.Item._writeMessage(msg));
    },

    /**
     * Deserializes Proposal.Item from JSON.
     */
    decode: function (json: string): Proposal.Item {
      return ProposalJSON.Item._readMessage(
        ProposalJSON.Item.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Proposal.Item with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Proposal.Item>): Proposal.Item {
      return {
        key: "",
        value: "",
        hint: "",
        action: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Proposal.Item>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      if (msg.hint) {
        json["hint"] = msg.hint;
      }
      if (msg.action) {
        json["action"] = msg.action;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Proposal.Item, json: any): Proposal.Item {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      const _hint_ = json["hint"];
      if (_hint_) {
        msg.hint = _hint_;
      }
      const _action_ = json["action"];
      if (_action_) {
        msg.action = _action_;
      }
      return msg;
    },
  },
};

export const OracleJSON = {
  /**
   * Serializes Oracle to JSON.
   */
  encode: function (msg: PartialDeep<Oracle>): string {
    return JSON.stringify(OracleJSON._writeMessage(msg));
  },

  /**
   * Deserializes Oracle from JSON.
   */
  decode: function (json: string): Oracle {
    return OracleJSON._readMessage(OracleJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Oracle with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Oracle>): Oracle {
    return {
      assetId: "",
      hop: 0,
      current: "",
      next: "",
      peekAt: protoscript.TimestampJSON.initialize(),
      threshold: 0,
      governors: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Oracle>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.hop) {
      json["hop"] = msg.hop;
    }
    if (msg.current) {
      json["current"] = msg.current;
    }
    if (msg.next) {
      json["next"] = msg.next;
    }
    if (msg.peekAt && msg.peekAt.seconds && msg.peekAt.nanos) {
      json["peekAt"] = protoscript.serializeTimestamp(msg.peekAt);
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.governors?.length) {
      json["governors"] = msg.governors;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Oracle, json: any): Oracle {
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _hop_ = json["hop"];
    if (_hop_) {
      msg.hop = protoscript.parseNumber(_hop_);
    }
    const _current_ = json["current"];
    if (_current_) {
      msg.current = _current_;
    }
    const _next_ = json["next"];
    if (_next_) {
      msg.next = _next_;
    }
    const _peekAt_ = json["peekAt"] ?? json["peek_at"];
    if (_peekAt_) {
      msg.peekAt = protoscript.parseTimestamp(_peekAt_);
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _governors_ = json["governors"];
    if (_governors_) {
      msg.governors = _governors_;
    }
    return msg;
  },
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: PartialDeep<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      assetId: "",
      amount: "",
      action: Action._fromInt(0),
      status: Transaction.Status._fromInt(0),
      msg: "",
      parameters: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.action && ActionJSON._toInt(msg.action)) {
      json["action"] = msg.action;
    }
    if (msg.status && TransactionJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.msg) {
      json["msg"] = msg.msg;
    }
    if (msg.parameters) {
      json["parameters"] = msg.parameters;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _action_ = json["action"];
    if (_action_) {
      msg.action = Action._fromInt(_action_);
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Transaction.Status._fromInt(_status_);
    }
    const _msg_ = json["msg"];
    if (_msg_) {
      msg.msg = _msg_;
    }
    const _parameters_ = json["parameters"];
    if (_parameters_) {
      msg.parameters = _parameters_;
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Abort: "Abort",
    OK: "OK",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Abort";
        }
        case 2: {
          return "OK";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Abort": {
          return 1;
        }
        case "OK": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const StatJSON = {
  /**
   * Serializes Stat to JSON.
   */
  encode: function (msg: PartialDeep<Stat>): string {
    return JSON.stringify(StatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Stat from JSON.
   */
  decode: function (json: string): Stat {
    return StatJSON._readMessage(StatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Stat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Stat>): Stat {
    return {
      collateralId: "",
      date: protoscript.TimestampJSON.initialize(),
      timestamp: 0n,
      gem: "",
      dai: "",
      ink: "",
      debt: "",
      gemPrice: "",
      daiPrice: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Stat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.collateralId) {
      json["collateralId"] = msg.collateralId;
    }
    if (msg.date && msg.date.seconds && msg.date.nanos) {
      json["date"] = protoscript.serializeTimestamp(msg.date);
    }
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.gem) {
      json["gem"] = msg.gem;
    }
    if (msg.dai) {
      json["dai"] = msg.dai;
    }
    if (msg.ink) {
      json["ink"] = msg.ink;
    }
    if (msg.debt) {
      json["debt"] = msg.debt;
    }
    if (msg.gemPrice) {
      json["gemPrice"] = msg.gemPrice;
    }
    if (msg.daiPrice) {
      json["daiPrice"] = msg.daiPrice;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Stat, json: any): Stat {
    const _collateralId_ = json["collateralId"] ?? json["collateral_id"];
    if (_collateralId_) {
      msg.collateralId = _collateralId_;
    }
    const _date_ = json["date"];
    if (_date_) {
      msg.date = protoscript.parseTimestamp(_date_);
    }
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _gem_ = json["gem"];
    if (_gem_) {
      msg.gem = _gem_;
    }
    const _dai_ = json["dai"];
    if (_dai_) {
      msg.dai = _dai_;
    }
    const _ink_ = json["ink"];
    if (_ink_) {
      msg.ink = _ink_;
    }
    const _debt_ = json["debt"];
    if (_debt_) {
      msg.debt = _debt_;
    }
    const _gemPrice_ = json["gemPrice"] ?? json["gem_price"];
    if (_gemPrice_) {
      msg.gemPrice = _gemPrice_;
    }
    const _daiPrice_ = json["daiPrice"] ?? json["dai_price"];
    if (_daiPrice_) {
      msg.daiPrice = _daiPrice_;
    }
    return msg;
  },
};

export const AggregatedStatJSON = {
  /**
   * Serializes AggregatedStat to JSON.
   */
  encode: function (msg: PartialDeep<AggregatedStat>): string {
    return JSON.stringify(AggregatedStatJSON._writeMessage(msg));
  },

  /**
   * Deserializes AggregatedStat from JSON.
   */
  decode: function (json: string): AggregatedStat {
    return AggregatedStatJSON._readMessage(
      AggregatedStatJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes AggregatedStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AggregatedStat>): AggregatedStat {
    return {
      date: protoscript.TimestampJSON.initialize(),
      timestamp: 0n,
      gemValue: "",
      daiValue: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AggregatedStat>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.date && msg.date.seconds && msg.date.nanos) {
      json["date"] = protoscript.serializeTimestamp(msg.date);
    }
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.gemValue) {
      json["gemValue"] = msg.gemValue;
    }
    if (msg.daiValue) {
      json["daiValue"] = msg.daiValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: AggregatedStat, json: any): AggregatedStat {
    const _date_ = json["date"];
    if (_date_) {
      msg.date = protoscript.parseTimestamp(_date_);
    }
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _gemValue_ = json["gemValue"] ?? json["gem_value"];
    if (_gemValue_) {
      msg.gemValue = _gemValue_;
    }
    const _daiValue_ = json["daiValue"] ?? json["dai_value"];
    if (_daiValue_) {
      msg.daiValue = _daiValue_;
    }
    return msg;
  },
};

export const AuditJSON = {
  /**
   * Serializes Audit to JSON.
   */
  encode: function (msg: PartialDeep<Audit>): string {
    return JSON.stringify(AuditJSON._writeMessage(msg));
  },

  /**
   * Deserializes Audit from JSON.
   */
  decode: function (json: string): Audit {
    return AuditJSON._readMessage(AuditJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Audit with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Audit>): Audit {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      assetId: "",
      amount: "",
      userId: "",
      status: Audit.Status._fromInt(0),
      memo: "",
      reviewedBy: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Audit>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.status && AuditJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.reviewedBy) {
      json["reviewedBy"] = msg.reviewedBy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Audit, json: any): Audit {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Audit.Status._fromInt(_status_);
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _reviewedBy_ = json["reviewedBy"] ?? json["reviewed_by"];
    if (_reviewedBy_) {
      msg.reviewedBy = _reviewedBy_;
    }
    return msg;
  },

  Status: {
    Pending: "Pending",
    Rejected: "Rejected",
    Approved: "Approved",
    /**
     * @private
     */
    _fromInt: function (i: number): Audit.Status {
      switch (i) {
        case 0: {
          return "Pending";
        }
        case 1: {
          return "Rejected";
        }
        case 2: {
          return "Approved";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Audit.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Audit.Status): number {
      switch (i) {
        case "Pending": {
          return 0;
        }
        case "Rejected": {
          return 1;
        }
        case "Approved": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg?: PartialDeep<Req>): string {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json?: string): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Req>): Req {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: PartialDeep<Req>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Req, _json: any): Req {
    return msg;
  },

  FindAsset: {
    /**
     * Serializes Req.FindAsset to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindAsset>): string {
      return JSON.stringify(ReqJSON.FindAsset._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindAsset from JSON.
     */
    decode: function (json: string): Req.FindAsset {
      return ReqJSON.FindAsset._readMessage(
        ReqJSON.FindAsset.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindAsset with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindAsset>): Req.FindAsset {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindAsset>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindAsset, json: any): Req.FindAsset {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListAssets: {
    /**
     * Serializes Req.ListAssets to JSON.
     */
    encode: function (_msg?: PartialDeep<Req.ListAssets>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListAssets from JSON.
     */
    decode: function (_json?: string): Req.ListAssets {
      return {};
    },

    /**
     * Initializes Req.ListAssets with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListAssets>): Req.ListAssets {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListAssets>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListAssets, _json: any): Req.ListAssets {
      return msg;
    },
  },

  FindOracle: {
    /**
     * Serializes Req.FindOracle to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindOracle>): string {
      return JSON.stringify(ReqJSON.FindOracle._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindOracle from JSON.
     */
    decode: function (json: string): Req.FindOracle {
      return ReqJSON.FindOracle._readMessage(
        ReqJSON.FindOracle.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindOracle with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindOracle>): Req.FindOracle {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindOracle>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindOracle, json: any): Req.FindOracle {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Req.ListOracles to JSON.
     */
    encode: function (_msg?: PartialDeep<Req.ListOracles>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListOracles from JSON.
     */
    decode: function (_json?: string): Req.ListOracles {
      return {};
    },

    /**
     * Initializes Req.ListOracles with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListOracles>): Req.ListOracles {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListOracles>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListOracles, _json: any): Req.ListOracles {
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Req.ListCollaterals to JSON.
     */
    encode: function (_msg?: PartialDeep<Req.ListCollaterals>): string {
      return "{}";
    },

    /**
     * Deserializes Req.ListCollaterals from JSON.
     */
    decode: function (_json?: string): Req.ListCollaterals {
      return {};
    },

    /**
     * Initializes Req.ListCollaterals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListCollaterals>,
    ): Req.ListCollaterals {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.ListCollaterals>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListCollaterals,
      _json: any,
    ): Req.ListCollaterals {
      return msg;
    },
  },

  FindCollateral: {
    /**
     * Serializes Req.FindCollateral to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindCollateral>): string {
      return JSON.stringify(ReqJSON.FindCollateral._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindCollateral from JSON.
     */
    decode: function (json: string): Req.FindCollateral {
      return ReqJSON.FindCollateral._readMessage(
        ReqJSON.FindCollateral.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindCollateral with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.FindCollateral>,
    ): Req.FindCollateral {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindCollateral>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindCollateral,
      json: any,
    ): Req.FindCollateral {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  FindVault: {
    /**
     * Serializes Req.FindVault to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindVault>): string {
      return JSON.stringify(ReqJSON.FindVault._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindVault from JSON.
     */
    decode: function (json: string): Req.FindVault {
      return ReqJSON.FindVault._readMessage(
        ReqJSON.FindVault.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindVault with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindVault>): Req.FindVault {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindVault>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindVault, json: any): Req.FindVault {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Req.ListVaults to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListVaults>): string {
      return JSON.stringify(ReqJSON.ListVaults._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListVaults from JSON.
     */
    decode: function (json: string): Req.ListVaults {
      return ReqJSON.ListVaults._readMessage(
        ReqJSON.ListVaults.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListVaults>): Req.ListVaults {
      return {
        collateralId: "",
        userId: "",
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListVaults>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.collateralId) {
        json["collateralId"] = msg.collateralId;
      }
      if (msg.userId) {
        json["userId"] = msg.userId;
      }
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListVaults, json: any): Req.ListVaults {
      const _collateralId_ = json["collateralId"] ?? json["collateral_id"];
      if (_collateralId_) {
        msg.collateralId = _collateralId_;
      }
      const _userId_ = json["userId"] ?? json["user_id"];
      if (_userId_) {
        msg.userId = _userId_;
      }
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Req.ListMyVaults to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListMyVaults>): string {
      return JSON.stringify(ReqJSON.ListMyVaults._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListMyVaults from JSON.
     */
    decode: function (json: string): Req.ListMyVaults {
      return ReqJSON.ListMyVaults._readMessage(
        ReqJSON.ListMyVaults.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListMyVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListMyVaults>): Req.ListMyVaults {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListMyVaults>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListMyVaults,
      json: any,
    ): Req.ListMyVaults {
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Req.ListVaultEvents to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListVaultEvents>): string {
      return JSON.stringify(ReqJSON.ListVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListVaultEvents from JSON.
     */
    decode: function (json: string): Req.ListVaultEvents {
      return ReqJSON.ListVaultEvents._readMessage(
        ReqJSON.ListVaultEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListVaultEvents>,
    ): Req.ListVaultEvents {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListVaultEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListVaultEvents,
      json: any,
    ): Req.ListVaultEvents {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Req.QueryVaultEvents to JSON.
     */
    encode: function (msg: PartialDeep<Req.QueryVaultEvents>): string {
      return JSON.stringify(ReqJSON.QueryVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.QueryVaultEvents from JSON.
     */
    decode: function (json: string): Req.QueryVaultEvents {
      return ReqJSON.QueryVaultEvents._readMessage(
        ReqJSON.QueryVaultEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.QueryVaultEvents>,
    ): Req.QueryVaultEvents {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.QueryVaultEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.QueryVaultEvents,
      json: any,
    ): Req.QueryVaultEvents {
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  FindFlip: {
    /**
     * Serializes Req.FindFlip to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindFlip>): string {
      return JSON.stringify(ReqJSON.FindFlip._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindFlip from JSON.
     */
    decode: function (json: string): Req.FindFlip {
      return ReqJSON.FindFlip._readMessage(
        ReqJSON.FindFlip.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindFlip with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindFlip>): Req.FindFlip {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindFlip>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindFlip, json: any): Req.FindFlip {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Req.ListFlips to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListFlips>): string {
      return JSON.stringify(ReqJSON.ListFlips._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListFlips from JSON.
     */
    decode: function (json: string): Req.ListFlips {
      return ReqJSON.ListFlips._readMessage(
        ReqJSON.ListFlips.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListFlips>): Req.ListFlips {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListFlips>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListFlips, json: any): Req.ListFlips {
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Req.QueryFlips to JSON.
     */
    encode: function (msg: PartialDeep<Req.QueryFlips>): string {
      return JSON.stringify(ReqJSON.QueryFlips._writeMessage(msg));
    },

    /**
     * Deserializes Req.QueryFlips from JSON.
     */
    decode: function (json: string): Req.QueryFlips {
      return ReqJSON.QueryFlips._readMessage(
        ReqJSON.QueryFlips.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.QueryFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.QueryFlips>): Req.QueryFlips {
      return {
        offset: 0n,
        limit: 0n,
        phase: "",
        myVaults: "",
        myBids: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.QueryFlips>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.offset) {
        json["offset"] = String(msg.offset);
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      if (msg.phase) {
        json["phase"] = msg.phase;
      }
      if (msg.myVaults) {
        json["myVaults"] = msg.myVaults;
      }
      if (msg.myBids) {
        json["myBids"] = msg.myBids;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.QueryFlips, json: any): Req.QueryFlips {
      const _offset_ = json["offset"];
      if (_offset_) {
        msg.offset = BigInt(_offset_);
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      const _phase_ = json["phase"];
      if (_phase_) {
        msg.phase = _phase_;
      }
      const _myVaults_ = json["myVaults"] ?? json["my_vaults"];
      if (_myVaults_) {
        msg.myVaults = _myVaults_;
      }
      const _myBids_ = json["myBids"] ?? json["my_bids"];
      if (_myBids_) {
        msg.myBids = _myBids_;
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Req.ListFlipEvents to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListFlipEvents>): string {
      return JSON.stringify(ReqJSON.ListFlipEvents._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListFlipEvents from JSON.
     */
    decode: function (json: string): Req.ListFlipEvents {
      return ReqJSON.ListFlipEvents._readMessage(
        ReqJSON.ListFlipEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListFlipEvents>,
    ): Req.ListFlipEvents {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListFlipEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListFlipEvents,
      json: any,
    ): Req.ListFlipEvents {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  FindTransaction: {
    /**
     * Serializes Req.FindTransaction to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindTransaction>): string {
      return JSON.stringify(ReqJSON.FindTransaction._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindTransaction from JSON.
     */
    decode: function (json: string): Req.FindTransaction {
      return ReqJSON.FindTransaction._readMessage(
        ReqJSON.FindTransaction.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindTransaction with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.FindTransaction>,
    ): Req.FindTransaction {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindTransaction>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindTransaction,
      json: any,
    ): Req.FindTransaction {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Req.ListTransactions to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListTransactions>): string {
      return JSON.stringify(ReqJSON.ListTransactions._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListTransactions from JSON.
     */
    decode: function (json: string): Req.ListTransactions {
      return ReqJSON.ListTransactions._readMessage(
        ReqJSON.ListTransactions.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListTransactions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListTransactions>,
    ): Req.ListTransactions {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListTransactions>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListTransactions,
      json: any,
    ): Req.ListTransactions {
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Req.ListProposals to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListProposals>): string {
      return JSON.stringify(ReqJSON.ListProposals._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListProposals from JSON.
     */
    decode: function (json: string): Req.ListProposals {
      return ReqJSON.ListProposals._readMessage(
        ReqJSON.ListProposals.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListProposals with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListProposals>): Req.ListProposals {
      return {
        cursor: "",
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListProposals>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.cursor) {
        json["cursor"] = msg.cursor;
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListProposals,
      json: any,
    ): Req.ListProposals {
      const _cursor_ = json["cursor"];
      if (_cursor_) {
        msg.cursor = _cursor_;
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },

  FindProposal: {
    /**
     * Serializes Req.FindProposal to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindProposal>): string {
      return JSON.stringify(ReqJSON.FindProposal._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindProposal from JSON.
     */
    decode: function (json: string): Req.FindProposal {
      return ReqJSON.FindProposal._readMessage(
        ReqJSON.FindProposal.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindProposal with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindProposal>): Req.FindProposal {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindProposal>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.FindProposal,
      json: any,
    ): Req.FindProposal {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Req.ListStats to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListStats>): string {
      return JSON.stringify(ReqJSON.ListStats._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListStats from JSON.
     */
    decode: function (json: string): Req.ListStats {
      return ReqJSON.ListStats._readMessage(
        ReqJSON.ListStats.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListStats with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListStats>): Req.ListStats {
      return {
        id: "",
        from: 0n,
        to: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListStats>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      if (msg.from) {
        json["from"] = String(msg.from);
      }
      if (msg.to) {
        json["to"] = String(msg.to);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListStats, json: any): Req.ListStats {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      const _from_ = json["from"];
      if (_from_) {
        msg.from = BigInt(_from_);
      }
      const _to_ = json["to"];
      if (_to_) {
        msg.to = BigInt(_to_);
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Req.ListAggregatedStats to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListAggregatedStats>): string {
      return JSON.stringify(ReqJSON.ListAggregatedStats._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListAggregatedStats from JSON.
     */
    decode: function (json: string): Req.ListAggregatedStats {
      return ReqJSON.ListAggregatedStats._readMessage(
        ReqJSON.ListAggregatedStats.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Req.ListAggregatedStats>,
    ): Req.ListAggregatedStats {
      return {
        from: 0n,
        to: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListAggregatedStats>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.from) {
        json["from"] = String(msg.from);
      }
      if (msg.to) {
        json["to"] = String(msg.to);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.ListAggregatedStats,
      json: any,
    ): Req.ListAggregatedStats {
      const _from_ = json["from"];
      if (_from_) {
        msg.from = BigInt(_from_);
      }
      const _to_ = json["to"];
      if (_to_) {
        msg.to = BigInt(_to_);
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Req.GetInfo to JSON.
     */
    encode: function (_msg?: PartialDeep<Req.GetInfo>): string {
      return "{}";
    },

    /**
     * Deserializes Req.GetInfo from JSON.
     */
    decode: function (_json?: string): Req.GetInfo {
      return {};
    },

    /**
     * Initializes Req.GetInfo with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.GetInfo>): Req.GetInfo {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<Req.GetInfo>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.GetInfo, _json: any): Req.GetInfo {
      return msg;
    },
  },

  FindAudit: {
    /**
     * Serializes Req.FindAudit to JSON.
     */
    encode: function (msg: PartialDeep<Req.FindAudit>): string {
      return JSON.stringify(ReqJSON.FindAudit._writeMessage(msg));
    },

    /**
     * Deserializes Req.FindAudit from JSON.
     */
    decode: function (json: string): Req.FindAudit {
      return ReqJSON.FindAudit._readMessage(
        ReqJSON.FindAudit.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.FindAudit with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.FindAudit>): Req.FindAudit {
      return {
        id: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.FindAudit>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.id) {
        json["id"] = msg.id;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.FindAudit, json: any): Req.FindAudit {
      const _id_ = json["id"];
      if (_id_) {
        msg.id = _id_;
      }
      return msg;
    },
  },

  ListAudits: {
    /**
     * Serializes Req.ListAudits to JSON.
     */
    encode: function (msg: PartialDeep<Req.ListAudits>): string {
      return JSON.stringify(ReqJSON.ListAudits._writeMessage(msg));
    },

    /**
     * Deserializes Req.ListAudits from JSON.
     */
    decode: function (json: string): Req.ListAudits {
      return ReqJSON.ListAudits._readMessage(
        ReqJSON.ListAudits.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.ListAudits with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Req.ListAudits>): Req.ListAudits {
      return {
        offset: protoscript.TimestampJSON.initialize(),
        limit: 0n,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.ListAudits>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.offset && msg.offset.seconds && msg.offset.nanos) {
        json["offset"] = protoscript.serializeTimestamp(msg.offset);
      }
      if (msg.limit) {
        json["limit"] = String(msg.limit);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.ListAudits, json: any): Req.ListAudits {
      const _offset_ = json["offset"];
      if (_offset_) {
        msg.offset = protoscript.parseTimestamp(_offset_);
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = BigInt(_limit_);
      }
      return msg;
    },
  },
};

export const RespJSON = {
  /**
   * Serializes Resp to JSON.
   */
  encode: function (_msg?: PartialDeep<Resp>): string {
    return "{}";
  },

  /**
   * Deserializes Resp from JSON.
   */
  decode: function (_json?: string): Resp {
    return {};
  },

  /**
   * Initializes Resp with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Resp>): Resp {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: PartialDeep<Resp>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Resp, _json: any): Resp {
    return msg;
  },

  ListAssets: {
    /**
     * Serializes Resp.ListAssets to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListAssets>): string {
      return JSON.stringify(RespJSON.ListAssets._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAssets from JSON.
     */
    decode: function (json: string): Resp.ListAssets {
      return RespJSON.ListAssets._readMessage(
        RespJSON.ListAssets.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListAssets with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListAssets>): Resp.ListAssets {
      return {
        assets: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAssets>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.assets?.length) {
        json["assets"] = msg.assets.map(AssetJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListAssets, json: any): Resp.ListAssets {
      const _assets_ = json["assets"];
      if (_assets_) {
        for (const item of _assets_) {
          const m = AssetJSON.initialize();
          AssetJSON._readMessage(m, item);
          msg.assets.push(m);
        }
      }
      return msg;
    },
  },

  ListOracles: {
    /**
     * Serializes Resp.ListOracles to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListOracles>): string {
      return JSON.stringify(RespJSON.ListOracles._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListOracles from JSON.
     */
    decode: function (json: string): Resp.ListOracles {
      return RespJSON.ListOracles._readMessage(
        RespJSON.ListOracles.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListOracles with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListOracles>): Resp.ListOracles {
      return {
        oracles: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListOracles>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oracles?.length) {
        json["oracles"] = msg.oracles.map(OracleJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListOracles,
      json: any,
    ): Resp.ListOracles {
      const _oracles_ = json["oracles"];
      if (_oracles_) {
        for (const item of _oracles_) {
          const m = OracleJSON.initialize();
          OracleJSON._readMessage(m, item);
          msg.oracles.push(m);
        }
      }
      return msg;
    },
  },

  ListCollaterals: {
    /**
     * Serializes Resp.ListCollaterals to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListCollaterals>): string {
      return JSON.stringify(RespJSON.ListCollaterals._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListCollaterals from JSON.
     */
    decode: function (json: string): Resp.ListCollaterals {
      return RespJSON.ListCollaterals._readMessage(
        RespJSON.ListCollaterals.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListCollaterals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListCollaterals>,
    ): Resp.ListCollaterals {
      return {
        collaterals: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListCollaterals>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.collaterals?.length) {
        json["collaterals"] = msg.collaterals.map(CollateralJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListCollaterals,
      json: any,
    ): Resp.ListCollaterals {
      const _collaterals_ = json["collaterals"];
      if (_collaterals_) {
        for (const item of _collaterals_) {
          const m = CollateralJSON.initialize();
          CollateralJSON._readMessage(m, item);
          msg.collaterals.push(m);
        }
      }
      return msg;
    },
  },

  ListVaults: {
    /**
     * Serializes Resp.ListVaults to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListVaults>): string {
      return JSON.stringify(RespJSON.ListVaults._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListVaults from JSON.
     */
    decode: function (json: string): Resp.ListVaults {
      return RespJSON.ListVaults._readMessage(
        RespJSON.ListVaults.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListVaults>): Resp.ListVaults {
      return {
        vaults: [],
        pagination: PaginationJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListVaults>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaults?.length) {
        json["vaults"] = msg.vaults.map(VaultJSON._writeMessage);
      }
      if (msg.pagination) {
        const _pagination_ = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(_pagination_).length > 0) {
          json["pagination"] = _pagination_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListVaults, json: any): Resp.ListVaults {
      const _vaults_ = json["vaults"];
      if (_vaults_) {
        for (const item of _vaults_) {
          const m = VaultJSON.initialize();
          VaultJSON._readMessage(m, item);
          msg.vaults.push(m);
        }
      }
      const _pagination_ = json["pagination"];
      if (_pagination_) {
        PaginationJSON._readMessage(msg.pagination, _pagination_);
      }
      return msg;
    },
  },

  ListMyVaults: {
    /**
     * Serializes Resp.ListMyVaults to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListMyVaults>): string {
      return JSON.stringify(RespJSON.ListMyVaults._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListMyVaults from JSON.
     */
    decode: function (json: string): Resp.ListMyVaults {
      return RespJSON.ListMyVaults._readMessage(
        RespJSON.ListMyVaults.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListMyVaults with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListMyVaults>): Resp.ListMyVaults {
      return {
        vaults: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListMyVaults>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.vaults?.length) {
        json["vaults"] = msg.vaults.map(VaultJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListMyVaults,
      json: any,
    ): Resp.ListMyVaults {
      const _vaults_ = json["vaults"];
      if (_vaults_) {
        for (const item of _vaults_) {
          const m = VaultJSON.initialize();
          VaultJSON._readMessage(m, item);
          msg.vaults.push(m);
        }
      }
      return msg;
    },
  },

  ListVaultEvents: {
    /**
     * Serializes Resp.ListVaultEvents to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListVaultEvents>): string {
      return JSON.stringify(RespJSON.ListVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListVaultEvents from JSON.
     */
    decode: function (json: string): Resp.ListVaultEvents {
      return RespJSON.ListVaultEvents._readMessage(
        RespJSON.ListVaultEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListVaultEvents>,
    ): Resp.ListVaultEvents {
      return {
        events: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListVaultEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json["events"] = msg.events.map(VaultJSON.Event._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListVaultEvents,
      json: any,
    ): Resp.ListVaultEvents {
      const _events_ = json["events"];
      if (_events_) {
        for (const item of _events_) {
          const m = VaultJSON.Event.initialize();
          VaultJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      return msg;
    },
  },

  QueryVaultEvents: {
    /**
     * Serializes Resp.QueryVaultEvents to JSON.
     */
    encode: function (msg: PartialDeep<Resp.QueryVaultEvents>): string {
      return JSON.stringify(RespJSON.QueryVaultEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.QueryVaultEvents from JSON.
     */
    decode: function (json: string): Resp.QueryVaultEvents {
      return RespJSON.QueryVaultEvents._readMessage(
        RespJSON.QueryVaultEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.QueryVaultEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.QueryVaultEvents>,
    ): Resp.QueryVaultEvents {
      return {
        events: [],
        pagination: PaginationJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.QueryVaultEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json["events"] = msg.events.map(VaultJSON.Event._writeMessage);
      }
      if (msg.pagination) {
        const _pagination_ = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(_pagination_).length > 0) {
          json["pagination"] = _pagination_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.QueryVaultEvents,
      json: any,
    ): Resp.QueryVaultEvents {
      const _events_ = json["events"];
      if (_events_) {
        for (const item of _events_) {
          const m = VaultJSON.Event.initialize();
          VaultJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      const _pagination_ = json["pagination"];
      if (_pagination_) {
        PaginationJSON._readMessage(msg.pagination, _pagination_);
      }
      return msg;
    },
  },

  ListFlips: {
    /**
     * Serializes Resp.ListFlips to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListFlips>): string {
      return JSON.stringify(RespJSON.ListFlips._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListFlips from JSON.
     */
    decode: function (json: string): Resp.ListFlips {
      return RespJSON.ListFlips._readMessage(
        RespJSON.ListFlips.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListFlips>): Resp.ListFlips {
      return {
        flips: [],
        pagination: PaginationJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListFlips>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flips?.length) {
        json["flips"] = msg.flips.map(FlipJSON._writeMessage);
      }
      if (msg.pagination) {
        const _pagination_ = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(_pagination_).length > 0) {
          json["pagination"] = _pagination_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListFlips, json: any): Resp.ListFlips {
      const _flips_ = json["flips"];
      if (_flips_) {
        for (const item of _flips_) {
          const m = FlipJSON.initialize();
          FlipJSON._readMessage(m, item);
          msg.flips.push(m);
        }
      }
      const _pagination_ = json["pagination"];
      if (_pagination_) {
        PaginationJSON._readMessage(msg.pagination, _pagination_);
      }
      return msg;
    },
  },

  QueryFlips: {
    /**
     * Serializes Resp.QueryFlips to JSON.
     */
    encode: function (msg: PartialDeep<Resp.QueryFlips>): string {
      return JSON.stringify(RespJSON.QueryFlips._writeMessage(msg));
    },

    /**
     * Deserializes Resp.QueryFlips from JSON.
     */
    decode: function (json: string): Resp.QueryFlips {
      return RespJSON.QueryFlips._readMessage(
        RespJSON.QueryFlips.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.QueryFlips with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.QueryFlips>): Resp.QueryFlips {
      return {
        flips: [],
        total: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.QueryFlips>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.flips?.length) {
        json["flips"] = msg.flips.map(FlipJSON._writeMessage);
      }
      if (msg.total) {
        json["total"] = msg.total;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.QueryFlips, json: any): Resp.QueryFlips {
      const _flips_ = json["flips"];
      if (_flips_) {
        for (const item of _flips_) {
          const m = FlipJSON.initialize();
          FlipJSON._readMessage(m, item);
          msg.flips.push(m);
        }
      }
      const _total_ = json["total"];
      if (_total_) {
        msg.total = protoscript.parseNumber(_total_);
      }
      return msg;
    },
  },

  ListFlipEvents: {
    /**
     * Serializes Resp.ListFlipEvents to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListFlipEvents>): string {
      return JSON.stringify(RespJSON.ListFlipEvents._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListFlipEvents from JSON.
     */
    decode: function (json: string): Resp.ListFlipEvents {
      return RespJSON.ListFlipEvents._readMessage(
        RespJSON.ListFlipEvents.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListFlipEvents with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListFlipEvents>,
    ): Resp.ListFlipEvents {
      return {
        events: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListFlipEvents>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.events?.length) {
        json["events"] = msg.events.map(FlipJSON.Event._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListFlipEvents,
      json: any,
    ): Resp.ListFlipEvents {
      const _events_ = json["events"];
      if (_events_) {
        for (const item of _events_) {
          const m = FlipJSON.Event.initialize();
          FlipJSON.Event._readMessage(m, item);
          msg.events.push(m);
        }
      }
      return msg;
    },
  },

  ListTransactions: {
    /**
     * Serializes Resp.ListTransactions to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListTransactions>): string {
      return JSON.stringify(RespJSON.ListTransactions._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListTransactions from JSON.
     */
    decode: function (json: string): Resp.ListTransactions {
      return RespJSON.ListTransactions._readMessage(
        RespJSON.ListTransactions.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListTransactions with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListTransactions>,
    ): Resp.ListTransactions {
      return {
        transactions: [],
        pagination: PaginationJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListTransactions>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.transactions?.length) {
        json["transactions"] = msg.transactions.map(
          TransactionJSON._writeMessage,
        );
      }
      if (msg.pagination) {
        const _pagination_ = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(_pagination_).length > 0) {
          json["pagination"] = _pagination_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListTransactions,
      json: any,
    ): Resp.ListTransactions {
      const _transactions_ = json["transactions"];
      if (_transactions_) {
        for (const item of _transactions_) {
          const m = TransactionJSON.initialize();
          TransactionJSON._readMessage(m, item);
          msg.transactions.push(m);
        }
      }
      const _pagination_ = json["pagination"];
      if (_pagination_) {
        PaginationJSON._readMessage(msg.pagination, _pagination_);
      }
      return msg;
    },
  },

  ListProposals: {
    /**
     * Serializes Resp.ListProposals to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListProposals>): string {
      return JSON.stringify(RespJSON.ListProposals._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListProposals from JSON.
     */
    decode: function (json: string): Resp.ListProposals {
      return RespJSON.ListProposals._readMessage(
        RespJSON.ListProposals.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListProposals with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListProposals>,
    ): Resp.ListProposals {
      return {
        proposals: [],
        pagination: PaginationJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListProposals>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.proposals?.length) {
        json["proposals"] = msg.proposals.map(ProposalJSON._writeMessage);
      }
      if (msg.pagination) {
        const _pagination_ = PaginationJSON._writeMessage(msg.pagination);
        if (Object.keys(_pagination_).length > 0) {
          json["pagination"] = _pagination_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListProposals,
      json: any,
    ): Resp.ListProposals {
      const _proposals_ = json["proposals"];
      if (_proposals_) {
        for (const item of _proposals_) {
          const m = ProposalJSON.initialize();
          ProposalJSON._readMessage(m, item);
          msg.proposals.push(m);
        }
      }
      const _pagination_ = json["pagination"];
      if (_pagination_) {
        PaginationJSON._readMessage(msg.pagination, _pagination_);
      }
      return msg;
    },
  },

  ListStats: {
    /**
     * Serializes Resp.ListStats to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListStats>): string {
      return JSON.stringify(RespJSON.ListStats._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListStats from JSON.
     */
    decode: function (json: string): Resp.ListStats {
      return RespJSON.ListStats._readMessage(
        RespJSON.ListStats.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListStats with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListStats>): Resp.ListStats {
      return {
        stats: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListStats>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.stats?.length) {
        json["stats"] = msg.stats.map(StatJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListStats, json: any): Resp.ListStats {
      const _stats_ = json["stats"];
      if (_stats_) {
        for (const item of _stats_) {
          const m = StatJSON.initialize();
          StatJSON._readMessage(m, item);
          msg.stats.push(m);
        }
      }
      return msg;
    },
  },

  ListAggregatedStats: {
    /**
     * Serializes Resp.ListAggregatedStats to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListAggregatedStats>): string {
      return JSON.stringify(RespJSON.ListAggregatedStats._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAggregatedStats from JSON.
     */
    decode: function (json: string): Resp.ListAggregatedStats {
      return RespJSON.ListAggregatedStats._readMessage(
        RespJSON.ListAggregatedStats.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListAggregatedStats with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<Resp.ListAggregatedStats>,
    ): Resp.ListAggregatedStats {
      return {
        stats: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAggregatedStats>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.stats?.length) {
        json["stats"] = msg.stats.map(AggregatedStatJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Resp.ListAggregatedStats,
      json: any,
    ): Resp.ListAggregatedStats {
      const _stats_ = json["stats"];
      if (_stats_) {
        for (const item of _stats_) {
          const m = AggregatedStatJSON.initialize();
          AggregatedStatJSON._readMessage(m, item);
          msg.stats.push(m);
        }
      }
      return msg;
    },
  },

  GetInfo: {
    /**
     * Serializes Resp.GetInfo to JSON.
     */
    encode: function (msg: PartialDeep<Resp.GetInfo>): string {
      return JSON.stringify(RespJSON.GetInfo._writeMessage(msg));
    },

    /**
     * Deserializes Resp.GetInfo from JSON.
     */
    decode: function (json: string): Resp.GetInfo {
      return RespJSON.GetInfo._readMessage(
        RespJSON.GetInfo.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.GetInfo with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.GetInfo>): Resp.GetInfo {
      return {
        oauthClientId: "",
        members: [],
        threshold: 0,
        publicKey: "",
        mode: 0,
        composeMode: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.GetInfo>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oauthClientId) {
        json["oauthClientId"] = msg.oauthClientId;
      }
      if (msg.members?.length) {
        json["members"] = msg.members;
      }
      if (msg.threshold) {
        json["threshold"] = msg.threshold;
      }
      if (msg.publicKey) {
        json["publicKey"] = msg.publicKey;
      }
      if (msg.mode) {
        json["mode"] = msg.mode;
      }
      if (msg.composeMode) {
        json["composeMode"] = msg.composeMode;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.GetInfo, json: any): Resp.GetInfo {
      const _oauthClientId_ = json["oauthClientId"] ?? json["oauth_client_id"];
      if (_oauthClientId_) {
        msg.oauthClientId = _oauthClientId_;
      }
      const _members_ = json["members"];
      if (_members_) {
        msg.members = _members_;
      }
      const _threshold_ = json["threshold"];
      if (_threshold_) {
        msg.threshold = protoscript.parseNumber(_threshold_);
      }
      const _publicKey_ = json["publicKey"] ?? json["public_key"];
      if (_publicKey_) {
        msg.publicKey = _publicKey_;
      }
      const _mode_ = json["mode"];
      if (_mode_) {
        msg.mode = protoscript.parseNumber(_mode_);
      }
      const _composeMode_ = json["composeMode"] ?? json["compose_mode"];
      if (_composeMode_) {
        msg.composeMode = protoscript.parseNumber(_composeMode_);
      }
      return msg;
    },
  },

  ListAudits: {
    /**
     * Serializes Resp.ListAudits to JSON.
     */
    encode: function (msg: PartialDeep<Resp.ListAudits>): string {
      return JSON.stringify(RespJSON.ListAudits._writeMessage(msg));
    },

    /**
     * Deserializes Resp.ListAudits from JSON.
     */
    decode: function (json: string): Resp.ListAudits {
      return RespJSON.ListAudits._readMessage(
        RespJSON.ListAudits.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Resp.ListAudits with all fields set to their default value.
     */
    initialize: function (msg?: Partial<Resp.ListAudits>): Resp.ListAudits {
      return {
        audits: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Resp.ListAudits>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.audits?.length) {
        json["audits"] = msg.audits.map(AuditJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Resp.ListAudits, json: any): Resp.ListAudits {
      const _audits_ = json["audits"];
      if (_audits_) {
        for (const item of _audits_) {
          const m = AuditJSON.initialize();
          AuditJSON._readMessage(m, item);
          msg.audits.push(m);
        }
      }
      return msg;
    },
  },
};
