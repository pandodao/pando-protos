// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: tradinglab/v1/tradinglab.proto
/* eslint-disable */

import type { ByteSource, ClientConfiguration } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import { Timestamp, TimestampJSON } from "../../google/protobuf/timestamp.pb";

//========================================//
//   TradingLabService Protobuf Client    //
//========================================//

export async function PreOrder(
  preOrderRequest: PreOrderRequest,
  config?: ClientConfiguration
): Promise<PreOrderResponse> {
  const response = await PBrequest(
    "/tradinglab.v1.TradingLabService/PreOrder",
    PreOrderRequest.encode(preOrderRequest),
    config
  );
  return PreOrderResponse.decode(response);
}

export async function CancelOrder(
  cancelOrderRequest: CancelOrderRequest,
  config?: ClientConfiguration
): Promise<CancelOrderResponse> {
  const response = await PBrequest(
    "/tradinglab.v1.TradingLabService/CancelOrder",
    CancelOrderRequest.encode(cancelOrderRequest),
    config
  );
  return CancelOrderResponse.decode(response);
}

export async function GetOrder(
  getOrderRequest: GetOrderRequest,
  config?: ClientConfiguration
): Promise<GetOrderResponse> {
  const response = await PBrequest(
    "/tradinglab.v1.TradingLabService/GetOrder",
    GetOrderRequest.encode(getOrderRequest),
    config
  );
  return GetOrderResponse.decode(response);
}

export async function ListOrders(
  listOrdersRequest: ListOrdersRequest,
  config?: ClientConfiguration
): Promise<ListOrdersResponse> {
  const response = await PBrequest(
    "/tradinglab.v1.TradingLabService/ListOrders",
    ListOrdersRequest.encode(listOrdersRequest),
    config
  );
  return ListOrdersResponse.decode(response);
}

//========================================//
//     TradingLabService JSON Client      //
//========================================//

export async function PreOrderJSON(
  preOrderRequest: PreOrderRequest,
  config?: ClientConfiguration
): Promise<PreOrderResponse> {
  const response = await JSONrequest(
    "/tradinglab.v1.TradingLabService/PreOrder",
    PreOrderRequestJSON.encode(preOrderRequest),
    config
  );
  return PreOrderResponseJSON.decode(response);
}

export async function CancelOrderJSON(
  cancelOrderRequest: CancelOrderRequest,
  config?: ClientConfiguration
): Promise<CancelOrderResponse> {
  const response = await JSONrequest(
    "/tradinglab.v1.TradingLabService/CancelOrder",
    CancelOrderRequestJSON.encode(cancelOrderRequest),
    config
  );
  return CancelOrderResponseJSON.decode(response);
}

export async function GetOrderJSON(
  getOrderRequest: GetOrderRequest,
  config?: ClientConfiguration
): Promise<GetOrderResponse> {
  const response = await JSONrequest(
    "/tradinglab.v1.TradingLabService/GetOrder",
    GetOrderRequestJSON.encode(getOrderRequest),
    config
  );
  return GetOrderResponseJSON.decode(response);
}

export async function ListOrdersJSON(
  listOrdersRequest: ListOrdersRequest,
  config?: ClientConfiguration
): Promise<ListOrdersResponse> {
  const response = await JSONrequest(
    "/tradinglab.v1.TradingLabService/ListOrders",
    ListOrdersRequestJSON.encode(listOrdersRequest),
    config
  );
  return ListOrdersResponseJSON.decode(response);
}

//========================================//
//           TradingLabService            //
//========================================//

export interface TradingLabService<Context = unknown> {
  PreOrder: (
    preOrderRequest: PreOrderRequest,
    context: Context
  ) => Promise<PreOrderResponse> | PreOrderResponse;
  CancelOrder: (
    cancelOrderRequest: CancelOrderRequest,
    context: Context
  ) => Promise<CancelOrderResponse> | CancelOrderResponse;
  GetOrder: (
    getOrderRequest: GetOrderRequest,
    context: Context
  ) => Promise<GetOrderResponse> | GetOrderResponse;
  ListOrders: (
    listOrdersRequest: ListOrdersRequest,
    context: Context
  ) => Promise<ListOrdersResponse> | ListOrdersResponse;
}

export function createTradingLabService<Context>(
  service: TradingLabService<Context>
) {
  return {
    name: "tradinglab.v1.TradingLabService",
    methods: {
      PreOrder: {
        name: "PreOrder",
        handler: service.PreOrder,
        input: { protobuf: PreOrderRequest, json: PreOrderRequestJSON },
        output: { protobuf: PreOrderResponse, json: PreOrderResponseJSON },
      },
      CancelOrder: {
        name: "CancelOrder",
        handler: service.CancelOrder,
        input: { protobuf: CancelOrderRequest, json: CancelOrderRequestJSON },
        output: {
          protobuf: CancelOrderResponse,
          json: CancelOrderResponseJSON,
        },
      },
      GetOrder: {
        name: "GetOrder",
        handler: service.GetOrder,
        input: { protobuf: GetOrderRequest, json: GetOrderRequestJSON },
        output: { protobuf: GetOrderResponse, json: GetOrderResponseJSON },
      },
      ListOrders: {
        name: "ListOrders",
        handler: service.ListOrders,
        input: { protobuf: ListOrdersRequest, json: ListOrdersRequestJSON },
        output: { protobuf: ListOrdersResponse, json: ListOrdersResponseJSON },
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Asset {
  id: string;
  symbol: string;
  name: string;
  logo: string;
}

export interface Order {
  id: string;
  createdAt: Timestamp;
  expiredAt: Timestamp;
  cancelledAt: Timestamp;
  userId: string;
  type: Order.Type;
  state: Order.State;
  payAssetId: string;
  payAsset: Asset;
  fillAssetId: string;
  fillAsset: Asset;
  funds: string;
  expects: string;
  filledFunds: string;
  filledAmount: string;
}

export declare namespace Order {
  export type Type = "TYPE_NOT_SET" | "LIMIT" | "AGG_SWAP";

  export type State =
    | "STATE_NOT_SET"
    | "PENDING"
    | "DONE"
    | "REJECT"
    | "CANCELLED"
    | "EXPIRED";
}

export interface Trade {
  id: string;
  createdAt: Timestamp;
  exchange: string;
  orderId: string;
  state: Trade.State;
  payAssetId: string;
  payAsset: Asset;
  fillAssetId: string;
  fillAsset: Asset;
  funds: string;
  expects: string;
  filledFunds: string;
  filledAmount: string;
  binance?: Trade.BinanceExtra | null | undefined;
  fswap?: Trade.FswapExtra | null | undefined;
}

export declare namespace Trade {
  export type State = "STATE_NOT_SET" | "PENDING" | "TRADING" | "DONE";

  export interface BinanceExtra {
    symbol: string;
    side: string;
  }

  export interface FswapExtra {
    routes: Trade.FswapExtra.Path[];
  }

  namespace FswapExtra {
    export interface Path {
      amount: string;
      share: string;
      pairs: number[];
      assets: Asset[];
    }
  }
}

export interface Transfer {
  traceId: string;
  assetId: string;
  amount: string;
  memo: string;
  opponents: string[];
  threshold: number;
  url: string;
}

export interface PreOrderRequest {
  type: Order.Type;
  payAssetId: string;
  fillAssetId: string;
  funds: string;
  exchange: string;
}

export interface PreOrderResponse {
  order: Order;
  trades: Trade[];
  transfer: Transfer;
}

export interface CancelOrderRequest {
  id: string;
}

export interface CancelOrderResponse {
  order: Order;
}

export interface GetOrderRequest {
  id: string;
}

export interface GetOrderResponse {
  order: Order;
  trades: Trade[];
}

export interface ListOrdersRequest {
  type: Order.Type;
  state: Order.State;
  cursor: string;
  limit: number;
}

export interface ListOrdersResponse {
  orders: Order[];
  nextCursor: string;
  hasNext: boolean;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Asset = {
  /**
   * Serializes Asset to protobuf.
   */
  encode: function (msg: Partial<Asset>): Uint8Array {
    return Asset._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Asset from protobuf.
   */
  decode: function (bytes: ByteSource): Asset {
    return Asset._readMessage(Asset.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (): Asset {
    return {
      id: "",
      symbol: "",
      name: "",
      logo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Asset>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.symbol) {
      writer.writeString(2, msg.symbol);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.logo) {
      writer.writeString(4, msg.logo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, reader: BinaryReader): Asset {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.symbol = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.logo = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Order = {
  /**
   * Serializes Order to protobuf.
   */
  encode: function (msg: Partial<Order>): Uint8Array {
    return Order._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Order from protobuf.
   */
  decode: function (bytes: ByteSource): Order {
    return Order._readMessage(Order.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (): Order {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      expiredAt: Timestamp.initialize(),
      cancelledAt: Timestamp.initialize(),
      userId: "",
      type: Order.Type._fromInt(0),
      state: Order.State._fromInt(0),
      payAssetId: "",
      payAsset: Asset.initialize(),
      fillAssetId: "",
      fillAsset: Asset.initialize(),
      funds: "",
      expects: "",
      filledFunds: "",
      filledAmount: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Order>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.expiredAt) {
      writer.writeMessage(3, msg.expiredAt, Timestamp._writeMessage);
    }
    if (msg.cancelledAt) {
      writer.writeMessage(4, msg.cancelledAt, Timestamp._writeMessage);
    }
    if (msg.userId) {
      writer.writeString(5, msg.userId);
    }
    if (msg.type && Order.Type._toInt(msg.type)) {
      writer.writeEnum(6, Order.Type._toInt(msg.type));
    }
    if (msg.state && Order.State._toInt(msg.state)) {
      writer.writeEnum(7, Order.State._toInt(msg.state));
    }
    if (msg.payAssetId) {
      writer.writeString(8, msg.payAssetId);
    }
    if (msg.payAsset) {
      writer.writeMessage(9, msg.payAsset, Asset._writeMessage);
    }
    if (msg.fillAssetId) {
      writer.writeString(10, msg.fillAssetId);
    }
    if (msg.fillAsset) {
      writer.writeMessage(11, msg.fillAsset, Asset._writeMessage);
    }
    if (msg.funds) {
      writer.writeString(12, msg.funds);
    }
    if (msg.expects) {
      writer.writeString(13, msg.expects);
    }
    if (msg.filledFunds) {
      writer.writeString(14, msg.filledFunds);
    }
    if (msg.filledAmount) {
      writer.writeString(15, msg.filledAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, reader: BinaryReader): Order {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.expiredAt, Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.cancelledAt, Timestamp._readMessage);
          break;
        }
        case 5: {
          msg.userId = reader.readString();
          break;
        }
        case 6: {
          msg.type = Order.Type._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.state = Order.State._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.payAsset, Asset._readMessage);
          break;
        }
        case 10: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 11: {
          reader.readMessage(msg.fillAsset, Asset._readMessage);
          break;
        }
        case 12: {
          msg.funds = reader.readString();
          break;
        }
        case 13: {
          msg.expects = reader.readString();
          break;
        }
        case 14: {
          msg.filledFunds = reader.readString();
          break;
        }
        case 15: {
          msg.filledAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Type: {
    TYPE_NOT_SET: "TYPE_NOT_SET",
    LIMIT: "LIMIT",
    AGG_SWAP: "AGG_SWAP",
    /**
     * @private
     */
    _fromInt: function (i: number): Order.Type {
      switch (i) {
        case 0: {
          return "TYPE_NOT_SET";
        }
        case 1: {
          return "LIMIT";
        }
        case 2: {
          return "AGG_SWAP";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Order.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Order.Type): number {
      switch (i) {
        case "TYPE_NOT_SET": {
          return 0;
        }
        case "LIMIT": {
          return 1;
        }
        case "AGG_SWAP": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  State: {
    STATE_NOT_SET: "STATE_NOT_SET",
    PENDING: "PENDING",
    DONE: "DONE",
    REJECT: "REJECT",
    CANCELLED: "CANCELLED",
    EXPIRED: "EXPIRED",
    /**
     * @private
     */
    _fromInt: function (i: number): Order.State {
      switch (i) {
        case 0: {
          return "STATE_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "DONE";
        }
        case 3: {
          return "REJECT";
        }
        case 4: {
          return "CANCELLED";
        }
        case 5: {
          return "EXPIRED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Order.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Order.State): number {
      switch (i) {
        case "STATE_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "DONE": {
          return 2;
        }
        case "REJECT": {
          return 3;
        }
        case "CANCELLED": {
          return 4;
        }
        case "EXPIRED": {
          return 5;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Trade = {
  /**
   * Serializes Trade to protobuf.
   */
  encode: function (msg: Partial<Trade>): Uint8Array {
    return Trade._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Trade from protobuf.
   */
  decode: function (bytes: ByteSource): Trade {
    return Trade._readMessage(Trade.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Trade with all fields set to their default value.
   */
  initialize: function (): Trade {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      exchange: "",
      orderId: "",
      state: Trade.State._fromInt(0),
      payAssetId: "",
      payAsset: Asset.initialize(),
      fillAssetId: "",
      fillAsset: Asset.initialize(),
      funds: "",
      expects: "",
      filledFunds: "",
      filledAmount: "",
      binance: undefined,
      fswap: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Trade>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(2, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.exchange) {
      writer.writeString(3, msg.exchange);
    }
    if (msg.orderId) {
      writer.writeString(4, msg.orderId);
    }
    if (msg.state && Trade.State._toInt(msg.state)) {
      writer.writeEnum(5, Trade.State._toInt(msg.state));
    }
    if (msg.payAssetId) {
      writer.writeString(6, msg.payAssetId);
    }
    if (msg.payAsset) {
      writer.writeMessage(7, msg.payAsset, Asset._writeMessage);
    }
    if (msg.fillAssetId) {
      writer.writeString(8, msg.fillAssetId);
    }
    if (msg.fillAsset) {
      writer.writeMessage(9, msg.fillAsset, Asset._writeMessage);
    }
    if (msg.funds) {
      writer.writeString(10, msg.funds);
    }
    if (msg.expects) {
      writer.writeString(11, msg.expects);
    }
    if (msg.filledFunds) {
      writer.writeString(12, msg.filledFunds);
    }
    if (msg.filledAmount) {
      writer.writeString(13, msg.filledAmount);
    }
    if (msg.binance != undefined) {
      writer.writeMessage(14, msg.binance, Trade.BinanceExtra._writeMessage);
    }
    if (msg.fswap != undefined) {
      writer.writeMessage(15, msg.fswap, Trade.FswapExtra._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Trade, reader: BinaryReader): Trade {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.exchange = reader.readString();
          break;
        }
        case 4: {
          msg.orderId = reader.readString();
          break;
        }
        case 5: {
          msg.state = Trade.State._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 7: {
          reader.readMessage(msg.payAsset, Asset._readMessage);
          break;
        }
        case 8: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.fillAsset, Asset._readMessage);
          break;
        }
        case 10: {
          msg.funds = reader.readString();
          break;
        }
        case 11: {
          msg.expects = reader.readString();
          break;
        }
        case 12: {
          msg.filledFunds = reader.readString();
          break;
        }
        case 13: {
          msg.filledAmount = reader.readString();
          break;
        }
        case 14: {
          msg.binance = Trade.BinanceExtra.initialize();
          reader.readMessage(msg.binance, Trade.BinanceExtra._readMessage);
          break;
        }
        case 15: {
          msg.fswap = Trade.FswapExtra.initialize();
          reader.readMessage(msg.fswap, Trade.FswapExtra._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  State: {
    STATE_NOT_SET: "STATE_NOT_SET",
    PENDING: "PENDING",
    TRADING: "TRADING",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Trade.State {
      switch (i) {
        case 0: {
          return "STATE_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "TRADING";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Trade.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Trade.State): number {
      switch (i) {
        case "STATE_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "TRADING": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  BinanceExtra: {
    /**
     * Serializes Trade.BinanceExtra to protobuf.
     */
    encode: function (msg: Partial<Trade.BinanceExtra>): Uint8Array {
      return Trade.BinanceExtra._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Trade.BinanceExtra from protobuf.
     */
    decode: function (bytes: ByteSource): Trade.BinanceExtra {
      return Trade.BinanceExtra._readMessage(
        Trade.BinanceExtra.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Trade.BinanceExtra with all fields set to their default value.
     */
    initialize: function (): Trade.BinanceExtra {
      return {
        symbol: "",
        side: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Trade.BinanceExtra>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.symbol) {
        writer.writeString(1, msg.symbol);
      }
      if (msg.side) {
        writer.writeString(2, msg.side);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Trade.BinanceExtra,
      reader: BinaryReader
    ): Trade.BinanceExtra {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.symbol = reader.readString();
            break;
          }
          case 2: {
            msg.side = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FswapExtra: {
    /**
     * Serializes Trade.FswapExtra to protobuf.
     */
    encode: function (msg: Partial<Trade.FswapExtra>): Uint8Array {
      return Trade.FswapExtra._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Trade.FswapExtra from protobuf.
     */
    decode: function (bytes: ByteSource): Trade.FswapExtra {
      return Trade.FswapExtra._readMessage(
        Trade.FswapExtra.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Trade.FswapExtra with all fields set to their default value.
     */
    initialize: function (): Trade.FswapExtra {
      return {
        routes: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Trade.FswapExtra>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.routes?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.routes as any,
          Trade.FswapExtra.Path._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Trade.FswapExtra,
      reader: BinaryReader
    ): Trade.FswapExtra {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Trade.FswapExtra.Path.initialize();
            reader.readMessage(m, Trade.FswapExtra.Path._readMessage);
            msg.routes.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Path: {
      /**
       * Serializes Trade.FswapExtra.Path to protobuf.
       */
      encode: function (msg: Partial<Trade.FswapExtra.Path>): Uint8Array {
        return Trade.FswapExtra.Path._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes Trade.FswapExtra.Path from protobuf.
       */
      decode: function (bytes: ByteSource): Trade.FswapExtra.Path {
        return Trade.FswapExtra.Path._readMessage(
          Trade.FswapExtra.Path.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes Trade.FswapExtra.Path with all fields set to their default value.
       */
      initialize: function (): Trade.FswapExtra.Path {
        return {
          amount: "",
          share: "",
          pairs: [],
          assets: [],
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<Trade.FswapExtra.Path>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.amount) {
          writer.writeString(1, msg.amount);
        }
        if (msg.share) {
          writer.writeString(2, msg.share);
        }
        if (msg.pairs?.length) {
          writer.writePackedInt32(3, msg.pairs);
        }
        if (msg.assets?.length) {
          writer.writeRepeatedMessage(
            4,
            msg.assets as any,
            Asset._writeMessage
          );
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: Trade.FswapExtra.Path,
        reader: BinaryReader
      ): Trade.FswapExtra.Path {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.amount = reader.readString();
              break;
            }
            case 2: {
              msg.share = reader.readString();
              break;
            }
            case 3: {
              if (reader.isDelimited()) {
                msg.pairs.push(...reader.readPackedInt32());
              } else {
                msg.pairs.push(reader.readInt32());
              }
              break;
            }
            case 4: {
              const m = Asset.initialize();
              reader.readMessage(m, Asset._readMessage);
              msg.assets.push(m);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: Partial<Transfer>): Uint8Array {
    return Transfer._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      memo: "",
      opponents: [],
      threshold: 0,
      url: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Transfer>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.traceId) {
      writer.writeString(1, msg.traceId);
    }
    if (msg.assetId) {
      writer.writeString(2, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(3, msg.amount);
    }
    if (msg.memo) {
      writer.writeString(4, msg.memo);
    }
    if (msg.opponents?.length) {
      writer.writeRepeatedString(5, msg.opponents);
    }
    if (msg.threshold) {
      writer.writeUint32(6, msg.threshold);
    }
    if (msg.url) {
      writer.writeString(7, msg.url);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, reader: BinaryReader): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.traceId = reader.readString();
          break;
        }
        case 2: {
          msg.assetId = reader.readString();
          break;
        }
        case 3: {
          msg.amount = reader.readString();
          break;
        }
        case 4: {
          msg.memo = reader.readString();
          break;
        }
        case 5: {
          msg.opponents.push(reader.readString());
          break;
        }
        case 6: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 7: {
          msg.url = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PreOrderRequest = {
  /**
   * Serializes PreOrderRequest to protobuf.
   */
  encode: function (msg: Partial<PreOrderRequest>): Uint8Array {
    return PreOrderRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PreOrderRequest from protobuf.
   */
  decode: function (bytes: ByteSource): PreOrderRequest {
    return PreOrderRequest._readMessage(
      PreOrderRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PreOrderRequest with all fields set to their default value.
   */
  initialize: function (): PreOrderRequest {
    return {
      type: Order.Type._fromInt(0),
      payAssetId: "",
      fillAssetId: "",
      funds: "",
      exchange: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreOrderRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.type && Order.Type._toInt(msg.type)) {
      writer.writeEnum(1, Order.Type._toInt(msg.type));
    }
    if (msg.payAssetId) {
      writer.writeString(2, msg.payAssetId);
    }
    if (msg.fillAssetId) {
      writer.writeString(3, msg.fillAssetId);
    }
    if (msg.funds) {
      writer.writeString(4, msg.funds);
    }
    if (msg.exchange) {
      writer.writeString(5, msg.exchange);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PreOrderRequest,
    reader: BinaryReader
  ): PreOrderRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.type = Order.Type._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.payAssetId = reader.readString();
          break;
        }
        case 3: {
          msg.fillAssetId = reader.readString();
          break;
        }
        case 4: {
          msg.funds = reader.readString();
          break;
        }
        case 5: {
          msg.exchange = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PreOrderResponse = {
  /**
   * Serializes PreOrderResponse to protobuf.
   */
  encode: function (msg: Partial<PreOrderResponse>): Uint8Array {
    return PreOrderResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PreOrderResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PreOrderResponse {
    return PreOrderResponse._readMessage(
      PreOrderResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PreOrderResponse with all fields set to their default value.
   */
  initialize: function (): PreOrderResponse {
    return {
      order: Order.initialize(),
      trades: [],
      transfer: Transfer.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreOrderResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.order) {
      writer.writeMessage(1, msg.order, Order._writeMessage);
    }
    if (msg.trades?.length) {
      writer.writeRepeatedMessage(2, msg.trades as any, Trade._writeMessage);
    }
    if (msg.transfer) {
      writer.writeMessage(3, msg.transfer, Transfer._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PreOrderResponse,
    reader: BinaryReader
  ): PreOrderResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.order, Order._readMessage);
          break;
        }
        case 2: {
          const m = Trade.initialize();
          reader.readMessage(m, Trade._readMessage);
          msg.trades.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.transfer, Transfer._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelOrderRequest = {
  /**
   * Serializes CancelOrderRequest to protobuf.
   */
  encode: function (msg: Partial<CancelOrderRequest>): Uint8Array {
    return CancelOrderRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelOrderRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CancelOrderRequest {
    return CancelOrderRequest._readMessage(
      CancelOrderRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes CancelOrderRequest with all fields set to their default value.
   */
  initialize: function (): CancelOrderRequest {
    return {
      id: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CancelOrderRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelOrderRequest,
    reader: BinaryReader
  ): CancelOrderRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelOrderResponse = {
  /**
   * Serializes CancelOrderResponse to protobuf.
   */
  encode: function (msg: Partial<CancelOrderResponse>): Uint8Array {
    return CancelOrderResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelOrderResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CancelOrderResponse {
    return CancelOrderResponse._readMessage(
      CancelOrderResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes CancelOrderResponse with all fields set to their default value.
   */
  initialize: function (): CancelOrderResponse {
    return {
      order: Order.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CancelOrderResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.order) {
      writer.writeMessage(1, msg.order, Order._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelOrderResponse,
    reader: BinaryReader
  ): CancelOrderResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.order, Order._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetOrderRequest = {
  /**
   * Serializes GetOrderRequest to protobuf.
   */
  encode: function (msg: Partial<GetOrderRequest>): Uint8Array {
    return GetOrderRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetOrderRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetOrderRequest {
    return GetOrderRequest._readMessage(
      GetOrderRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetOrderRequest with all fields set to their default value.
   */
  initialize: function (): GetOrderRequest {
    return {
      id: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetOrderRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetOrderRequest,
    reader: BinaryReader
  ): GetOrderRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetOrderResponse = {
  /**
   * Serializes GetOrderResponse to protobuf.
   */
  encode: function (msg: Partial<GetOrderResponse>): Uint8Array {
    return GetOrderResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetOrderResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetOrderResponse {
    return GetOrderResponse._readMessage(
      GetOrderResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetOrderResponse with all fields set to their default value.
   */
  initialize: function (): GetOrderResponse {
    return {
      order: Order.initialize(),
      trades: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetOrderResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.order) {
      writer.writeMessage(1, msg.order, Order._writeMessage);
    }
    if (msg.trades?.length) {
      writer.writeRepeatedMessage(2, msg.trades as any, Trade._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetOrderResponse,
    reader: BinaryReader
  ): GetOrderResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.order, Order._readMessage);
          break;
        }
        case 2: {
          const m = Trade.initialize();
          reader.readMessage(m, Trade._readMessage);
          msg.trades.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListOrdersRequest = {
  /**
   * Serializes ListOrdersRequest to protobuf.
   */
  encode: function (msg: Partial<ListOrdersRequest>): Uint8Array {
    return ListOrdersRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ListOrdersRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListOrdersRequest {
    return ListOrdersRequest._readMessage(
      ListOrdersRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ListOrdersRequest with all fields set to their default value.
   */
  initialize: function (): ListOrdersRequest {
    return {
      type: Order.Type._fromInt(0),
      state: Order.State._fromInt(0),
      cursor: "",
      limit: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListOrdersRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.type && Order.Type._toInt(msg.type)) {
      writer.writeEnum(1, Order.Type._toInt(msg.type));
    }
    if (msg.state && Order.State._toInt(msg.state)) {
      writer.writeEnum(2, Order.State._toInt(msg.state));
    }
    if (msg.cursor) {
      writer.writeString(3, msg.cursor);
    }
    if (msg.limit) {
      writer.writeInt32(4, msg.limit);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListOrdersRequest,
    reader: BinaryReader
  ): ListOrdersRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.type = Order.Type._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.state = Order.State._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.cursor = reader.readString();
          break;
        }
        case 4: {
          msg.limit = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListOrdersResponse = {
  /**
   * Serializes ListOrdersResponse to protobuf.
   */
  encode: function (msg: Partial<ListOrdersResponse>): Uint8Array {
    return ListOrdersResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ListOrdersResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListOrdersResponse {
    return ListOrdersResponse._readMessage(
      ListOrdersResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ListOrdersResponse with all fields set to their default value.
   */
  initialize: function (): ListOrdersResponse {
    return {
      orders: [],
      nextCursor: "",
      hasNext: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListOrdersResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.orders?.length) {
      writer.writeRepeatedMessage(1, msg.orders as any, Order._writeMessage);
    }
    if (msg.nextCursor) {
      writer.writeString(2, msg.nextCursor);
    }
    if (msg.hasNext) {
      writer.writeBool(3, msg.hasNext);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListOrdersResponse,
    reader: BinaryReader
  ): ListOrdersResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Order.initialize();
          reader.readMessage(m, Order._readMessage);
          msg.orders.push(m);
          break;
        }
        case 2: {
          msg.nextCursor = reader.readString();
          break;
        }
        case 3: {
          msg.hasNext = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const AssetJSON = {
  /**
   * Serializes Asset to JSON.
   */
  encode: function (msg: Partial<Asset>): string {
    return JSON.stringify(AssetJSON._writeMessage(msg));
  },

  /**
   * Deserializes Asset from JSON.
   */
  decode: function (json: string): Asset {
    return AssetJSON._readMessage(AssetJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (): Asset {
    return {
      id: "",
      symbol: "",
      name: "",
      logo: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Asset>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.symbol) {
      json.symbol = msg.symbol;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.logo) {
      json.logo = msg.logo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, json: any): Asset {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _symbol = json.symbol;
    if (_symbol) {
      msg.symbol = _symbol;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _logo = json.logo;
    if (_logo) {
      msg.logo = _logo;
    }
    return msg;
  },
};

export const OrderJSON = {
  /**
   * Serializes Order to JSON.
   */
  encode: function (msg: Partial<Order>): string {
    return JSON.stringify(OrderJSON._writeMessage(msg));
  },

  /**
   * Deserializes Order from JSON.
   */
  decode: function (json: string): Order {
    return OrderJSON._readMessage(OrderJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Order with all fields set to their default value.
   */
  initialize: function (): Order {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      expiredAt: Timestamp.initialize(),
      cancelledAt: Timestamp.initialize(),
      userId: "",
      type: Order.Type._fromInt(0),
      state: Order.State._fromInt(0),
      payAssetId: "",
      payAsset: Asset.initialize(),
      fillAssetId: "",
      fillAsset: Asset.initialize(),
      funds: "",
      expects: "",
      filledFunds: "",
      filledAmount: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Order>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.expiredAt) {
      const expiredAt = TimestampJSON._writeMessage(msg.expiredAt);
      if (Object.keys(expiredAt).length > 0) {
        json.expiredAt = expiredAt;
      }
    }
    if (msg.cancelledAt) {
      const cancelledAt = TimestampJSON._writeMessage(msg.cancelledAt);
      if (Object.keys(cancelledAt).length > 0) {
        json.cancelledAt = cancelledAt;
      }
    }
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.type && OrderJSON.Type._toInt(msg.type)) {
      json.type = msg.type;
    }
    if (msg.state && OrderJSON.State._toInt(msg.state)) {
      json.state = msg.state;
    }
    if (msg.payAssetId) {
      json.payAssetId = msg.payAssetId;
    }
    if (msg.payAsset) {
      const payAsset = AssetJSON._writeMessage(msg.payAsset);
      if (Object.keys(payAsset).length > 0) {
        json.payAsset = payAsset;
      }
    }
    if (msg.fillAssetId) {
      json.fillAssetId = msg.fillAssetId;
    }
    if (msg.fillAsset) {
      const fillAsset = AssetJSON._writeMessage(msg.fillAsset);
      if (Object.keys(fillAsset).length > 0) {
        json.fillAsset = fillAsset;
      }
    }
    if (msg.funds) {
      json.funds = msg.funds;
    }
    if (msg.expects) {
      json.expects = msg.expects;
    }
    if (msg.filledFunds) {
      json.filledFunds = msg.filledFunds;
    }
    if (msg.filledAmount) {
      json.filledAmount = msg.filledAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Order, json: any): Order {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _expiredAt = json.expiredAt ?? json.expired_at;
    if (_expiredAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _expiredAt);
      msg.expiredAt = m;
    }
    const _cancelledAt = json.cancelledAt ?? json.cancelled_at;
    if (_cancelledAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _cancelledAt);
      msg.cancelledAt = m;
    }
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _state = json.state;
    if (_state) {
      msg.state = _state;
    }
    const _payAssetId = json.payAssetId ?? json.pay_asset_id;
    if (_payAssetId) {
      msg.payAssetId = _payAssetId;
    }
    const _payAsset = json.payAsset ?? json.pay_asset;
    if (_payAsset) {
      const m = Asset.initialize();
      AssetJSON._readMessage(m, _payAsset);
      msg.payAsset = m;
    }
    const _fillAssetId = json.fillAssetId ?? json.fill_asset_id;
    if (_fillAssetId) {
      msg.fillAssetId = _fillAssetId;
    }
    const _fillAsset = json.fillAsset ?? json.fill_asset;
    if (_fillAsset) {
      const m = Asset.initialize();
      AssetJSON._readMessage(m, _fillAsset);
      msg.fillAsset = m;
    }
    const _funds = json.funds;
    if (_funds) {
      msg.funds = _funds;
    }
    const _expects = json.expects;
    if (_expects) {
      msg.expects = _expects;
    }
    const _filledFunds = json.filledFunds ?? json.filled_funds;
    if (_filledFunds) {
      msg.filledFunds = _filledFunds;
    }
    const _filledAmount = json.filledAmount ?? json.filled_amount;
    if (_filledAmount) {
      msg.filledAmount = _filledAmount;
    }
    return msg;
  },

  Type: {
    TYPE_NOT_SET: "TYPE_NOT_SET",
    LIMIT: "LIMIT",
    AGG_SWAP: "AGG_SWAP",
    /**
     * @private
     */
    _fromInt: function (i: number): Order.Type {
      switch (i) {
        case 0: {
          return "TYPE_NOT_SET";
        }
        case 1: {
          return "LIMIT";
        }
        case 2: {
          return "AGG_SWAP";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Order.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Order.Type): number {
      switch (i) {
        case "TYPE_NOT_SET": {
          return 0;
        }
        case "LIMIT": {
          return 1;
        }
        case "AGG_SWAP": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  State: {
    STATE_NOT_SET: "STATE_NOT_SET",
    PENDING: "PENDING",
    DONE: "DONE",
    REJECT: "REJECT",
    CANCELLED: "CANCELLED",
    EXPIRED: "EXPIRED",
    /**
     * @private
     */
    _fromInt: function (i: number): Order.State {
      switch (i) {
        case 0: {
          return "STATE_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "DONE";
        }
        case 3: {
          return "REJECT";
        }
        case 4: {
          return "CANCELLED";
        }
        case 5: {
          return "EXPIRED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Order.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Order.State): number {
      switch (i) {
        case "STATE_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "DONE": {
          return 2;
        }
        case "REJECT": {
          return 3;
        }
        case "CANCELLED": {
          return 4;
        }
        case "EXPIRED": {
          return 5;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const TradeJSON = {
  /**
   * Serializes Trade to JSON.
   */
  encode: function (msg: Partial<Trade>): string {
    return JSON.stringify(TradeJSON._writeMessage(msg));
  },

  /**
   * Deserializes Trade from JSON.
   */
  decode: function (json: string): Trade {
    return TradeJSON._readMessage(TradeJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Trade with all fields set to their default value.
   */
  initialize: function (): Trade {
    return {
      id: "",
      createdAt: Timestamp.initialize(),
      exchange: "",
      orderId: "",
      state: Trade.State._fromInt(0),
      payAssetId: "",
      payAsset: Asset.initialize(),
      fillAssetId: "",
      fillAsset: Asset.initialize(),
      funds: "",
      expects: "",
      filledFunds: "",
      filledAmount: "",
      binance: undefined,
      fswap: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Trade>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.exchange) {
      json.exchange = msg.exchange;
    }
    if (msg.orderId) {
      json.orderId = msg.orderId;
    }
    if (msg.state && TradeJSON.State._toInt(msg.state)) {
      json.state = msg.state;
    }
    if (msg.payAssetId) {
      json.payAssetId = msg.payAssetId;
    }
    if (msg.payAsset) {
      const payAsset = AssetJSON._writeMessage(msg.payAsset);
      if (Object.keys(payAsset).length > 0) {
        json.payAsset = payAsset;
      }
    }
    if (msg.fillAssetId) {
      json.fillAssetId = msg.fillAssetId;
    }
    if (msg.fillAsset) {
      const fillAsset = AssetJSON._writeMessage(msg.fillAsset);
      if (Object.keys(fillAsset).length > 0) {
        json.fillAsset = fillAsset;
      }
    }
    if (msg.funds) {
      json.funds = msg.funds;
    }
    if (msg.expects) {
      json.expects = msg.expects;
    }
    if (msg.filledFunds) {
      json.filledFunds = msg.filledFunds;
    }
    if (msg.filledAmount) {
      json.filledAmount = msg.filledAmount;
    }
    if (msg.binance != undefined) {
      const binance = TradeJSON.BinanceExtra._writeMessage(msg.binance);
      json.binance = binance;
    }
    if (msg.fswap != undefined) {
      const fswap = TradeJSON.FswapExtra._writeMessage(msg.fswap);
      json.fswap = fswap;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Trade, json: any): Trade {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _exchange = json.exchange;
    if (_exchange) {
      msg.exchange = _exchange;
    }
    const _orderId = json.orderId ?? json.order_id;
    if (_orderId) {
      msg.orderId = _orderId;
    }
    const _state = json.state;
    if (_state) {
      msg.state = _state;
    }
    const _payAssetId = json.payAssetId ?? json.pay_asset_id;
    if (_payAssetId) {
      msg.payAssetId = _payAssetId;
    }
    const _payAsset = json.payAsset ?? json.pay_asset;
    if (_payAsset) {
      const m = Asset.initialize();
      AssetJSON._readMessage(m, _payAsset);
      msg.payAsset = m;
    }
    const _fillAssetId = json.fillAssetId ?? json.fill_asset_id;
    if (_fillAssetId) {
      msg.fillAssetId = _fillAssetId;
    }
    const _fillAsset = json.fillAsset ?? json.fill_asset;
    if (_fillAsset) {
      const m = Asset.initialize();
      AssetJSON._readMessage(m, _fillAsset);
      msg.fillAsset = m;
    }
    const _funds = json.funds;
    if (_funds) {
      msg.funds = _funds;
    }
    const _expects = json.expects;
    if (_expects) {
      msg.expects = _expects;
    }
    const _filledFunds = json.filledFunds ?? json.filled_funds;
    if (_filledFunds) {
      msg.filledFunds = _filledFunds;
    }
    const _filledAmount = json.filledAmount ?? json.filled_amount;
    if (_filledAmount) {
      msg.filledAmount = _filledAmount;
    }
    const _binance = json.binance;
    if (_binance) {
      const m = Trade.BinanceExtra.initialize();
      TradeJSON.BinanceExtra._readMessage(m, _binance);
      msg.binance = m;
    }
    const _fswap = json.fswap;
    if (_fswap) {
      const m = Trade.FswapExtra.initialize();
      TradeJSON.FswapExtra._readMessage(m, _fswap);
      msg.fswap = m;
    }
    return msg;
  },

  State: {
    STATE_NOT_SET: "STATE_NOT_SET",
    PENDING: "PENDING",
    TRADING: "TRADING",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Trade.State {
      switch (i) {
        case 0: {
          return "STATE_NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "TRADING";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Trade.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Trade.State): number {
      switch (i) {
        case "STATE_NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "TRADING": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  BinanceExtra: {
    /**
     * Serializes Trade.BinanceExtra to JSON.
     */
    encode: function (msg: Partial<Trade.BinanceExtra>): string {
      return JSON.stringify(TradeJSON.BinanceExtra._writeMessage(msg));
    },

    /**
     * Deserializes Trade.BinanceExtra from JSON.
     */
    decode: function (json: string): Trade.BinanceExtra {
      return TradeJSON.BinanceExtra._readMessage(
        TradeJSON.BinanceExtra.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Trade.BinanceExtra with all fields set to their default value.
     */
    initialize: function (): Trade.BinanceExtra {
      return {
        symbol: "",
        side: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Trade.BinanceExtra>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.symbol) {
        json.symbol = msg.symbol;
      }
      if (msg.side) {
        json.side = msg.side;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Trade.BinanceExtra,
      json: any
    ): Trade.BinanceExtra {
      const _symbol = json.symbol;
      if (_symbol) {
        msg.symbol = _symbol;
      }
      const _side = json.side;
      if (_side) {
        msg.side = _side;
      }
      return msg;
    },
  },

  FswapExtra: {
    /**
     * Serializes Trade.FswapExtra to JSON.
     */
    encode: function (msg: Partial<Trade.FswapExtra>): string {
      return JSON.stringify(TradeJSON.FswapExtra._writeMessage(msg));
    },

    /**
     * Deserializes Trade.FswapExtra from JSON.
     */
    decode: function (json: string): Trade.FswapExtra {
      return TradeJSON.FswapExtra._readMessage(
        TradeJSON.FswapExtra.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Trade.FswapExtra with all fields set to their default value.
     */
    initialize: function (): Trade.FswapExtra {
      return {
        routes: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Trade.FswapExtra>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.routes?.length) {
        json.routes = msg.routes.map(TradeJSON.FswapExtra.Path._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Trade.FswapExtra,
      json: any
    ): Trade.FswapExtra {
      const _routes = json.routes;
      if (_routes) {
        for (const item of _routes) {
          const m = Trade.FswapExtra.Path.initialize();
          TradeJSON.FswapExtra.Path._readMessage(m, item);
          msg.routes.push(m);
        }
      }
      return msg;
    },

    Path: {
      /**
       * Serializes Trade.FswapExtra.Path to JSON.
       */
      encode: function (msg: Partial<Trade.FswapExtra.Path>): string {
        return JSON.stringify(TradeJSON.FswapExtra.Path._writeMessage(msg));
      },

      /**
       * Deserializes Trade.FswapExtra.Path from JSON.
       */
      decode: function (json: string): Trade.FswapExtra.Path {
        return TradeJSON.FswapExtra.Path._readMessage(
          TradeJSON.FswapExtra.Path.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes Trade.FswapExtra.Path with all fields set to their default value.
       */
      initialize: function (): Trade.FswapExtra.Path {
        return {
          amount: "",
          share: "",
          pairs: [],
          assets: [],
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<Trade.FswapExtra.Path>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.amount) {
          json.amount = msg.amount;
        }
        if (msg.share) {
          json.share = msg.share;
        }
        if (msg.pairs?.length) {
          json.pairs = msg.pairs;
        }
        if (msg.assets?.length) {
          json.assets = msg.assets.map(AssetJSON._writeMessage);
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: Trade.FswapExtra.Path,
        json: any
      ): Trade.FswapExtra.Path {
        const _amount = json.amount;
        if (_amount) {
          msg.amount = _amount;
        }
        const _share = json.share;
        if (_share) {
          msg.share = _share;
        }
        const _pairs = json.pairs;
        if (_pairs) {
          msg.pairs = _pairs;
        }
        const _assets = json.assets;
        if (_assets) {
          for (const item of _assets) {
            const m = Asset.initialize();
            AssetJSON._readMessage(m, item);
            msg.assets.push(m);
          }
        }
        return msg;
      },
    },
  },
};

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: Partial<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (): Transfer {
    return {
      traceId: "",
      assetId: "",
      amount: "",
      memo: "",
      opponents: [],
      threshold: 0,
      url: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Transfer>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.traceId) {
      json.traceId = msg.traceId;
    }
    if (msg.assetId) {
      json.assetId = msg.assetId;
    }
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.memo) {
      json.memo = msg.memo;
    }
    if (msg.opponents?.length) {
      json.opponents = msg.opponents;
    }
    if (msg.threshold) {
      json.threshold = msg.threshold;
    }
    if (msg.url) {
      json.url = msg.url;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _traceId = json.traceId ?? json.trace_id;
    if (_traceId) {
      msg.traceId = _traceId;
    }
    const _assetId = json.assetId ?? json.asset_id;
    if (_assetId) {
      msg.assetId = _assetId;
    }
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _memo = json.memo;
    if (_memo) {
      msg.memo = _memo;
    }
    const _opponents = json.opponents;
    if (_opponents) {
      msg.opponents = _opponents;
    }
    const _threshold = json.threshold;
    if (_threshold) {
      msg.threshold = _threshold;
    }
    const _url = json.url;
    if (_url) {
      msg.url = _url;
    }
    return msg;
  },
};

export const PreOrderRequestJSON = {
  /**
   * Serializes PreOrderRequest to JSON.
   */
  encode: function (msg: Partial<PreOrderRequest>): string {
    return JSON.stringify(PreOrderRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes PreOrderRequest from JSON.
   */
  decode: function (json: string): PreOrderRequest {
    return PreOrderRequestJSON._readMessage(
      PreOrderRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PreOrderRequest with all fields set to their default value.
   */
  initialize: function (): PreOrderRequest {
    return {
      type: Order.Type._fromInt(0),
      payAssetId: "",
      fillAssetId: "",
      funds: "",
      exchange: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreOrderRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.type && OrderJSON.Type._toInt(msg.type)) {
      json.type = msg.type;
    }
    if (msg.payAssetId) {
      json.payAssetId = msg.payAssetId;
    }
    if (msg.fillAssetId) {
      json.fillAssetId = msg.fillAssetId;
    }
    if (msg.funds) {
      json.funds = msg.funds;
    }
    if (msg.exchange) {
      json.exchange = msg.exchange;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PreOrderRequest, json: any): PreOrderRequest {
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _payAssetId = json.payAssetId ?? json.pay_asset_id;
    if (_payAssetId) {
      msg.payAssetId = _payAssetId;
    }
    const _fillAssetId = json.fillAssetId ?? json.fill_asset_id;
    if (_fillAssetId) {
      msg.fillAssetId = _fillAssetId;
    }
    const _funds = json.funds;
    if (_funds) {
      msg.funds = _funds;
    }
    const _exchange = json.exchange;
    if (_exchange) {
      msg.exchange = _exchange;
    }
    return msg;
  },
};

export const PreOrderResponseJSON = {
  /**
   * Serializes PreOrderResponse to JSON.
   */
  encode: function (msg: Partial<PreOrderResponse>): string {
    return JSON.stringify(PreOrderResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PreOrderResponse from JSON.
   */
  decode: function (json: string): PreOrderResponse {
    return PreOrderResponseJSON._readMessage(
      PreOrderResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PreOrderResponse with all fields set to their default value.
   */
  initialize: function (): PreOrderResponse {
    return {
      order: Order.initialize(),
      trades: [],
      transfer: Transfer.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreOrderResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.order) {
      const order = OrderJSON._writeMessage(msg.order);
      if (Object.keys(order).length > 0) {
        json.order = order;
      }
    }
    if (msg.trades?.length) {
      json.trades = msg.trades.map(TradeJSON._writeMessage);
    }
    if (msg.transfer) {
      const transfer = TransferJSON._writeMessage(msg.transfer);
      if (Object.keys(transfer).length > 0) {
        json.transfer = transfer;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PreOrderResponse, json: any): PreOrderResponse {
    const _order = json.order;
    if (_order) {
      const m = Order.initialize();
      OrderJSON._readMessage(m, _order);
      msg.order = m;
    }
    const _trades = json.trades;
    if (_trades) {
      for (const item of _trades) {
        const m = Trade.initialize();
        TradeJSON._readMessage(m, item);
        msg.trades.push(m);
      }
    }
    const _transfer = json.transfer;
    if (_transfer) {
      const m = Transfer.initialize();
      TransferJSON._readMessage(m, _transfer);
      msg.transfer = m;
    }
    return msg;
  },
};

export const CancelOrderRequestJSON = {
  /**
   * Serializes CancelOrderRequest to JSON.
   */
  encode: function (msg: Partial<CancelOrderRequest>): string {
    return JSON.stringify(CancelOrderRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CancelOrderRequest from JSON.
   */
  decode: function (json: string): CancelOrderRequest {
    return CancelOrderRequestJSON._readMessage(
      CancelOrderRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes CancelOrderRequest with all fields set to their default value.
   */
  initialize: function (): CancelOrderRequest {
    return {
      id: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CancelOrderRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelOrderRequest,
    json: any
  ): CancelOrderRequest {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    return msg;
  },
};

export const CancelOrderResponseJSON = {
  /**
   * Serializes CancelOrderResponse to JSON.
   */
  encode: function (msg: Partial<CancelOrderResponse>): string {
    return JSON.stringify(CancelOrderResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes CancelOrderResponse from JSON.
   */
  decode: function (json: string): CancelOrderResponse {
    return CancelOrderResponseJSON._readMessage(
      CancelOrderResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes CancelOrderResponse with all fields set to their default value.
   */
  initialize: function (): CancelOrderResponse {
    return {
      order: Order.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CancelOrderResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.order) {
      const order = OrderJSON._writeMessage(msg.order);
      if (Object.keys(order).length > 0) {
        json.order = order;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelOrderResponse,
    json: any
  ): CancelOrderResponse {
    const _order = json.order;
    if (_order) {
      const m = Order.initialize();
      OrderJSON._readMessage(m, _order);
      msg.order = m;
    }
    return msg;
  },
};

export const GetOrderRequestJSON = {
  /**
   * Serializes GetOrderRequest to JSON.
   */
  encode: function (msg: Partial<GetOrderRequest>): string {
    return JSON.stringify(GetOrderRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetOrderRequest from JSON.
   */
  decode: function (json: string): GetOrderRequest {
    return GetOrderRequestJSON._readMessage(
      GetOrderRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetOrderRequest with all fields set to their default value.
   */
  initialize: function (): GetOrderRequest {
    return {
      id: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetOrderRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetOrderRequest, json: any): GetOrderRequest {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    return msg;
  },
};

export const GetOrderResponseJSON = {
  /**
   * Serializes GetOrderResponse to JSON.
   */
  encode: function (msg: Partial<GetOrderResponse>): string {
    return JSON.stringify(GetOrderResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetOrderResponse from JSON.
   */
  decode: function (json: string): GetOrderResponse {
    return GetOrderResponseJSON._readMessage(
      GetOrderResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetOrderResponse with all fields set to their default value.
   */
  initialize: function (): GetOrderResponse {
    return {
      order: Order.initialize(),
      trades: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetOrderResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.order) {
      const order = OrderJSON._writeMessage(msg.order);
      if (Object.keys(order).length > 0) {
        json.order = order;
      }
    }
    if (msg.trades?.length) {
      json.trades = msg.trades.map(TradeJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetOrderResponse, json: any): GetOrderResponse {
    const _order = json.order;
    if (_order) {
      const m = Order.initialize();
      OrderJSON._readMessage(m, _order);
      msg.order = m;
    }
    const _trades = json.trades;
    if (_trades) {
      for (const item of _trades) {
        const m = Trade.initialize();
        TradeJSON._readMessage(m, item);
        msg.trades.push(m);
      }
    }
    return msg;
  },
};

export const ListOrdersRequestJSON = {
  /**
   * Serializes ListOrdersRequest to JSON.
   */
  encode: function (msg: Partial<ListOrdersRequest>): string {
    return JSON.stringify(ListOrdersRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListOrdersRequest from JSON.
   */
  decode: function (json: string): ListOrdersRequest {
    return ListOrdersRequestJSON._readMessage(
      ListOrdersRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ListOrdersRequest with all fields set to their default value.
   */
  initialize: function (): ListOrdersRequest {
    return {
      type: Order.Type._fromInt(0),
      state: Order.State._fromInt(0),
      cursor: "",
      limit: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListOrdersRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.type && OrderJSON.Type._toInt(msg.type)) {
      json.type = msg.type;
    }
    if (msg.state && OrderJSON.State._toInt(msg.state)) {
      json.state = msg.state;
    }
    if (msg.cursor) {
      json.cursor = msg.cursor;
    }
    if (msg.limit) {
      json.limit = msg.limit;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListOrdersRequest,
    json: any
  ): ListOrdersRequest {
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _state = json.state;
    if (_state) {
      msg.state = _state;
    }
    const _cursor = json.cursor;
    if (_cursor) {
      msg.cursor = _cursor;
    }
    const _limit = json.limit;
    if (_limit) {
      msg.limit = _limit;
    }
    return msg;
  },
};

export const ListOrdersResponseJSON = {
  /**
   * Serializes ListOrdersResponse to JSON.
   */
  encode: function (msg: Partial<ListOrdersResponse>): string {
    return JSON.stringify(ListOrdersResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListOrdersResponse from JSON.
   */
  decode: function (json: string): ListOrdersResponse {
    return ListOrdersResponseJSON._readMessage(
      ListOrdersResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ListOrdersResponse with all fields set to their default value.
   */
  initialize: function (): ListOrdersResponse {
    return {
      orders: [],
      nextCursor: "",
      hasNext: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListOrdersResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.orders?.length) {
      json.orders = msg.orders.map(OrderJSON._writeMessage);
    }
    if (msg.nextCursor) {
      json.nextCursor = msg.nextCursor;
    }
    if (msg.hasNext) {
      json.hasNext = msg.hasNext;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListOrdersResponse,
    json: any
  ): ListOrdersResponse {
    const _orders = json.orders;
    if (_orders) {
      for (const item of _orders) {
        const m = Order.initialize();
        OrderJSON._readMessage(m, item);
        msg.orders.push(m);
      }
    }
    const _nextCursor = json.nextCursor ?? json.next_cursor;
    if (_nextCursor) {
      msg.nextCursor = _nextCursor;
    }
    const _hasNext = json.hasNext ?? json.has_next;
    if (_hasNext) {
      msg.hasNext = _hasNext;
    }
    return msg;
  },
};
