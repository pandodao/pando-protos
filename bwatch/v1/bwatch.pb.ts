// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: bwatch/v1/bwatch.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type Action =
  | "ACTION_NOT_SET"
  | "SUBSCRIPTION"
  | "REDEMPTION"
  | "GEM_DEPOSIT"
  | "GEM_WITHDRAW"
  | "AUDIT_REVIEW"
  | "EXPIRE_SUBSCRIPTION";

export interface Asset {
  id: string;
  chainId: string;
  name: string;
  symbol: string;
  logo: string;
  price: string;
}

export interface Gem {
  etf: string;
  share: string;
  balance: string;
  asset: Asset;
}

export interface Etf {
  id: bigint;
  assetId: string;
  name: string;
  symbol: string;
  logo: string;
  version: bigint;
  precision: number;
  maxSupply: string;
  maxSubscriptionAmount: string;
  minSubscriptionAmount: string;
  maxRedemptionAmount: string;
  minRedemptionAmount: string;
  redemptionFeeRate: string;
  redemptionFee: string;
  circulatingSupply: string;
  gems: Gem[];
}

export interface Subscription {
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
  version: bigint;
  state: Subscription.State;
  etf: bigint;
  followId: string;
  assets: Record<string, Subscription.Assets["value"] | undefined>;
  amount: string;
  feeAmount: string;
}

export declare namespace Subscription {
  export type State = "NOT_SET" | "PENDING" | "CANCELLED" | "DONE";

  interface Assets {
    key: string;
    value: string;
  }
}

export interface Transaction {
  group: bigint;
  index: number;
  createdAt: protoscript.Timestamp;
  etf: bigint;
  amount: string;
  feeAmount: string;
  assets: Record<string, Transaction.Assets["value"] | undefined>;
}

export declare namespace Transaction {
  export type Type = "NOT_SET" | "SUBSCRIPTION" | "REDEMPTION";

  interface Assets {
    key: string;
    value: string;
  }
}

export interface User {
  members: string[];
  threshold: number;
  uniqueId: string;
}

export interface Transfer {
  id: string;
  createdAt: protoscript.Timestamp;
  group: bigint;
  assetId: string;
  amount: string;
  memo: string;
  status: Transfer.Status;
  opponent: User;
  txHash: string;
}

export declare namespace Transfer {
  export type Status =
    | "STATUS_NOT_SET"
    | "AUDITING"
    | "APPROVED"
    | "ASSIGNED"
    | "HANDLED"
    | "PASSED"
    | "REJECTED";
}

export interface BwatchReq {}

export declare namespace BwatchReq {
  export interface ListAssetsRequest {}

  export interface ListEtfsRequest {}

  export interface ReadEtfRequest {
    etf: string;
  }

  export interface ReadSubscriptionRequest {
    followId: string;
  }

  export interface ListTransfersRequest {
    group: bigint;
    status: Transfer.Status;
    limit: number;
  }

  export interface GetInfoRequest {}
}

export interface BwatchResp {}

export declare namespace BwatchResp {
  export interface ListAssetsResponse {
    assets: Asset[];
  }

  export interface ListEtfsResponse {
    etfs: Etf[];
  }

  export interface ReadEtfResponse {
    etf: Etf;
  }

  export interface ReadSubscriptionResponse {
    sub: Subscription;
  }

  export interface ListTransfersResponse {
    transfers: Transfer[];
  }

  export interface GetInfoResponse {
    members: string[];
    threshold: number;
    version: string;
    mixAddress: string;
    blockedActions: Action[];
    country: string;
    countryCode: string;
    restricted: boolean;
    ip: string;
  }
}

//========================================//
//     BwatchService Protobuf Client      //
//========================================//

export async function GetInfo(
  getInfoRequest: BwatchReq.GetInfoRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.GetInfoResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/GetInfo",
    BwatchReq.GetInfoRequest.encode(getInfoRequest),
    config,
  );
  return BwatchResp.GetInfoResponse.decode(response);
}

export async function ListAssets(
  listAssetsRequest: BwatchReq.ListAssetsRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListAssetsResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/ListAssets",
    BwatchReq.ListAssetsRequest.encode(listAssetsRequest),
    config,
  );
  return BwatchResp.ListAssetsResponse.decode(response);
}

export async function ListEtfs(
  listEtfsRequest: BwatchReq.ListEtfsRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListEtfsResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/ListEtfs",
    BwatchReq.ListEtfsRequest.encode(listEtfsRequest),
    config,
  );
  return BwatchResp.ListEtfsResponse.decode(response);
}

/**
 * ReadEtf 读取 etf 详情
 */
export async function ReadEtf(
  readEtfRequest: BwatchReq.ReadEtfRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ReadEtfResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/ReadEtf",
    BwatchReq.ReadEtfRequest.encode(readEtfRequest),
    config,
  );
  return BwatchResp.ReadEtfResponse.decode(response);
}

/**
 * ReadSubscription 读取申购详情
 */
export async function ReadSubscription(
  readSubscriptionRequest: BwatchReq.ReadSubscriptionRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ReadSubscriptionResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/ReadSubscription",
    BwatchReq.ReadSubscriptionRequest.encode(readSubscriptionRequest),
    config,
  );
  return BwatchResp.ReadSubscriptionResponse.decode(response);
}

export async function ListTransfers(
  listTransfersRequest: BwatchReq.ListTransfersRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListTransfersResponse> {
  const response = await PBrequest(
    "/bwatch.v1.BwatchService/ListTransfers",
    BwatchReq.ListTransfersRequest.encode(listTransfersRequest),
    config,
  );
  return BwatchResp.ListTransfersResponse.decode(response);
}

//========================================//
//       BwatchService JSON Client        //
//========================================//

export async function GetInfoJSON(
  getInfoRequest: BwatchReq.GetInfoRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.GetInfoResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/GetInfo",
    BwatchReqJSON.GetInfoRequest.encode(getInfoRequest),
    config,
  );
  return BwatchRespJSON.GetInfoResponse.decode(response);
}

export async function ListAssetsJSON(
  listAssetsRequest: BwatchReq.ListAssetsRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListAssetsResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/ListAssets",
    BwatchReqJSON.ListAssetsRequest.encode(listAssetsRequest),
    config,
  );
  return BwatchRespJSON.ListAssetsResponse.decode(response);
}

export async function ListEtfsJSON(
  listEtfsRequest: BwatchReq.ListEtfsRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListEtfsResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/ListEtfs",
    BwatchReqJSON.ListEtfsRequest.encode(listEtfsRequest),
    config,
  );
  return BwatchRespJSON.ListEtfsResponse.decode(response);
}

/**
 * ReadEtf 读取 etf 详情
 */
export async function ReadEtfJSON(
  readEtfRequest: BwatchReq.ReadEtfRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ReadEtfResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/ReadEtf",
    BwatchReqJSON.ReadEtfRequest.encode(readEtfRequest),
    config,
  );
  return BwatchRespJSON.ReadEtfResponse.decode(response);
}

/**
 * ReadSubscription 读取申购详情
 */
export async function ReadSubscriptionJSON(
  readSubscriptionRequest: BwatchReq.ReadSubscriptionRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ReadSubscriptionResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/ReadSubscription",
    BwatchReqJSON.ReadSubscriptionRequest.encode(readSubscriptionRequest),
    config,
  );
  return BwatchRespJSON.ReadSubscriptionResponse.decode(response);
}

export async function ListTransfersJSON(
  listTransfersRequest: BwatchReq.ListTransfersRequest,
  config?: ClientConfiguration,
): Promise<BwatchResp.ListTransfersResponse> {
  const response = await JSONrequest(
    "/bwatch.v1.BwatchService/ListTransfers",
    BwatchReqJSON.ListTransfersRequest.encode(listTransfersRequest),
    config,
  );
  return BwatchRespJSON.ListTransfersResponse.decode(response);
}

//========================================//
//             BwatchService              //
//========================================//

export interface BwatchService<Context = unknown> {
  GetInfo: (
    getInfoRequest: BwatchReq.GetInfoRequest,
    context: Context,
  ) => Promise<BwatchResp.GetInfoResponse> | BwatchResp.GetInfoResponse;
  ListAssets: (
    listAssetsRequest: BwatchReq.ListAssetsRequest,
    context: Context,
  ) => Promise<BwatchResp.ListAssetsResponse> | BwatchResp.ListAssetsResponse;
  ListEtfs: (
    listEtfsRequest: BwatchReq.ListEtfsRequest,
    context: Context,
  ) => Promise<BwatchResp.ListEtfsResponse> | BwatchResp.ListEtfsResponse;
  /**
   * ReadEtf 读取 etf 详情
   */
  ReadEtf: (
    readEtfRequest: BwatchReq.ReadEtfRequest,
    context: Context,
  ) => Promise<BwatchResp.ReadEtfResponse> | BwatchResp.ReadEtfResponse;
  /**
   * ReadSubscription 读取申购详情
   */
  ReadSubscription: (
    readSubscriptionRequest: BwatchReq.ReadSubscriptionRequest,
    context: Context,
  ) =>
    | Promise<BwatchResp.ReadSubscriptionResponse>
    | BwatchResp.ReadSubscriptionResponse;
  ListTransfers: (
    listTransfersRequest: BwatchReq.ListTransfersRequest,
    context: Context,
  ) =>
    | Promise<BwatchResp.ListTransfersResponse>
    | BwatchResp.ListTransfersResponse;
}

export function createBwatchService<Context>(service: BwatchService<Context>) {
  return {
    name: "bwatch.v1.BwatchService",
    methods: {
      GetInfo: {
        name: "GetInfo",
        handler: service.GetInfo,
        input: {
          protobuf: BwatchReq.GetInfoRequest,
          json: BwatchReqJSON.GetInfoRequest,
        },
        output: {
          protobuf: BwatchResp.GetInfoResponse,
          json: BwatchRespJSON.GetInfoResponse,
        },
      },
      ListAssets: {
        name: "ListAssets",
        handler: service.ListAssets,
        input: {
          protobuf: BwatchReq.ListAssetsRequest,
          json: BwatchReqJSON.ListAssetsRequest,
        },
        output: {
          protobuf: BwatchResp.ListAssetsResponse,
          json: BwatchRespJSON.ListAssetsResponse,
        },
      },
      ListEtfs: {
        name: "ListEtfs",
        handler: service.ListEtfs,
        input: {
          protobuf: BwatchReq.ListEtfsRequest,
          json: BwatchReqJSON.ListEtfsRequest,
        },
        output: {
          protobuf: BwatchResp.ListEtfsResponse,
          json: BwatchRespJSON.ListEtfsResponse,
        },
      },
      ReadEtf: {
        name: "ReadEtf",
        handler: service.ReadEtf,
        input: {
          protobuf: BwatchReq.ReadEtfRequest,
          json: BwatchReqJSON.ReadEtfRequest,
        },
        output: {
          protobuf: BwatchResp.ReadEtfResponse,
          json: BwatchRespJSON.ReadEtfResponse,
        },
      },
      ReadSubscription: {
        name: "ReadSubscription",
        handler: service.ReadSubscription,
        input: {
          protobuf: BwatchReq.ReadSubscriptionRequest,
          json: BwatchReqJSON.ReadSubscriptionRequest,
        },
        output: {
          protobuf: BwatchResp.ReadSubscriptionResponse,
          json: BwatchRespJSON.ReadSubscriptionResponse,
        },
      },
      ListTransfers: {
        name: "ListTransfers",
        handler: service.ListTransfers,
        input: {
          protobuf: BwatchReq.ListTransfersRequest,
          json: BwatchReqJSON.ListTransfersRequest,
        },
        output: {
          protobuf: BwatchResp.ListTransfersResponse,
          json: BwatchRespJSON.ListTransfersResponse,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Action = {
  ACTION_NOT_SET: "ACTION_NOT_SET",
  SUBSCRIPTION: "SUBSCRIPTION",
  REDEMPTION: "REDEMPTION",
  GEM_DEPOSIT: "GEM_DEPOSIT",
  GEM_WITHDRAW: "GEM_WITHDRAW",
  AUDIT_REVIEW: "AUDIT_REVIEW",
  EXPIRE_SUBSCRIPTION: "EXPIRE_SUBSCRIPTION",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "ACTION_NOT_SET";
      }
      case 1: {
        return "SUBSCRIPTION";
      }
      case 2: {
        return "REDEMPTION";
      }
      case 3: {
        return "GEM_DEPOSIT";
      }
      case 4: {
        return "GEM_WITHDRAW";
      }
      case 5: {
        return "AUDIT_REVIEW";
      }
      case 6: {
        return "EXPIRE_SUBSCRIPTION";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "ACTION_NOT_SET": {
        return 0;
      }
      case "SUBSCRIPTION": {
        return 1;
      }
      case "REDEMPTION": {
        return 2;
      }
      case "GEM_DEPOSIT": {
        return 3;
      }
      case "GEM_WITHDRAW": {
        return 4;
      }
      case "AUDIT_REVIEW": {
        return 5;
      }
      case "EXPIRE_SUBSCRIPTION": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Asset = {
  /**
   * Serializes Asset to protobuf.
   */
  encode: function (msg: PartialDeep<Asset>): Uint8Array {
    return Asset._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Asset from protobuf.
   */
  decode: function (bytes: ByteSource): Asset {
    return Asset._readMessage(
      Asset.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      chainId: "",
      name: "",
      symbol: "",
      logo: "",
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Asset>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.chainId) {
      writer.writeString(2, msg.chainId);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.symbol) {
      writer.writeString(4, msg.symbol);
    }
    if (msg.logo) {
      writer.writeString(5, msg.logo);
    }
    if (msg.price) {
      writer.writeString(6, msg.price);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, reader: protoscript.BinaryReader): Asset {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.chainId = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.symbol = reader.readString();
          break;
        }
        case 5: {
          msg.logo = reader.readString();
          break;
        }
        case 6: {
          msg.price = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Gem = {
  /**
   * Serializes Gem to protobuf.
   */
  encode: function (msg: PartialDeep<Gem>): Uint8Array {
    return Gem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Gem from protobuf.
   */
  decode: function (bytes: ByteSource): Gem {
    return Gem._readMessage(
      Gem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Gem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Gem>): Gem {
    return {
      etf: "",
      share: "",
      balance: "",
      asset: Asset.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Gem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.etf) {
      writer.writeString(1, msg.etf);
    }
    if (msg.share) {
      writer.writeString(2, msg.share);
    }
    if (msg.balance) {
      writer.writeString(3, msg.balance);
    }
    if (msg.asset) {
      writer.writeMessage(4, msg.asset, Asset._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Gem, reader: protoscript.BinaryReader): Gem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.etf = reader.readString();
          break;
        }
        case 2: {
          msg.share = reader.readString();
          break;
        }
        case 3: {
          msg.balance = reader.readString();
          break;
        }
        case 4: {
          reader.readMessage(msg.asset, Asset._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Etf = {
  /**
   * Serializes Etf to protobuf.
   */
  encode: function (msg: PartialDeep<Etf>): Uint8Array {
    return Etf._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Etf from protobuf.
   */
  decode: function (bytes: ByteSource): Etf {
    return Etf._readMessage(
      Etf.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Etf with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Etf>): Etf {
    return {
      id: 0n,
      assetId: "",
      name: "",
      symbol: "",
      logo: "",
      version: 0n,
      precision: 0,
      maxSupply: "",
      maxSubscriptionAmount: "",
      minSubscriptionAmount: "",
      maxRedemptionAmount: "",
      minRedemptionAmount: "",
      redemptionFeeRate: "",
      redemptionFee: "",
      circulatingSupply: "",
      gems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Etf>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt64String(1, msg.id.toString() as any);
    }
    if (msg.assetId) {
      writer.writeString(2, msg.assetId);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.symbol) {
      writer.writeString(4, msg.symbol);
    }
    if (msg.logo) {
      writer.writeString(5, msg.logo);
    }
    if (msg.version) {
      writer.writeInt64String(6, msg.version.toString() as any);
    }
    if (msg.precision) {
      writer.writeInt32(7, msg.precision);
    }
    if (msg.maxSupply) {
      writer.writeString(8, msg.maxSupply);
    }
    if (msg.maxSubscriptionAmount) {
      writer.writeString(9, msg.maxSubscriptionAmount);
    }
    if (msg.minSubscriptionAmount) {
      writer.writeString(10, msg.minSubscriptionAmount);
    }
    if (msg.maxRedemptionAmount) {
      writer.writeString(11, msg.maxRedemptionAmount);
    }
    if (msg.minRedemptionAmount) {
      writer.writeString(12, msg.minRedemptionAmount);
    }
    if (msg.redemptionFeeRate) {
      writer.writeString(13, msg.redemptionFeeRate);
    }
    if (msg.redemptionFee) {
      writer.writeString(14, msg.redemptionFee);
    }
    if (msg.circulatingSupply) {
      writer.writeString(15, msg.circulatingSupply);
    }
    if (msg.gems?.length) {
      writer.writeRepeatedMessage(16, msg.gems as any, Gem._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Etf, reader: protoscript.BinaryReader): Etf {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.assetId = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.symbol = reader.readString();
          break;
        }
        case 5: {
          msg.logo = reader.readString();
          break;
        }
        case 6: {
          msg.version = BigInt(reader.readInt64String());
          break;
        }
        case 7: {
          msg.precision = reader.readInt32();
          break;
        }
        case 8: {
          msg.maxSupply = reader.readString();
          break;
        }
        case 9: {
          msg.maxSubscriptionAmount = reader.readString();
          break;
        }
        case 10: {
          msg.minSubscriptionAmount = reader.readString();
          break;
        }
        case 11: {
          msg.maxRedemptionAmount = reader.readString();
          break;
        }
        case 12: {
          msg.minRedemptionAmount = reader.readString();
          break;
        }
        case 13: {
          msg.redemptionFeeRate = reader.readString();
          break;
        }
        case 14: {
          msg.redemptionFee = reader.readString();
          break;
        }
        case 15: {
          msg.circulatingSupply = reader.readString();
          break;
        }
        case 16: {
          const m = Gem.initialize();
          reader.readMessage(m, Gem._readMessage);
          msg.gems.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Subscription = {
  /**
   * Serializes Subscription to protobuf.
   */
  encode: function (msg: PartialDeep<Subscription>): Uint8Array {
    return Subscription._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Subscription from protobuf.
   */
  decode: function (bytes: ByteSource): Subscription {
    return Subscription._readMessage(
      Subscription.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Subscription with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Subscription>): Subscription {
    return {
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      version: 0n,
      state: Subscription.State._fromInt(0),
      etf: 0n,
      followId: "",
      assets: {},
      amount: "",
      feeAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Subscription>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.createdAt) {
      writer.writeMessage(
        1,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        2,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.version) {
      writer.writeInt64String(3, msg.version.toString() as any);
    }
    if (msg.state && Subscription.State._toInt(msg.state)) {
      writer.writeEnum(4, Subscription.State._toInt(msg.state));
    }
    if (msg.etf) {
      writer.writeInt64String(5, msg.etf.toString() as any);
    }
    if (msg.followId) {
      writer.writeString(6, msg.followId);
    }
    if (msg.assets) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.assets).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Subscription.Assets._writeMessage,
      );
    }
    if (msg.amount) {
      writer.writeString(8, msg.amount);
    }
    if (msg.feeAmount) {
      writer.writeString(9, msg.feeAmount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Subscription,
    reader: protoscript.BinaryReader,
  ): Subscription {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.version = BigInt(reader.readInt64String());
          break;
        }
        case 4: {
          msg.state = Subscription.State._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.etf = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.followId = reader.readString();
          break;
        }
        case 7: {
          const map = {} as Subscription.Assets;
          reader.readMessage(map, Subscription.Assets._readMessage);
          msg.assets[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          msg.amount = reader.readString();
          break;
        }
        case 9: {
          msg.feeAmount = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  State: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Subscription.State {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Subscription.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Subscription.State): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Assets: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Subscription.Assets>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Subscription.Assets,
      reader: protoscript.BinaryReader,
    ): Subscription.Assets {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Transaction = {
  /**
   * Serializes Transaction to protobuf.
   */
  encode: function (msg: PartialDeep<Transaction>): Uint8Array {
    return Transaction._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transaction from protobuf.
   */
  decode: function (bytes: ByteSource): Transaction {
    return Transaction._readMessage(
      Transaction.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      group: 0n,
      index: 0,
      createdAt: protoscript.Timestamp.initialize(),
      etf: 0n,
      amount: "",
      feeAmount: "",
      assets: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.group) {
      writer.writeInt64String(1, msg.group.toString() as any);
    }
    if (msg.index) {
      writer.writeInt32(2, msg.index);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        3,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.etf) {
      writer.writeInt64String(4, msg.etf.toString() as any);
    }
    if (msg.amount) {
      writer.writeString(5, msg.amount);
    }
    if (msg.feeAmount) {
      writer.writeString(6, msg.feeAmount);
    }
    if (msg.assets) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.assets).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Transaction.Assets._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transaction,
    reader: protoscript.BinaryReader,
  ): Transaction {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.group = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.index = reader.readInt32();
          break;
        }
        case 3: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.etf = BigInt(reader.readInt64String());
          break;
        }
        case 5: {
          msg.amount = reader.readString();
          break;
        }
        case 6: {
          msg.feeAmount = reader.readString();
          break;
        }
        case 7: {
          const map = {} as Transaction.Assets;
          reader.readMessage(map, Transaction.Assets._readMessage);
          msg.assets[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Type: {
    NOT_SET: "NOT_SET",
    SUBSCRIPTION: "SUBSCRIPTION",
    REDEMPTION: "REDEMPTION",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Type {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "SUBSCRIPTION";
        }
        case 2: {
          return "REDEMPTION";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Type): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "SUBSCRIPTION": {
          return 1;
        }
        case "REDEMPTION": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Assets: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Transaction.Assets>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Transaction.Assets,
      reader: protoscript.BinaryReader,
    ): Transaction.Assets {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const User = {
  /**
   * Serializes User to protobuf.
   */
  encode: function (msg: PartialDeep<User>): Uint8Array {
    return User._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes User from protobuf.
   */
  decode: function (bytes: ByteSource): User {
    return User._readMessage(
      User.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      members: [],
      threshold: 0,
      uniqueId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<User>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.members?.length) {
      writer.writeRepeatedString(1, msg.members);
    }
    if (msg.threshold) {
      writer.writeUint32(2, msg.threshold);
    }
    if (msg.uniqueId) {
      writer.writeString(3, msg.uniqueId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, reader: protoscript.BinaryReader): User {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.members.push(reader.readString());
          break;
        }
        case 2: {
          msg.threshold = reader.readUint32();
          break;
        }
        case 3: {
          msg.uniqueId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Transfer = {
  /**
   * Serializes Transfer to protobuf.
   */
  encode: function (msg: PartialDeep<Transfer>): Uint8Array {
    return Transfer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Transfer from protobuf.
   */
  decode: function (bytes: ByteSource): Transfer {
    return Transfer._readMessage(
      Transfer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.Timestamp.initialize(),
      group: 0n,
      assetId: "",
      amount: "",
      memo: "",
      status: Transfer.Status._fromInt(0),
      opponent: User.initialize(),
      txHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        2,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.group) {
      writer.writeUint64String(3, msg.group.toString() as any);
    }
    if (msg.assetId) {
      writer.writeString(4, msg.assetId);
    }
    if (msg.amount) {
      writer.writeString(5, msg.amount);
    }
    if (msg.memo) {
      writer.writeString(6, msg.memo);
    }
    if (msg.status && Transfer.Status._toInt(msg.status)) {
      writer.writeEnum(7, Transfer.Status._toInt(msg.status));
    }
    if (msg.opponent) {
      writer.writeMessage(8, msg.opponent, User._writeMessage);
    }
    if (msg.txHash) {
      writer.writeString(9, msg.txHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Transfer,
    reader: protoscript.BinaryReader,
  ): Transfer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.group = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.assetId = reader.readString();
          break;
        }
        case 5: {
          msg.amount = reader.readString();
          break;
        }
        case 6: {
          msg.memo = reader.readString();
          break;
        }
        case 7: {
          msg.status = Transfer.Status._fromInt(reader.readEnum());
          break;
        }
        case 8: {
          reader.readMessage(msg.opponent, User._readMessage);
          break;
        }
        case 9: {
          msg.txHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    AUDITING: "AUDITING",
    APPROVED: "APPROVED",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    REJECTED: "REJECTED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "AUDITING";
        }
        case 2: {
          return "APPROVED";
        }
        case 3: {
          return "ASSIGNED";
        }
        case 4: {
          return "HANDLED";
        }
        case 5: {
          return "PASSED";
        }
        case 6: {
          return "REJECTED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "AUDITING": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        case "ASSIGNED": {
          return 3;
        }
        case "HANDLED": {
          return 4;
        }
        case "PASSED": {
          return 5;
        }
        case "REJECTED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const BwatchReq = {
  /**
   * Serializes BwatchReq to protobuf.
   */
  encode: function (_msg?: PartialDeep<BwatchReq>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BwatchReq from protobuf.
   */
  decode: function (_bytes?: ByteSource): BwatchReq {
    return {};
  },

  /**
   * Initializes BwatchReq with all fields set to their default value.
   */
  initialize: function (msg?: Partial<BwatchReq>): BwatchReq {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BwatchReq>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: BwatchReq,
    _reader: protoscript.BinaryReader,
  ): BwatchReq {
    return _msg;
  },

  ListAssetsRequest: {
    /**
     * Serializes BwatchReq.ListAssetsRequest to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<BwatchReq.ListAssetsRequest>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes BwatchReq.ListAssetsRequest from protobuf.
     */
    decode: function (_bytes?: ByteSource): BwatchReq.ListAssetsRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.ListAssetsRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListAssetsRequest>,
    ): BwatchReq.ListAssetsRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.ListAssetsRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: BwatchReq.ListAssetsRequest,
      _reader: protoscript.BinaryReader,
    ): BwatchReq.ListAssetsRequest {
      return _msg;
    },
  },

  ListEtfsRequest: {
    /**
     * Serializes BwatchReq.ListEtfsRequest to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<BwatchReq.ListEtfsRequest>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes BwatchReq.ListEtfsRequest from protobuf.
     */
    decode: function (_bytes?: ByteSource): BwatchReq.ListEtfsRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.ListEtfsRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListEtfsRequest>,
    ): BwatchReq.ListEtfsRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.ListEtfsRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: BwatchReq.ListEtfsRequest,
      _reader: protoscript.BinaryReader,
    ): BwatchReq.ListEtfsRequest {
      return _msg;
    },
  },

  ReadEtfRequest: {
    /**
     * Serializes BwatchReq.ReadEtfRequest to protobuf.
     */
    encode: function (msg: PartialDeep<BwatchReq.ReadEtfRequest>): Uint8Array {
      return BwatchReq.ReadEtfRequest._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchReq.ReadEtfRequest from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchReq.ReadEtfRequest {
      return BwatchReq.ReadEtfRequest._readMessage(
        BwatchReq.ReadEtfRequest.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchReq.ReadEtfRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ReadEtfRequest>,
    ): BwatchReq.ReadEtfRequest {
      return {
        etf: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ReadEtfRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.etf) {
        writer.writeString(1, msg.etf);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ReadEtfRequest,
      reader: protoscript.BinaryReader,
    ): BwatchReq.ReadEtfRequest {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.etf = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ReadSubscriptionRequest: {
    /**
     * Serializes BwatchReq.ReadSubscriptionRequest to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchReq.ReadSubscriptionRequest>,
    ): Uint8Array {
      return BwatchReq.ReadSubscriptionRequest._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchReq.ReadSubscriptionRequest from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchReq.ReadSubscriptionRequest {
      return BwatchReq.ReadSubscriptionRequest._readMessage(
        BwatchReq.ReadSubscriptionRequest.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchReq.ReadSubscriptionRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ReadSubscriptionRequest>,
    ): BwatchReq.ReadSubscriptionRequest {
      return {
        followId: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ReadSubscriptionRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.followId) {
        writer.writeString(1, msg.followId);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ReadSubscriptionRequest,
      reader: protoscript.BinaryReader,
    ): BwatchReq.ReadSubscriptionRequest {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.followId = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransfersRequest: {
    /**
     * Serializes BwatchReq.ListTransfersRequest to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchReq.ListTransfersRequest>,
    ): Uint8Array {
      return BwatchReq.ListTransfersRequest._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchReq.ListTransfersRequest from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchReq.ListTransfersRequest {
      return BwatchReq.ListTransfersRequest._readMessage(
        BwatchReq.ListTransfersRequest.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchReq.ListTransfersRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListTransfersRequest>,
    ): BwatchReq.ListTransfersRequest {
      return {
        group: 0n,
        status: Transfer.Status._fromInt(0),
        limit: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ListTransfersRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.group) {
        writer.writeUint64String(1, msg.group.toString() as any);
      }
      if (msg.status && Transfer.Status._toInt(msg.status)) {
        writer.writeEnum(2, Transfer.Status._toInt(msg.status));
      }
      if (msg.limit) {
        writer.writeInt32(3, msg.limit);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ListTransfersRequest,
      reader: protoscript.BinaryReader,
    ): BwatchReq.ListTransfersRequest {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.group = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.status = Transfer.Status._fromInt(reader.readEnum());
            break;
          }
          case 3: {
            msg.limit = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfoRequest: {
    /**
     * Serializes BwatchReq.GetInfoRequest to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<BwatchReq.GetInfoRequest>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes BwatchReq.GetInfoRequest from protobuf.
     */
    decode: function (_bytes?: ByteSource): BwatchReq.GetInfoRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.GetInfoRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.GetInfoRequest>,
    ): BwatchReq.GetInfoRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.GetInfoRequest>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: BwatchReq.GetInfoRequest,
      _reader: protoscript.BinaryReader,
    ): BwatchReq.GetInfoRequest {
      return _msg;
    },
  },
};

export const BwatchResp = {
  /**
   * Serializes BwatchResp to protobuf.
   */
  encode: function (_msg?: PartialDeep<BwatchResp>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BwatchResp from protobuf.
   */
  decode: function (_bytes?: ByteSource): BwatchResp {
    return {};
  },

  /**
   * Initializes BwatchResp with all fields set to their default value.
   */
  initialize: function (msg?: Partial<BwatchResp>): BwatchResp {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BwatchResp>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: BwatchResp,
    _reader: protoscript.BinaryReader,
  ): BwatchResp {
    return _msg;
  },

  ListAssetsResponse: {
    /**
     * Serializes BwatchResp.ListAssetsResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ListAssetsResponse>,
    ): Uint8Array {
      return BwatchResp.ListAssetsResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.ListAssetsResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.ListAssetsResponse {
      return BwatchResp.ListAssetsResponse._readMessage(
        BwatchResp.ListAssetsResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.ListAssetsResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListAssetsResponse>,
    ): BwatchResp.ListAssetsResponse {
      return {
        assets: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListAssetsResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.assets?.length) {
        writer.writeRepeatedMessage(1, msg.assets as any, Asset._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListAssetsResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.ListAssetsResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Asset.initialize();
            reader.readMessage(m, Asset._readMessage);
            msg.assets.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListEtfsResponse: {
    /**
     * Serializes BwatchResp.ListEtfsResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ListEtfsResponse>,
    ): Uint8Array {
      return BwatchResp.ListEtfsResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.ListEtfsResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.ListEtfsResponse {
      return BwatchResp.ListEtfsResponse._readMessage(
        BwatchResp.ListEtfsResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.ListEtfsResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListEtfsResponse>,
    ): BwatchResp.ListEtfsResponse {
      return {
        etfs: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListEtfsResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.etfs?.length) {
        writer.writeRepeatedMessage(1, msg.etfs as any, Etf._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListEtfsResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.ListEtfsResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Etf.initialize();
            reader.readMessage(m, Etf._readMessage);
            msg.etfs.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ReadEtfResponse: {
    /**
     * Serializes BwatchResp.ReadEtfResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ReadEtfResponse>,
    ): Uint8Array {
      return BwatchResp.ReadEtfResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.ReadEtfResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.ReadEtfResponse {
      return BwatchResp.ReadEtfResponse._readMessage(
        BwatchResp.ReadEtfResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.ReadEtfResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ReadEtfResponse>,
    ): BwatchResp.ReadEtfResponse {
      return {
        etf: Etf.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ReadEtfResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.etf) {
        writer.writeMessage(1, msg.etf, Etf._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ReadEtfResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.ReadEtfResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.etf, Etf._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ReadSubscriptionResponse: {
    /**
     * Serializes BwatchResp.ReadSubscriptionResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ReadSubscriptionResponse>,
    ): Uint8Array {
      return BwatchResp.ReadSubscriptionResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.ReadSubscriptionResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.ReadSubscriptionResponse {
      return BwatchResp.ReadSubscriptionResponse._readMessage(
        BwatchResp.ReadSubscriptionResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.ReadSubscriptionResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ReadSubscriptionResponse>,
    ): BwatchResp.ReadSubscriptionResponse {
      return {
        sub: Subscription.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ReadSubscriptionResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.sub) {
        writer.writeMessage(1, msg.sub, Subscription._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ReadSubscriptionResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.ReadSubscriptionResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.sub, Subscription._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ListTransfersResponse: {
    /**
     * Serializes BwatchResp.ListTransfersResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ListTransfersResponse>,
    ): Uint8Array {
      return BwatchResp.ListTransfersResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.ListTransfersResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.ListTransfersResponse {
      return BwatchResp.ListTransfersResponse._readMessage(
        BwatchResp.ListTransfersResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.ListTransfersResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListTransfersResponse>,
    ): BwatchResp.ListTransfersResponse {
      return {
        transfers: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListTransfersResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.transfers?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.transfers as any,
          Transfer._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListTransfersResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.ListTransfersResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = Transfer.initialize();
            reader.readMessage(m, Transfer._readMessage);
            msg.transfers.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  GetInfoResponse: {
    /**
     * Serializes BwatchResp.GetInfoResponse to protobuf.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.GetInfoResponse>,
    ): Uint8Array {
      return BwatchResp.GetInfoResponse._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes BwatchResp.GetInfoResponse from protobuf.
     */
    decode: function (bytes: ByteSource): BwatchResp.GetInfoResponse {
      return BwatchResp.GetInfoResponse._readMessage(
        BwatchResp.GetInfoResponse.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes BwatchResp.GetInfoResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.GetInfoResponse>,
    ): BwatchResp.GetInfoResponse {
      return {
        members: [],
        threshold: 0,
        version: "",
        mixAddress: "",
        blockedActions: [],
        country: "",
        countryCode: "",
        restricted: false,
        ip: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.GetInfoResponse>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.members?.length) {
        writer.writeRepeatedString(1, msg.members);
      }
      if (msg.threshold) {
        writer.writeInt32(2, msg.threshold);
      }
      if (msg.version) {
        writer.writeString(3, msg.version);
      }
      if (msg.mixAddress) {
        writer.writeString(4, msg.mixAddress);
      }
      if (msg.blockedActions?.length) {
        writer.writePackedEnum(5, msg.blockedActions.map(Action._toInt));
      }
      if (msg.country) {
        writer.writeString(6, msg.country);
      }
      if (msg.countryCode) {
        writer.writeString(7, msg.countryCode);
      }
      if (msg.restricted) {
        writer.writeBool(8, msg.restricted);
      }
      if (msg.ip) {
        writer.writeString(9, msg.ip);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.GetInfoResponse,
      reader: protoscript.BinaryReader,
    ): BwatchResp.GetInfoResponse {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.members.push(reader.readString());
            break;
          }
          case 2: {
            msg.threshold = reader.readInt32();
            break;
          }
          case 3: {
            msg.version = reader.readString();
            break;
          }
          case 4: {
            msg.mixAddress = reader.readString();
            break;
          }
          case 5: {
            if (reader.isDelimited()) {
              msg.blockedActions.push(
                ...reader.readPackedEnum().map(Action._fromInt),
              );
            } else {
              msg.blockedActions.push(Action._fromInt(reader.readEnum()));
            }
            break;
          }
          case 6: {
            msg.country = reader.readString();
            break;
          }
          case 7: {
            msg.countryCode = reader.readString();
            break;
          }
          case 8: {
            msg.restricted = reader.readBool();
            break;
          }
          case 9: {
            msg.ip = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ActionJSON = {
  ACTION_NOT_SET: "ACTION_NOT_SET",
  SUBSCRIPTION: "SUBSCRIPTION",
  REDEMPTION: "REDEMPTION",
  GEM_DEPOSIT: "GEM_DEPOSIT",
  GEM_WITHDRAW: "GEM_WITHDRAW",
  AUDIT_REVIEW: "AUDIT_REVIEW",
  EXPIRE_SUBSCRIPTION: "EXPIRE_SUBSCRIPTION",
  /**
   * @private
   */
  _fromInt: function (i: number): Action {
    switch (i) {
      case 0: {
        return "ACTION_NOT_SET";
      }
      case 1: {
        return "SUBSCRIPTION";
      }
      case 2: {
        return "REDEMPTION";
      }
      case 3: {
        return "GEM_DEPOSIT";
      }
      case 4: {
        return "GEM_WITHDRAW";
      }
      case 5: {
        return "AUDIT_REVIEW";
      }
      case 6: {
        return "EXPIRE_SUBSCRIPTION";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Action;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Action): number {
    switch (i) {
      case "ACTION_NOT_SET": {
        return 0;
      }
      case "SUBSCRIPTION": {
        return 1;
      }
      case "REDEMPTION": {
        return 2;
      }
      case "GEM_DEPOSIT": {
        return 3;
      }
      case "GEM_WITHDRAW": {
        return 4;
      }
      case "AUDIT_REVIEW": {
        return 5;
      }
      case "EXPIRE_SUBSCRIPTION": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const AssetJSON = {
  /**
   * Serializes Asset to JSON.
   */
  encode: function (msg: PartialDeep<Asset>): string {
    return JSON.stringify(AssetJSON._writeMessage(msg));
  },

  /**
   * Deserializes Asset from JSON.
   */
  decode: function (json: string): Asset {
    return AssetJSON._readMessage(AssetJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Asset with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Asset>): Asset {
    return {
      id: "",
      chainId: "",
      name: "",
      symbol: "",
      logo: "",
      price: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Asset>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.chainId) {
      json["chainId"] = msg.chainId;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.symbol) {
      json["symbol"] = msg.symbol;
    }
    if (msg.logo) {
      json["logo"] = msg.logo;
    }
    if (msg.price) {
      json["price"] = msg.price;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Asset, json: any): Asset {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _chainId_ = json["chainId"] ?? json["chain_id"];
    if (_chainId_) {
      msg.chainId = _chainId_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _symbol_ = json["symbol"];
    if (_symbol_) {
      msg.symbol = _symbol_;
    }
    const _logo_ = json["logo"];
    if (_logo_) {
      msg.logo = _logo_;
    }
    const _price_ = json["price"];
    if (_price_) {
      msg.price = _price_;
    }
    return msg;
  },
};

export const GemJSON = {
  /**
   * Serializes Gem to JSON.
   */
  encode: function (msg: PartialDeep<Gem>): string {
    return JSON.stringify(GemJSON._writeMessage(msg));
  },

  /**
   * Deserializes Gem from JSON.
   */
  decode: function (json: string): Gem {
    return GemJSON._readMessage(GemJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Gem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Gem>): Gem {
    return {
      etf: "",
      share: "",
      balance: "",
      asset: AssetJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Gem>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.etf) {
      json["etf"] = msg.etf;
    }
    if (msg.share) {
      json["share"] = msg.share;
    }
    if (msg.balance) {
      json["balance"] = msg.balance;
    }
    if (msg.asset) {
      const _asset_ = AssetJSON._writeMessage(msg.asset);
      if (Object.keys(_asset_).length > 0) {
        json["asset"] = _asset_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Gem, json: any): Gem {
    const _etf_ = json["etf"];
    if (_etf_) {
      msg.etf = _etf_;
    }
    const _share_ = json["share"];
    if (_share_) {
      msg.share = _share_;
    }
    const _balance_ = json["balance"];
    if (_balance_) {
      msg.balance = _balance_;
    }
    const _asset_ = json["asset"];
    if (_asset_) {
      AssetJSON._readMessage(msg.asset, _asset_);
    }
    return msg;
  },
};

export const EtfJSON = {
  /**
   * Serializes Etf to JSON.
   */
  encode: function (msg: PartialDeep<Etf>): string {
    return JSON.stringify(EtfJSON._writeMessage(msg));
  },

  /**
   * Deserializes Etf from JSON.
   */
  decode: function (json: string): Etf {
    return EtfJSON._readMessage(EtfJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Etf with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Etf>): Etf {
    return {
      id: 0n,
      assetId: "",
      name: "",
      symbol: "",
      logo: "",
      version: 0n,
      precision: 0,
      maxSupply: "",
      maxSubscriptionAmount: "",
      minSubscriptionAmount: "",
      maxRedemptionAmount: "",
      minRedemptionAmount: "",
      redemptionFeeRate: "",
      redemptionFee: "",
      circulatingSupply: "",
      gems: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Etf>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = String(msg.id);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.symbol) {
      json["symbol"] = msg.symbol;
    }
    if (msg.logo) {
      json["logo"] = msg.logo;
    }
    if (msg.version) {
      json["version"] = String(msg.version);
    }
    if (msg.precision) {
      json["precision"] = msg.precision;
    }
    if (msg.maxSupply) {
      json["maxSupply"] = msg.maxSupply;
    }
    if (msg.maxSubscriptionAmount) {
      json["maxSubscriptionAmount"] = msg.maxSubscriptionAmount;
    }
    if (msg.minSubscriptionAmount) {
      json["minSubscriptionAmount"] = msg.minSubscriptionAmount;
    }
    if (msg.maxRedemptionAmount) {
      json["maxRedemptionAmount"] = msg.maxRedemptionAmount;
    }
    if (msg.minRedemptionAmount) {
      json["minRedemptionAmount"] = msg.minRedemptionAmount;
    }
    if (msg.redemptionFeeRate) {
      json["redemptionFeeRate"] = msg.redemptionFeeRate;
    }
    if (msg.redemptionFee) {
      json["redemptionFee"] = msg.redemptionFee;
    }
    if (msg.circulatingSupply) {
      json["circulatingSupply"] = msg.circulatingSupply;
    }
    if (msg.gems?.length) {
      json["gems"] = msg.gems.map(GemJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Etf, json: any): Etf {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = BigInt(_id_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _symbol_ = json["symbol"];
    if (_symbol_) {
      msg.symbol = _symbol_;
    }
    const _logo_ = json["logo"];
    if (_logo_) {
      msg.logo = _logo_;
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = BigInt(_version_);
    }
    const _precision_ = json["precision"];
    if (_precision_) {
      msg.precision = protoscript.parseNumber(_precision_);
    }
    const _maxSupply_ = json["maxSupply"] ?? json["max_supply"];
    if (_maxSupply_) {
      msg.maxSupply = _maxSupply_;
    }
    const _maxSubscriptionAmount_ =
      json["maxSubscriptionAmount"] ?? json["max_subscription_amount"];
    if (_maxSubscriptionAmount_) {
      msg.maxSubscriptionAmount = _maxSubscriptionAmount_;
    }
    const _minSubscriptionAmount_ =
      json["minSubscriptionAmount"] ?? json["min_subscription_amount"];
    if (_minSubscriptionAmount_) {
      msg.minSubscriptionAmount = _minSubscriptionAmount_;
    }
    const _maxRedemptionAmount_ =
      json["maxRedemptionAmount"] ?? json["max_redemption_amount"];
    if (_maxRedemptionAmount_) {
      msg.maxRedemptionAmount = _maxRedemptionAmount_;
    }
    const _minRedemptionAmount_ =
      json["minRedemptionAmount"] ?? json["min_redemption_amount"];
    if (_minRedemptionAmount_) {
      msg.minRedemptionAmount = _minRedemptionAmount_;
    }
    const _redemptionFeeRate_ =
      json["redemptionFeeRate"] ?? json["redemption_fee_rate"];
    if (_redemptionFeeRate_) {
      msg.redemptionFeeRate = _redemptionFeeRate_;
    }
    const _redemptionFee_ = json["redemptionFee"] ?? json["redemption_fee"];
    if (_redemptionFee_) {
      msg.redemptionFee = _redemptionFee_;
    }
    const _circulatingSupply_ =
      json["circulatingSupply"] ?? json["circulating_supply"];
    if (_circulatingSupply_) {
      msg.circulatingSupply = _circulatingSupply_;
    }
    const _gems_ = json["gems"];
    if (_gems_) {
      for (const item of _gems_) {
        const m = GemJSON.initialize();
        GemJSON._readMessage(m, item);
        msg.gems.push(m);
      }
    }
    return msg;
  },
};

export const SubscriptionJSON = {
  /**
   * Serializes Subscription to JSON.
   */
  encode: function (msg: PartialDeep<Subscription>): string {
    return JSON.stringify(SubscriptionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Subscription from JSON.
   */
  decode: function (json: string): Subscription {
    return SubscriptionJSON._readMessage(
      SubscriptionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Subscription with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Subscription>): Subscription {
    return {
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      version: 0n,
      state: Subscription.State._fromInt(0),
      etf: 0n,
      followId: "",
      assets: {},
      amount: "",
      feeAmount: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Subscription>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    if (msg.version) {
      json["version"] = String(msg.version);
    }
    if (msg.state && SubscriptionJSON.State._toInt(msg.state)) {
      json["state"] = msg.state;
    }
    if (msg.etf) {
      json["etf"] = String(msg.etf);
    }
    if (msg.followId) {
      json["followId"] = msg.followId;
    }
    if (msg.assets) {
      const _assets_ = Object.fromEntries(
        Object.entries(msg.assets)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(SubscriptionJSON.Assets._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_assets_).length > 0) {
        json["assets"] = _assets_;
      }
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.feeAmount) {
      json["feeAmount"] = msg.feeAmount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Subscription, json: any): Subscription {
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = BigInt(_version_);
    }
    const _state_ = json["state"];
    if (_state_) {
      msg.state = Subscription.State._fromInt(_state_);
    }
    const _etf_ = json["etf"];
    if (_etf_) {
      msg.etf = BigInt(_etf_);
    }
    const _followId_ = json["followId"] ?? json["follow_id"];
    if (_followId_) {
      msg.followId = _followId_;
    }
    const _assets_ = json["assets"];
    if (_assets_) {
      msg.assets = Object.fromEntries(
        Object.entries(_assets_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(SubscriptionJSON.Assets._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _feeAmount_ = json["feeAmount"] ?? json["fee_amount"];
    if (_feeAmount_) {
      msg.feeAmount = _feeAmount_;
    }
    return msg;
  },

  State: {
    NOT_SET: "NOT_SET",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    DONE: "DONE",
    /**
     * @private
     */
    _fromInt: function (i: number): Subscription.State {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "PENDING";
        }
        case 2: {
          return "CANCELLED";
        }
        case 3: {
          return "DONE";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Subscription.State;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Subscription.State): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "PENDING": {
          return 1;
        }
        case "CANCELLED": {
          return 2;
        }
        case "DONE": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Assets: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Subscription.Assets>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Subscription.Assets,
      json: any,
    ): Subscription.Assets {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TransactionJSON = {
  /**
   * Serializes Transaction to JSON.
   */
  encode: function (msg: PartialDeep<Transaction>): string {
    return JSON.stringify(TransactionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transaction from JSON.
   */
  decode: function (json: string): Transaction {
    return TransactionJSON._readMessage(
      TransactionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transaction with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transaction>): Transaction {
    return {
      group: 0n,
      index: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      etf: 0n,
      amount: "",
      feeAmount: "",
      assets: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transaction>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    if (msg.index) {
      json["index"] = msg.index;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.etf) {
      json["etf"] = String(msg.etf);
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.feeAmount) {
      json["feeAmount"] = msg.feeAmount;
    }
    if (msg.assets) {
      const _assets_ = Object.fromEntries(
        Object.entries(msg.assets)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TransactionJSON.Assets._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_assets_).length > 0) {
        json["assets"] = _assets_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transaction, json: any): Transaction {
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    const _index_ = json["index"];
    if (_index_) {
      msg.index = protoscript.parseNumber(_index_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _etf_ = json["etf"];
    if (_etf_) {
      msg.etf = BigInt(_etf_);
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _feeAmount_ = json["feeAmount"] ?? json["fee_amount"];
    if (_feeAmount_) {
      msg.feeAmount = _feeAmount_;
    }
    const _assets_ = json["assets"];
    if (_assets_) {
      msg.assets = Object.fromEntries(
        Object.entries(_assets_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TransactionJSON.Assets._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Type: {
    NOT_SET: "NOT_SET",
    SUBSCRIPTION: "SUBSCRIPTION",
    REDEMPTION: "REDEMPTION",
    /**
     * @private
     */
    _fromInt: function (i: number): Transaction.Type {
      switch (i) {
        case 0: {
          return "NOT_SET";
        }
        case 1: {
          return "SUBSCRIPTION";
        }
        case 2: {
          return "REDEMPTION";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transaction.Type;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transaction.Type): number {
      switch (i) {
        case "NOT_SET": {
          return 0;
        }
        case "SUBSCRIPTION": {
          return 1;
        }
        case "REDEMPTION": {
          return 2;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Assets: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Transaction.Assets>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Transaction.Assets,
      json: any,
    ): Transaction.Assets {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const UserJSON = {
  /**
   * Serializes User to JSON.
   */
  encode: function (msg: PartialDeep<User>): string {
    return JSON.stringify(UserJSON._writeMessage(msg));
  },

  /**
   * Deserializes User from JSON.
   */
  decode: function (json: string): User {
    return UserJSON._readMessage(UserJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes User with all fields set to their default value.
   */
  initialize: function (msg?: Partial<User>): User {
    return {
      members: [],
      threshold: 0,
      uniqueId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<User>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.members?.length) {
      json["members"] = msg.members;
    }
    if (msg.threshold) {
      json["threshold"] = msg.threshold;
    }
    if (msg.uniqueId) {
      json["uniqueId"] = msg.uniqueId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: User, json: any): User {
    const _members_ = json["members"];
    if (_members_) {
      msg.members = _members_;
    }
    const _threshold_ = json["threshold"];
    if (_threshold_) {
      msg.threshold = protoscript.parseNumber(_threshold_);
    }
    const _uniqueId_ = json["uniqueId"] ?? json["unique_id"];
    if (_uniqueId_) {
      msg.uniqueId = _uniqueId_;
    }
    return msg;
  },
};

export const TransferJSON = {
  /**
   * Serializes Transfer to JSON.
   */
  encode: function (msg: PartialDeep<Transfer>): string {
    return JSON.stringify(TransferJSON._writeMessage(msg));
  },

  /**
   * Deserializes Transfer from JSON.
   */
  decode: function (json: string): Transfer {
    return TransferJSON._readMessage(
      TransferJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Transfer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Transfer>): Transfer {
    return {
      id: "",
      createdAt: protoscript.TimestampJSON.initialize(),
      group: 0n,
      assetId: "",
      amount: "",
      memo: "",
      status: Transfer.Status._fromInt(0),
      opponent: UserJSON.initialize(),
      txHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Transfer>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.group) {
      json["group"] = String(msg.group);
    }
    if (msg.assetId) {
      json["assetId"] = msg.assetId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.memo) {
      json["memo"] = msg.memo;
    }
    if (msg.status && TransferJSON.Status._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.opponent) {
      const _opponent_ = UserJSON._writeMessage(msg.opponent);
      if (Object.keys(_opponent_).length > 0) {
        json["opponent"] = _opponent_;
      }
    }
    if (msg.txHash) {
      json["txHash"] = msg.txHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Transfer, json: any): Transfer {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _group_ = json["group"];
    if (_group_) {
      msg.group = BigInt(_group_);
    }
    const _assetId_ = json["assetId"] ?? json["asset_id"];
    if (_assetId_) {
      msg.assetId = _assetId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _memo_ = json["memo"];
    if (_memo_) {
      msg.memo = _memo_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = Transfer.Status._fromInt(_status_);
    }
    const _opponent_ = json["opponent"];
    if (_opponent_) {
      UserJSON._readMessage(msg.opponent, _opponent_);
    }
    const _txHash_ = json["txHash"] ?? json["tx_hash"];
    if (_txHash_) {
      msg.txHash = _txHash_;
    }
    return msg;
  },

  Status: {
    STATUS_NOT_SET: "STATUS_NOT_SET",
    AUDITING: "AUDITING",
    APPROVED: "APPROVED",
    ASSIGNED: "ASSIGNED",
    HANDLED: "HANDLED",
    PASSED: "PASSED",
    REJECTED: "REJECTED",
    /**
     * @private
     */
    _fromInt: function (i: number): Transfer.Status {
      switch (i) {
        case 0: {
          return "STATUS_NOT_SET";
        }
        case 1: {
          return "AUDITING";
        }
        case 2: {
          return "APPROVED";
        }
        case 3: {
          return "ASSIGNED";
        }
        case 4: {
          return "HANDLED";
        }
        case 5: {
          return "PASSED";
        }
        case 6: {
          return "REJECTED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Transfer.Status;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Transfer.Status): number {
      switch (i) {
        case "STATUS_NOT_SET": {
          return 0;
        }
        case "AUDITING": {
          return 1;
        }
        case "APPROVED": {
          return 2;
        }
        case "ASSIGNED": {
          return 3;
        }
        case "HANDLED": {
          return 4;
        }
        case "PASSED": {
          return 5;
        }
        case "REJECTED": {
          return 6;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const BwatchReqJSON = {
  /**
   * Serializes BwatchReq to JSON.
   */
  encode: function (_msg?: PartialDeep<BwatchReq>): string {
    return "{}";
  },

  /**
   * Deserializes BwatchReq from JSON.
   */
  decode: function (_json?: string): BwatchReq {
    return {};
  },

  /**
   * Initializes BwatchReq with all fields set to their default value.
   */
  initialize: function (msg?: Partial<BwatchReq>): BwatchReq {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BwatchReq>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BwatchReq, _json: any): BwatchReq {
    return msg;
  },

  ListAssetsRequest: {
    /**
     * Serializes BwatchReq.ListAssetsRequest to JSON.
     */
    encode: function (_msg?: PartialDeep<BwatchReq.ListAssetsRequest>): string {
      return "{}";
    },

    /**
     * Deserializes BwatchReq.ListAssetsRequest from JSON.
     */
    decode: function (_json?: string): BwatchReq.ListAssetsRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.ListAssetsRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListAssetsRequest>,
    ): BwatchReq.ListAssetsRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.ListAssetsRequest>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ListAssetsRequest,
      _json: any,
    ): BwatchReq.ListAssetsRequest {
      return msg;
    },
  },

  ListEtfsRequest: {
    /**
     * Serializes BwatchReq.ListEtfsRequest to JSON.
     */
    encode: function (_msg?: PartialDeep<BwatchReq.ListEtfsRequest>): string {
      return "{}";
    },

    /**
     * Deserializes BwatchReq.ListEtfsRequest from JSON.
     */
    decode: function (_json?: string): BwatchReq.ListEtfsRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.ListEtfsRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListEtfsRequest>,
    ): BwatchReq.ListEtfsRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.ListEtfsRequest>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ListEtfsRequest,
      _json: any,
    ): BwatchReq.ListEtfsRequest {
      return msg;
    },
  },

  ReadEtfRequest: {
    /**
     * Serializes BwatchReq.ReadEtfRequest to JSON.
     */
    encode: function (msg: PartialDeep<BwatchReq.ReadEtfRequest>): string {
      return JSON.stringify(BwatchReqJSON.ReadEtfRequest._writeMessage(msg));
    },

    /**
     * Deserializes BwatchReq.ReadEtfRequest from JSON.
     */
    decode: function (json: string): BwatchReq.ReadEtfRequest {
      return BwatchReqJSON.ReadEtfRequest._readMessage(
        BwatchReqJSON.ReadEtfRequest.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchReq.ReadEtfRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ReadEtfRequest>,
    ): BwatchReq.ReadEtfRequest {
      return {
        etf: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ReadEtfRequest>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.etf) {
        json["etf"] = msg.etf;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ReadEtfRequest,
      json: any,
    ): BwatchReq.ReadEtfRequest {
      const _etf_ = json["etf"];
      if (_etf_) {
        msg.etf = _etf_;
      }
      return msg;
    },
  },

  ReadSubscriptionRequest: {
    /**
     * Serializes BwatchReq.ReadSubscriptionRequest to JSON.
     */
    encode: function (
      msg: PartialDeep<BwatchReq.ReadSubscriptionRequest>,
    ): string {
      return JSON.stringify(
        BwatchReqJSON.ReadSubscriptionRequest._writeMessage(msg),
      );
    },

    /**
     * Deserializes BwatchReq.ReadSubscriptionRequest from JSON.
     */
    decode: function (json: string): BwatchReq.ReadSubscriptionRequest {
      return BwatchReqJSON.ReadSubscriptionRequest._readMessage(
        BwatchReqJSON.ReadSubscriptionRequest.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchReq.ReadSubscriptionRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ReadSubscriptionRequest>,
    ): BwatchReq.ReadSubscriptionRequest {
      return {
        followId: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ReadSubscriptionRequest>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.followId) {
        json["followId"] = msg.followId;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ReadSubscriptionRequest,
      json: any,
    ): BwatchReq.ReadSubscriptionRequest {
      const _followId_ = json["followId"] ?? json["follow_id"];
      if (_followId_) {
        msg.followId = _followId_;
      }
      return msg;
    },
  },

  ListTransfersRequest: {
    /**
     * Serializes BwatchReq.ListTransfersRequest to JSON.
     */
    encode: function (
      msg: PartialDeep<BwatchReq.ListTransfersRequest>,
    ): string {
      return JSON.stringify(
        BwatchReqJSON.ListTransfersRequest._writeMessage(msg),
      );
    },

    /**
     * Deserializes BwatchReq.ListTransfersRequest from JSON.
     */
    decode: function (json: string): BwatchReq.ListTransfersRequest {
      return BwatchReqJSON.ListTransfersRequest._readMessage(
        BwatchReqJSON.ListTransfersRequest.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchReq.ListTransfersRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.ListTransfersRequest>,
    ): BwatchReq.ListTransfersRequest {
      return {
        group: 0n,
        status: Transfer.Status._fromInt(0),
        limit: 0,
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchReq.ListTransfersRequest>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.group) {
        json["group"] = String(msg.group);
      }
      if (msg.status && TransferJSON.Status._toInt(msg.status)) {
        json["status"] = msg.status;
      }
      if (msg.limit) {
        json["limit"] = msg.limit;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.ListTransfersRequest,
      json: any,
    ): BwatchReq.ListTransfersRequest {
      const _group_ = json["group"];
      if (_group_) {
        msg.group = BigInt(_group_);
      }
      const _status_ = json["status"];
      if (_status_) {
        msg.status = Transfer.Status._fromInt(_status_);
      }
      const _limit_ = json["limit"];
      if (_limit_) {
        msg.limit = protoscript.parseNumber(_limit_);
      }
      return msg;
    },
  },

  GetInfoRequest: {
    /**
     * Serializes BwatchReq.GetInfoRequest to JSON.
     */
    encode: function (_msg?: PartialDeep<BwatchReq.GetInfoRequest>): string {
      return "{}";
    },

    /**
     * Deserializes BwatchReq.GetInfoRequest from JSON.
     */
    decode: function (_json?: string): BwatchReq.GetInfoRequest {
      return {};
    },

    /**
     * Initializes BwatchReq.GetInfoRequest with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchReq.GetInfoRequest>,
    ): BwatchReq.GetInfoRequest {
      return {
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<BwatchReq.GetInfoRequest>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchReq.GetInfoRequest,
      _json: any,
    ): BwatchReq.GetInfoRequest {
      return msg;
    },
  },
};

export const BwatchRespJSON = {
  /**
   * Serializes BwatchResp to JSON.
   */
  encode: function (_msg?: PartialDeep<BwatchResp>): string {
    return "{}";
  },

  /**
   * Deserializes BwatchResp from JSON.
   */
  decode: function (_json?: string): BwatchResp {
    return {};
  },

  /**
   * Initializes BwatchResp with all fields set to their default value.
   */
  initialize: function (msg?: Partial<BwatchResp>): BwatchResp {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BwatchResp>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BwatchResp, _json: any): BwatchResp {
    return msg;
  },

  ListAssetsResponse: {
    /**
     * Serializes BwatchResp.ListAssetsResponse to JSON.
     */
    encode: function (msg: PartialDeep<BwatchResp.ListAssetsResponse>): string {
      return JSON.stringify(
        BwatchRespJSON.ListAssetsResponse._writeMessage(msg),
      );
    },

    /**
     * Deserializes BwatchResp.ListAssetsResponse from JSON.
     */
    decode: function (json: string): BwatchResp.ListAssetsResponse {
      return BwatchRespJSON.ListAssetsResponse._readMessage(
        BwatchRespJSON.ListAssetsResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.ListAssetsResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListAssetsResponse>,
    ): BwatchResp.ListAssetsResponse {
      return {
        assets: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListAssetsResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.assets?.length) {
        json["assets"] = msg.assets.map(AssetJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListAssetsResponse,
      json: any,
    ): BwatchResp.ListAssetsResponse {
      const _assets_ = json["assets"];
      if (_assets_) {
        for (const item of _assets_) {
          const m = AssetJSON.initialize();
          AssetJSON._readMessage(m, item);
          msg.assets.push(m);
        }
      }
      return msg;
    },
  },

  ListEtfsResponse: {
    /**
     * Serializes BwatchResp.ListEtfsResponse to JSON.
     */
    encode: function (msg: PartialDeep<BwatchResp.ListEtfsResponse>): string {
      return JSON.stringify(BwatchRespJSON.ListEtfsResponse._writeMessage(msg));
    },

    /**
     * Deserializes BwatchResp.ListEtfsResponse from JSON.
     */
    decode: function (json: string): BwatchResp.ListEtfsResponse {
      return BwatchRespJSON.ListEtfsResponse._readMessage(
        BwatchRespJSON.ListEtfsResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.ListEtfsResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListEtfsResponse>,
    ): BwatchResp.ListEtfsResponse {
      return {
        etfs: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListEtfsResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.etfs?.length) {
        json["etfs"] = msg.etfs.map(EtfJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListEtfsResponse,
      json: any,
    ): BwatchResp.ListEtfsResponse {
      const _etfs_ = json["etfs"];
      if (_etfs_) {
        for (const item of _etfs_) {
          const m = EtfJSON.initialize();
          EtfJSON._readMessage(m, item);
          msg.etfs.push(m);
        }
      }
      return msg;
    },
  },

  ReadEtfResponse: {
    /**
     * Serializes BwatchResp.ReadEtfResponse to JSON.
     */
    encode: function (msg: PartialDeep<BwatchResp.ReadEtfResponse>): string {
      return JSON.stringify(BwatchRespJSON.ReadEtfResponse._writeMessage(msg));
    },

    /**
     * Deserializes BwatchResp.ReadEtfResponse from JSON.
     */
    decode: function (json: string): BwatchResp.ReadEtfResponse {
      return BwatchRespJSON.ReadEtfResponse._readMessage(
        BwatchRespJSON.ReadEtfResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.ReadEtfResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ReadEtfResponse>,
    ): BwatchResp.ReadEtfResponse {
      return {
        etf: EtfJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ReadEtfResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.etf) {
        const _etf_ = EtfJSON._writeMessage(msg.etf);
        if (Object.keys(_etf_).length > 0) {
          json["etf"] = _etf_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ReadEtfResponse,
      json: any,
    ): BwatchResp.ReadEtfResponse {
      const _etf_ = json["etf"];
      if (_etf_) {
        EtfJSON._readMessage(msg.etf, _etf_);
      }
      return msg;
    },
  },

  ReadSubscriptionResponse: {
    /**
     * Serializes BwatchResp.ReadSubscriptionResponse to JSON.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ReadSubscriptionResponse>,
    ): string {
      return JSON.stringify(
        BwatchRespJSON.ReadSubscriptionResponse._writeMessage(msg),
      );
    },

    /**
     * Deserializes BwatchResp.ReadSubscriptionResponse from JSON.
     */
    decode: function (json: string): BwatchResp.ReadSubscriptionResponse {
      return BwatchRespJSON.ReadSubscriptionResponse._readMessage(
        BwatchRespJSON.ReadSubscriptionResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.ReadSubscriptionResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ReadSubscriptionResponse>,
    ): BwatchResp.ReadSubscriptionResponse {
      return {
        sub: SubscriptionJSON.initialize(),
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ReadSubscriptionResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.sub) {
        const _sub_ = SubscriptionJSON._writeMessage(msg.sub);
        if (Object.keys(_sub_).length > 0) {
          json["sub"] = _sub_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ReadSubscriptionResponse,
      json: any,
    ): BwatchResp.ReadSubscriptionResponse {
      const _sub_ = json["sub"];
      if (_sub_) {
        SubscriptionJSON._readMessage(msg.sub, _sub_);
      }
      return msg;
    },
  },

  ListTransfersResponse: {
    /**
     * Serializes BwatchResp.ListTransfersResponse to JSON.
     */
    encode: function (
      msg: PartialDeep<BwatchResp.ListTransfersResponse>,
    ): string {
      return JSON.stringify(
        BwatchRespJSON.ListTransfersResponse._writeMessage(msg),
      );
    },

    /**
     * Deserializes BwatchResp.ListTransfersResponse from JSON.
     */
    decode: function (json: string): BwatchResp.ListTransfersResponse {
      return BwatchRespJSON.ListTransfersResponse._readMessage(
        BwatchRespJSON.ListTransfersResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.ListTransfersResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.ListTransfersResponse>,
    ): BwatchResp.ListTransfersResponse {
      return {
        transfers: [],
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.ListTransfersResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.transfers?.length) {
        json["transfers"] = msg.transfers.map(TransferJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.ListTransfersResponse,
      json: any,
    ): BwatchResp.ListTransfersResponse {
      const _transfers_ = json["transfers"];
      if (_transfers_) {
        for (const item of _transfers_) {
          const m = TransferJSON.initialize();
          TransferJSON._readMessage(m, item);
          msg.transfers.push(m);
        }
      }
      return msg;
    },
  },

  GetInfoResponse: {
    /**
     * Serializes BwatchResp.GetInfoResponse to JSON.
     */
    encode: function (msg: PartialDeep<BwatchResp.GetInfoResponse>): string {
      return JSON.stringify(BwatchRespJSON.GetInfoResponse._writeMessage(msg));
    },

    /**
     * Deserializes BwatchResp.GetInfoResponse from JSON.
     */
    decode: function (json: string): BwatchResp.GetInfoResponse {
      return BwatchRespJSON.GetInfoResponse._readMessage(
        BwatchRespJSON.GetInfoResponse.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes BwatchResp.GetInfoResponse with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<BwatchResp.GetInfoResponse>,
    ): BwatchResp.GetInfoResponse {
      return {
        members: [],
        threshold: 0,
        version: "",
        mixAddress: "",
        blockedActions: [],
        country: "",
        countryCode: "",
        restricted: false,
        ip: "",
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<BwatchResp.GetInfoResponse>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.members?.length) {
        json["members"] = msg.members;
      }
      if (msg.threshold) {
        json["threshold"] = msg.threshold;
      }
      if (msg.version) {
        json["version"] = msg.version;
      }
      if (msg.mixAddress) {
        json["mixAddress"] = msg.mixAddress;
      }
      if (msg.blockedActions?.length) {
        json["blockedActions"] = msg.blockedActions;
      }
      if (msg.country) {
        json["country"] = msg.country;
      }
      if (msg.countryCode) {
        json["countryCode"] = msg.countryCode;
      }
      if (msg.restricted) {
        json["restricted"] = msg.restricted;
      }
      if (msg.ip) {
        json["ip"] = msg.ip;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: BwatchResp.GetInfoResponse,
      json: any,
    ): BwatchResp.GetInfoResponse {
      const _members_ = json["members"];
      if (_members_) {
        msg.members = _members_;
      }
      const _threshold_ = json["threshold"];
      if (_threshold_) {
        msg.threshold = protoscript.parseNumber(_threshold_);
      }
      const _version_ = json["version"];
      if (_version_) {
        msg.version = _version_;
      }
      const _mixAddress_ = json["mixAddress"] ?? json["mix_address"];
      if (_mixAddress_) {
        msg.mixAddress = _mixAddress_;
      }
      const _blockedActions_ =
        json["blockedActions"] ?? json["blocked_actions"];
      if (_blockedActions_) {
        msg.blockedActions = _blockedActions_.map(Action._fromInt);
      }
      const _country_ = json["country"];
      if (_country_) {
        msg.country = _country_;
      }
      const _countryCode_ = json["countryCode"] ?? json["country_code"];
      if (_countryCode_) {
        msg.countryCode = _countryCode_;
      }
      const _restricted_ = json["restricted"];
      if (_restricted_) {
        msg.restricted = _restricted_;
      }
      const _ip_ = json["ip"];
      if (_ip_) {
        msg.ip = _ip_;
      }
      return msg;
    },
  },
};
